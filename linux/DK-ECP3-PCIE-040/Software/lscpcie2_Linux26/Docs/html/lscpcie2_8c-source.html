<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Lattice lscpcie2 Device Driver : lscpcie2.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>lscpcie2.c</h1><a href="lscpcie2_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment"> *  COPYRIGHT (c) 2007 by Lattice Semiconductor Corporation</span>
00003 <span class="comment"> *</span>
00004 <span class="comment"> * All rights reserved. All use of this software and documentation is</span>
00005 <span class="comment"> * subject to the License Agreement located in the file LICENSE.</span>
00006 <span class="comment"> */</span>
00111 <span class="preprocessor">#include &lt;linux/init.h&gt;</span>
00112 <span class="preprocessor">#include &lt;linux/module.h&gt;</span>
00113 <span class="preprocessor">#include &lt;linux/version.h&gt;</span>
00114 <span class="preprocessor">#include &lt;linux/kernel.h&gt;</span>
00115 
00116 <span class="preprocessor">#include &lt;linux/fs.h&gt;</span>
00117 <span class="preprocessor">#include &lt;linux/errno.h&gt;</span>
00118 <span class="preprocessor">#include &lt;linux/miscdevice.h&gt;</span>
00119 <span class="preprocessor">#include &lt;linux/major.h&gt;</span>
00120 <span class="preprocessor">#include &lt;linux/slab.h&gt;</span>
00121 <span class="preprocessor">#include &lt;linux/proc_fs.h&gt;</span>
00122 <span class="comment">//#include &lt;linux/devfs_fs_kernel.h&gt;</span>
00123 <span class="preprocessor">#include &lt;linux/stat.h&gt;</span>
00124 <span class="preprocessor">#include &lt;linux/init.h&gt;</span>
00125 
00126 <span class="preprocessor">#include &lt;linux/tty.h&gt;</span>
00127 <span class="preprocessor">#include &lt;linux/selection.h&gt;</span>
00128 <span class="preprocessor">#include &lt;linux/kmod.h&gt;</span>
00129 
00130 <span class="comment">/* For devices that use/implement shared memory (mmap) */</span>
00131 <span class="preprocessor">#include &lt;linux/mm.h&gt;</span>
00132 <span class="preprocessor">#include &lt;linux/vmalloc.h&gt;</span>
00133 <span class="preprocessor">#include &lt;linux/pagemap.h&gt;</span>
00134 <span class="preprocessor">#include &lt;linux/pci.h&gt;</span>
00135 <span class="preprocessor">#include &lt;linux/mman.h&gt;</span>
00136 
00137 <span class="preprocessor">#include &lt;asm/uaccess.h&gt;</span>
00138 <span class="preprocessor">#include &lt;asm/io.h&gt;</span>
00139 <span class="preprocessor">#include &lt;asm/pgalloc.h&gt;</span>
00140 
00141 <span class="preprocessor">#include "<a class="code" href="_ioctl_8h.html">Ioctl.h</a>"</span>
00142 
00143 <span class="preprocessor">#ifndef CONFIG_PCI</span>
00144 <span class="preprocessor"></span><span class="preprocessor">    #error No PCI Bus Support in kernel!</span>
00145 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00146 <span class="preprocessor"></span>
00147 <span class="preprocessor">#define USE_PROC  </span><span class="comment">/* For debugging */</span>
00148 
00149 <span class="comment">// Some Useful defines</span>
00150 <span class="preprocessor">#ifndef TRUE</span>
00151 <span class="preprocessor"></span><span class="preprocessor">#define TRUE 1</span>
00152 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00153 <span class="preprocessor"></span><span class="preprocessor">#ifndef FALSE</span>
00154 <span class="preprocessor"></span><span class="preprocessor">#define FALSE 0</span>
00155 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00156 <span class="preprocessor"></span><span class="preprocessor">#ifndef OK</span>
00157 <span class="preprocessor"></span><span class="preprocessor">#define OK 0</span>
00158 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00159 <span class="preprocessor"></span><span class="preprocessor">#ifndef ERROR</span>
00160 <span class="preprocessor"></span><span class="preprocessor">#define ERROR -1</span>
00161 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00162 <span class="preprocessor"></span>
00163 <span class="comment">/* Change these defines to increase number of boards supported by the driver */</span>
00164 
00165 <span class="preprocessor">#define NUM_BARS MAX_PCI_BARS  </span><span class="comment">/* defined in Ioctl.h */</span>
00166 <span class="preprocessor">#define NUM_BOARDS 4          // 4 PCIe boards per system is a lot of PCIe slots and eval boards to have on hand</span>
00167 <span class="preprocessor"></span><span class="preprocessor">#define MAX_BOARDS (NUM_BOARDS) </span>
00168 <span class="preprocessor"></span><span class="preprocessor">#define MINORS_PER_BOARD 1     // 1 minor number per discrete device</span>
00169 <span class="preprocessor"></span><span class="preprocessor">#define MAX_MINORS (MAX_BOARDS * MINORS_PER_BOARD)  </span>
00170 <span class="preprocessor"></span>
00171 
00172 <span class="preprocessor">#define DMA_BUFFER_SIZE (64 * 1024)</span>
00173 <span class="preprocessor"></span>
00174 
00175 <span class="comment">// Note: used as indexes into lists of strings</span>
00176 <span class="preprocessor">#define SC_BOARD    1</span>
00177 <span class="preprocessor"></span><span class="preprocessor">#define ECP2M_BOARD 2</span>
00178 <span class="preprocessor"></span><span class="preprocessor">#define BASIC_DEMO  1</span>
00179 <span class="preprocessor"></span><span class="preprocessor">#define SFIF_DEMO   2</span>
00180 <span class="preprocessor"></span>
00181 
00182 MODULE_AUTHOR(<span class="stringliteral">"Lattice Semiconductor"</span>);
00183 MODULE_DESCRIPTION(<span class="stringliteral">"Lattice PCIe Eval Board Device Driver"</span>);
00184 
00185 <span class="comment">/* License this so no annoying messages when loading module */</span>
00186 MODULE_LICENSE(<span class="stringliteral">"Dual BSD/GPL"</span>);
00187 
00188 MODULE_ALIAS(<span class="stringliteral">"lscpcie2"</span>);
00189 
00190 
00191 
00192 
00193 
00194 <span class="comment">/*-------------------------------------------------*/</span>
00195 <span class="comment">/*-------------------------------------------------*/</span>
00196 <span class="comment">/*-------------------------------------------------*/</span>
00197 <span class="comment">/*           DATA TYPES</span>
00198 <span class="comment"> */</span>
00199 <span class="comment">/*-------------------------------------------------*/</span>
00200 <span class="comment">/*-------------------------------------------------*/</span>
00201 <span class="comment">/*-------------------------------------------------*/</span>
00202 
00208 <span class="keyword">typedef</span> <span class="keyword">struct </span>PCI_Dev_BAR
00209 {
00210     <span class="keywordtype">int</span>          bar;
00211     <span class="keywordtype">void</span>         *pci_addr; 
00212     <span class="keywordtype">void</span>         *kvm_addr; 
00213     <span class="keywordtype">int</span>          memType;
00214     <span class="keywordtype">int</span>          dataSize;
00215     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> len;
00216     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> pci_start;   <span class="comment">/* info gathered from pci_resource_*() */</span>
00217     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> pci_end;
00218     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> pci_flags;
00219 } <a class="code" href="lscpcie2_8c.html#a13">pci_dev_bar_t</a>;
00220 
00221 
00222 <span class="keyword">typedef</span> <span class="keyword">struct </span>PCIE_Board
00223 {
00224     u32     ID;      
00225     u32     demoID;   
00226     u32     demoType;  
00227     u32 boardType; 
00228     u32     instanceNum;   
00229     u32 majorNum;      
00230     u32 minorNum;      
00231     u32     numBars;           
00232     <span class="keywordtype">int</span>     IRQ;               
00234     <span class="comment">//---------------- BAR Assignments -------------</span>
00235     u32 mmapBAR;          
00236     u32 ctrlBAR;          
00237     <span class="keywordtype">void</span>    *ctrlBARaddr;     
00240     <span class="comment">//---------------- DMA Buffer -------------</span>
00241     <span class="keywordtype">bool</span>    hasDMA;        
00242     size_t  dmaBufSize;    
00243     dma_addr_t dmaPCIBusAddr;  
00244     <span class="keywordtype">void</span>    *dmaCPUAddr;       
00247     <span class="keyword">struct  </span>pci_dev *pPciDev;  
00249     <a class="code" href="lscpcie2_8c.html#a13">pci_dev_bar_t</a> Dev_BARs[NUM_BARS];  
00251     <span class="keyword">struct </span>cdev charDev; 
00254 } pcie_board_t;
00255 
00256 
00257 
00263 <span class="keyword">typedef</span> <span class="keyword">struct </span>LSCPCIe2
00264 {
00265 
00266     dev_t   drvrDevNum;      
00267     u32     numBoards;       
00269     u8  numSC_Basic;     
00270     u8  numSC_SFIF;      
00271     u8  numECP2M_Basic;      
00272     u8  numECP2M_SFIF;      
00275 <span class="preprocessor">#if (LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,6,12))</span>
00276 <span class="preprocessor"></span>    <span class="keyword">struct </span>class *sysClass;   
00277 <span class="preprocessor">#else</span>
00278 <span class="preprocessor"></span>    <span class="keyword">struct </span>class_simple *sysClass;   
00279 <span class="preprocessor">#endif</span>
00280 <span class="preprocessor"></span>
00281 
00282     pcie_board_t Board[NUM_BOARDS];  
00284 } <a class="code" href="lscpcie2_8c.html#a15">lscpcie2_t</a>;
00285 
00286 
00287 <span class="comment">/*-------------------------------------------------*/</span>
00288 <span class="comment">/*-------------------------------------------------*/</span>
00289 <span class="comment">/*-------------------------------------------------*/</span>
00290 <span class="comment">/*</span>
00291 <span class="comment"> *            DRIVER GLOBAL VARIABLES</span>
00292 <span class="comment"> */</span>
00293 <span class="comment">/*-------------------------------------------------*/</span>
00294 <span class="comment">/*-------------------------------------------------*/</span>
00295 <span class="comment">/*-------------------------------------------------*/</span>
00296 
00297 
00301 <span class="keyword">static</span> <a class="code" href="lscpcie2_8c.html#a15">lscpcie2_t</a> lscpcie2;
00302 
00303 
00304 
00305 <span class="keyword">static</span> <span class="keywordtype">int</span> DrvrDebug = 0;
00306 
00307 
00308 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> Version[] = <span class="stringliteral">"lscpcie2 v2.1.6 - Rd/Wr added"</span>;  
00311 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *BoardName[3] = {<span class="stringliteral">"??"</span>, <span class="stringliteral">"SC"</span>, <span class="stringliteral">"ECP2M"</span>};
00312 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *DemoName[3] = {<span class="stringliteral">"??"</span>, <span class="stringliteral">"Basic"</span>, <span class="stringliteral">"SFIF"</span>};
00313 
00314 
00315 
00319 <span class="keyword">static</span> <span class="keyword">struct </span>pci_device_id lscpcie2_pci_id_tbl[] = 
00320 {
00321     { 0x1204, 0x5303, 0x1204, 0x3030, },   <span class="comment">// SC SFIF</span>
00322     { 0x1204, 0xe250, 0x1204, 0x3030, },   <span class="comment">// ECP2M SFIF</span>
00323     { 0x1204, 0xe250, 0x1204, 0x3010, },   <span class="comment">// ECP2M50 Basic on Sol. Brd</span>
00324     { 0x1204, 0x5303, 0x1204, 0x3010, },   <span class="comment">// SC Basic</span>
00325 <span class="preprocessor">#if 0</span>
00326 <span class="preprocessor"></span>    { 0x1204, 0xe235, 0x1204, 0xe235, },   <span class="comment">// ECP2M Basic - old ID; enable if have old demo bitstream</span>
00327     { 0x1204, 0xe235, 0x1204, 0x5303, },   <span class="comment">// ECP2M Basic - old ID; enable if have old demo bitstream</span>
00328     { 0x1204, 0x5303, 0x1204, 0x5303, },   <span class="comment">// SC Basic - old ID;  enable if have old demo bitstream</span>
00329 <span class="preprocessor">#endif</span>
00330 <span class="preprocessor"></span>    { }         <span class="comment">/* Terminating entry */</span>
00331 };
00332 
00333 MODULE_DEVICE_TABLE(pci, lscpcie2_pci_id_tbl);
00334 
00335 
00336 <span class="comment">/*========================================================================*/</span>
00337 <span class="comment">/*========================================================================*/</span>
00338 <span class="comment">/*========================================================================*/</span>
00339 <span class="comment">/*</span>
00340 <span class="comment"> *            PROC DEBUG STUFF</span>
00341 <span class="comment"> */</span>
00342 <span class="comment">/*========================================================================*/</span>
00343 <span class="comment">/*========================================================================*/</span>
00344 <span class="comment">/*========================================================================*/</span>
00345 <span class="preprocessor">#ifdef USE_PROC </span><span class="comment">/* don't waste space if unused */</span>
00346 
<a name="l00353"></a><a class="code" href="lscpcie2_8c.html#a30">00353</a> <span class="keywordtype">int</span> <a class="code" href="lscpcie2_8c.html#a30">lscpcie2_read_procmem</a>(<span class="keywordtype">char</span> *buf, <span class="keywordtype">char</span> **start, off_t offset,
00354                          <span class="keywordtype">int</span> count, <span class="keywordtype">int</span> *eof, <span class="keywordtype">void</span> *data)
00355 {
00356     <span class="keywordtype">int</span> i, n;
00357     <span class="keywordtype">int</span> len = 0;
00358     <span class="comment">// int limit = count - 80; /* Don't print more than this */</span>
00359     <a class="code" href="lscpcie2_8c.html#a13">pci_dev_bar_t</a> *p;  
00360 
00361     *start = buf + offset;
00362 
00363     <span class="keywordflow">if</span> (DrvrDebug)
00364         printk(KERN_INFO <span class="stringliteral">"lscpcie2: /proc entry created\n"</span>);
00365 
00366     <span class="comment">/* Put any messages in here that will be displayed by cat /proc/driver/.. */</span>
00367     len += sprintf(buf+len, <span class="stringliteral">"\nLSC PCIE Device Driver Info\n"</span>);
00368     len += sprintf(buf+len, <span class="stringliteral">"\nNumBoards: %d  Major#: %d\n"</span>, lscpcie2.numBoards, MAJOR(lscpcie2.drvrDevNum));
00369 
00370     <span class="keywordflow">for</span> (n = 0; n &lt; NUM_BOARDS; n++)
00371     {
00372 
00373         <span class="keywordflow">if</span> (lscpcie2.Board[n].ID != 0)
00374         {
00375 
00376             len += sprintf(buf+len, <span class="stringliteral">"Board:%d = %x  Demo=%x IRQ=%d\n"</span>, lscpcie2.Board[n].instanceNum, 
00377                                     lscpcie2.Board[n].ID,
00378                                     lscpcie2.Board[n].demoID,
00379                                     lscpcie2.Board[n].IRQ);
00380 
00381             <span class="keywordflow">for</span> (i = 0; i &lt; NUM_BARS; i++)
00382             {
00383                 p = &amp;lscpcie2.Board[n].Dev_BARs[i];
00384                 len += sprintf(buf+len, <span class="stringliteral">"BAR[%d]  pci_addr=%p  kvm_addr=%p\n"</span>
00385                                <span class="stringliteral">"          type=%d  dataSize=%d  len=%ld\n"</span>
00386                                <span class="stringliteral">"          start=%lx  end=%lx  flags=%lx\n"</span>,
00387                                i, 
00388                                p-&gt;pci_addr,
00389                                p-&gt;kvm_addr,
00390                                p-&gt;memType,
00391                                p-&gt;dataSize,
00392                                p-&gt;len,
00393                                p-&gt;pci_start,
00394                                p-&gt;pci_end,
00395                                p-&gt;pci_flags);
00396             }
00397         }
00398     }
00399 
00400     <span class="keywordflow">if</span> (len &lt; offset + count)
00401         *eof = 1;   <span class="comment">/* Mark that this is a complete buffer (the End of File) */</span>
00402 
00403     <span class="comment">/* Not sure about all this, but it works */</span>
00404     len = len - offset;
00405     <span class="keywordflow">if</span> (len &gt; count)
00406         len = count;
00407     <span class="keywordflow">if</span> (len &lt; 0)
00408         len = 0;
00409 
00410 
00411     <span class="keywordflow">return</span>(len);
00412 }
00413 
00414 
00415 <span class="preprocessor">#endif </span><span class="comment">/* USE_PROC */</span>
00416 
00417 
00418 
00425 <span class="keyword">static</span> pcie_board_t* initBoard(<span class="keyword">struct</span> pci_dev *PCI_Dev_Cfg, <span class="keywordtype">void</span> * devID)
00426 {
00427     <span class="keywordtype">int</span> i;
00428     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> irq;
00429     pcie_board_t *pBrd;
00430     <a class="code" href="lscpcie2_8c.html#a13">pci_dev_bar_t</a> *pBAR;
00431     <a class="code" href="lscpcie2_8c.html#a13">pci_dev_bar_t</a> *p;
00432     u16 SubSystem;
00433     u16 VendorID;
00434     u16 DeviceID;
00435 
00436     <span class="comment">/****************************************************/</span>
00437     <span class="comment">/* Device info passed in from the PCI controller via probe() */</span>
00438     <span class="comment">/****************************************************/</span>
00439 
00440 <span class="comment">// TODO</span>
00441 <span class="comment">// Add writing an 'E' to the LEDs to show an error if initialization fails</span>
00442 <span class="comment">// Problem is we don't have BARs setup till end of function :-(</span>
00443 
00444 
00445     <span class="keywordflow">if</span> (DrvrDebug)
00446         printk(KERN_INFO <span class="stringliteral">"lscpcie2: init EvalBoard\n"</span>);
00447 
00448     <span class="comment">/* Next available board structure in data base */</span>
00449     pBrd = &amp;lscpcie2.Board[lscpcie2.numBoards];
00450 
00451     <span class="keywordflow">if</span> (pci_read_config_word(PCI_Dev_Cfg, PCI_VENDOR_ID, &amp;VendorID))
00452     {
00453         printk(KERN_ERR <span class="stringliteral">"lscpcie2: init EvalBoard cfg access failed!\n"</span>);
00454         <span class="keywordflow">return</span>(NULL);
00455     }
00456     <span class="keywordflow">if</span> (VendorID != 0x1204)
00457     {
00458         printk(KERN_ERR <span class="stringliteral">"lscpcie2: init EvalBoard not Lattice ID!\n"</span>);
00459         <span class="keywordflow">return</span>(NULL);
00460     }
00461 
00462     <span class="keywordflow">if</span> (pci_read_config_word(PCI_Dev_Cfg, PCI_DEVICE_ID, &amp;DeviceID))
00463     {
00464         printk(KERN_ERR <span class="stringliteral">"lscpcie2: init EvalBoard cfg access failed!\n"</span>);
00465         <span class="keywordflow">return</span>(NULL);
00466     }
00467 
00468     <span class="keywordflow">if</span> (pci_read_config_word(PCI_Dev_Cfg, PCI_SUBSYSTEM_ID, &amp;SubSystem))
00469     {
00470         printk(KERN_ERR <span class="stringliteral">"lscpcie2: init EvalBoard cfg access failed!\n"</span>);
00471         <span class="keywordflow">return</span>(NULL);
00472     }
00473 
00474     pBrd-&gt;ID = DeviceID;
00475     pBrd-&gt;demoID = SubSystem;
00476     pBrd-&gt;pPciDev = PCI_Dev_Cfg;
00477     pBrd-&gt;majorNum = MAJOR(lscpcie2.drvrDevNum);
00478     pBrd-&gt;minorNum = MINOR(lscpcie2.drvrDevNum) + lscpcie2.numBoards;
00479 
00480 
00481     <span class="comment">// Figure out if board is SC or ECP2M, if demo is Basic or SFIF</span>
00482     <span class="keywordflow">if</span> ((DeviceID == 0x5303) &amp;&amp; (SubSystem == 0x3030))
00483     {
00484         ++lscpcie2.numSC_SFIF;
00485         pBrd-&gt;instanceNum  = lscpcie2.numSC_SFIF;
00486         pBrd-&gt;boardType = SC_BOARD;
00487         pBrd-&gt;demoType = SFIF_DEMO;
00488         pBrd-&gt;ctrlBAR = 0;
00489     }
00490     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((DeviceID == 0xe250) &amp;&amp; (SubSystem == 0x3030))
00491     {
00492         ++lscpcie2.numECP2M_SFIF;
00493         pBrd-&gt;instanceNum  = lscpcie2.numECP2M_SFIF;
00494         pBrd-&gt;boardType = ECP2M_BOARD;
00495         pBrd-&gt;demoType = SFIF_DEMO;
00496         pBrd-&gt;ctrlBAR = 0;
00497     }
00498     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((DeviceID == 0x5303) &amp;&amp; (SubSystem == 0x3010))
00499     {
00500         ++lscpcie2.numSC_Basic;
00501         pBrd-&gt;instanceNum  = lscpcie2.numSC_Basic;
00502         pBrd-&gt;boardType = SC_BOARD;
00503         pBrd-&gt;demoType = BASIC_DEMO;
00504         pBrd-&gt;ctrlBAR = 0;
00505     }
00506     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((DeviceID == 0xe250) &amp;&amp; (SubSystem == 0x3010))
00507     {
00508         ++lscpcie2.numECP2M_Basic;
00509         pBrd-&gt;instanceNum  = lscpcie2.numECP2M_Basic;
00510         pBrd-&gt;boardType = ECP2M_BOARD;
00511         pBrd-&gt;demoType = BASIC_DEMO;
00512         pBrd-&gt;ctrlBAR = 0;
00513     }
00514 <span class="preprocessor">#if 0  // OLD DEMO ID's for old bitstreams and boards</span>
00515 <span class="preprocessor"></span>    <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((DeviceID == 0x5303) &amp;&amp; (SubSystem == 0x5303))
00516     {
00517         ++lscpcie2.numSC_Basic;
00518         pBrd-&gt;instanceNum  = lscpcie2.numSC_Basic;
00519         pBrd-&gt;boardType = SC_BOARD;
00520         pBrd-&gt;demoType = BASIC_DEMO;
00521         pBrd-&gt;ctrlBAR = 1;
00522     }
00523     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((DeviceID == 0xe235) &amp;&amp; (SubSystem == 0x5303))
00524     {
00525         ++lscpcie2.numECP2M_Basic;
00526         pBrd-&gt;instanceNum  = lscpcie2.numECP2M_Basic;
00527         pBrd-&gt;boardType = ECP2M_BOARD;
00528         pBrd-&gt;demoType = BASIC_DEMO;
00529         pBrd-&gt;ctrlBAR = 1;
00530     }
00531     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((DeviceID == 0xe235) &amp;&amp; (SubSystem == 0xe235))
00532     {
00533         ++lscpcie2.numECP2M_Basic;
00534         pBrd-&gt;instanceNum  = lscpcie2.numECP2M_Basic;
00535         pBrd-&gt;boardType = ECP2M_BOARD;
00536         pBrd-&gt;demoType = BASIC_DEMO;
00537         pBrd-&gt;ctrlBAR = 1;
00538     }
00539 <span class="preprocessor">#endif</span>
00540 <span class="preprocessor"></span>    <span class="keywordflow">else</span>
00541     {
00542         printk(KERN_ERR <span class="stringliteral">"lscpcie2: init ERROR! unknown board: %x %x\n"</span>, DeviceID, SubSystem);
00543         pBrd-&gt;instanceNum  = 0;
00544         pBrd-&gt;boardType = 0;
00545         pBrd-&gt;demoType = 0;
00546         <span class="keywordflow">return</span>(NULL);
00547     }
00548 
00549     <span class="comment">// For now, all demos use only one BAR and that BAR is for control plane and is also what will</span>
00550     <span class="comment">// be mmap'ed into user space for the driver interface to access.</span>
00551     pBrd-&gt;mmapBAR = pBrd-&gt;ctrlBAR;
00552 
00553 
00554     <span class="comment">//=============== Interrupt handling stuff ========================</span>
00555     <span class="keywordflow">if</span> (pci_read_config_byte(PCI_Dev_Cfg, PCI_INTERRUPT_LINE, &amp;irq))
00556         pBrd-&gt;IRQ = -1;  <span class="comment">// no interrupt</span>
00557     <span class="keywordflow">else</span>
00558         pBrd-&gt;IRQ = irq;
00559 
00560     <span class="keywordflow">if</span> (DrvrDebug)
00561     {
00562         printk(KERN_INFO <span class="stringliteral">"lscpcie2: init brdID: %x  demoID: %x\n"</span>, DeviceID, SubSystem);
00563         printk(KERN_INFO <span class="stringliteral">"lscpcie2: init Board[] =%d\n"</span>, lscpcie2.numBoards);
00564         printk(KERN_INFO <span class="stringliteral">"lscpcie2: init IRQ=%d\n"</span>, irq);
00565     }
00566 
00567 
00568     <span class="comment">//================ DMA Common Buffer (Consistent) Allocation ====================</span>
00569     <span class="comment">// First see if platform supports 32 bit DMA address cycles (like what won't!)</span>
00570     <span class="keywordflow">if</span> (pci_set_dma_mask(PCI_Dev_Cfg, DMA_32BIT_MASK))
00571     {
00572         printk(KERN_WARNING <span class="stringliteral">"lscpcie2: init DMA not supported!\n"</span>);
00573         pBrd-&gt;hasDMA = FALSE;
00574     }
00575     <span class="keywordflow">else</span>
00576     {   
00577         pBrd-&gt;hasDMA = TRUE;
00578         pBrd-&gt;dmaBufSize = DMA_BUFFER_SIZE;
00579         pBrd-&gt;dmaCPUAddr = pci_alloc_consistent(PCI_Dev_Cfg, pBrd-&gt;dmaBufSize, &amp;pBrd-&gt;dmaPCIBusAddr);
00580         <span class="keywordflow">if</span> (pBrd-&gt;dmaCPUAddr == NULL)
00581         {
00582             printk(KERN_WARNING <span class="stringliteral">"lscpcie2: init DMA alloc failed! No DMA buffer.\n"</span>);
00583             pBrd-&gt;hasDMA = FALSE;
00584         }
00585     }
00586 
00587 
00588     <span class="comment">/* Get info on all the PCI BAR registers */</span>
00589     pBrd-&gt;numBars = 0;  <span class="comment">// initialize</span>
00590     <span class="keywordflow">for</span> (i = 0; i &lt; NUM_BARS; i++)
00591     {
00592         p = &amp;(pBrd-&gt;Dev_BARs[i]);
00593         p-&gt;pci_start = pci_resource_start(PCI_Dev_Cfg, i);
00594         p-&gt;pci_end   = pci_resource_end(PCI_Dev_Cfg, i);
00595         p-&gt;len       = pci_resource_len(PCI_Dev_Cfg, i);
00596         p-&gt;pci_flags = pci_resource_flags(PCI_Dev_Cfg, i);
00597 
00598         <span class="keywordflow">if</span> ((p-&gt;pci_start &gt; 0) &amp;&amp; (p-&gt;pci_end &gt; 0))
00599         {
00600             ++(pBrd-&gt;numBars);
00601             p-&gt;bar = i;
00602             p-&gt;pci_addr = (<span class="keywordtype">void</span> *)p-&gt;pci_start;
00603             p-&gt;memType = p-&gt;pci_flags;   <span class="comment">/* IORESOURCE Definitions: (see ioport.h)</span>
00604 <span class="comment">                              * 0x0100 = IO</span>
00605 <span class="comment">                              * 0x0200 = memory</span>
00606 <span class="comment">                              * 0x0400 = IRQ</span>
00607 <span class="comment">                              * 0x0800 = DMA</span>
00608 <span class="comment">                              * 0x1000 = PREFETCHable</span>
00609 <span class="comment">                              * 0x2000 = READONLY</span>
00610 <span class="comment">                              * 0x4000 = cacheable</span>
00611 <span class="comment">                              * 0x8000 = rangelength ???</span>
00612 <span class="comment">                              */</span>
00613             <span class="comment">/*============================================================*</span>
00614 <span class="comment">            *                                                             *</span>
00615 <span class="comment">            * Windows DDK definitions CM_PARTIAL_RESOURCE_DESCRIPTOR.Type *</span>
00616 <span class="comment">            *                                                             *</span>
00617 <span class="comment">            * #define CmResourceTypeNull                0                 *</span>
00618 <span class="comment">            * #define CmResourceTypePort                1                 *</span>
00619 <span class="comment">            * #define CmResourceTypeInterrupt           2                 *</span>
00620 <span class="comment">            * #define CmResourceTypeMemory              3                 *</span>
00621 <span class="comment">            * #define CmResourceTypeDma                 4                 *</span>
00622 <span class="comment">            * #define CmResourceTypeDeviceSpecific      5                 *</span>
00623 <span class="comment">            * #define CmResourceTypeBusNumber           6                 *</span>
00624 <span class="comment">            * #define CmResourceTypeMaximum             7                 *</span>
00625 <span class="comment">            * #define CmResourceTypeNonArbitrated     128                 *</span>
00626 <span class="comment">            * #define CmResourceTypeConfigData        128                 *</span>
00627 <span class="comment">            * #define CmResourceTypeDevicePrivate     129                 *</span>
00628 <span class="comment">            * #define CmResourceTypePcCardConfig      130                 *</span>
00629 <span class="comment">            * #define CmResourceTypeMfCardConfig      131                 *</span>
00630 <span class="comment">            *============================================================*/</span>
00631             <span class="keywordflow">if</span> (DrvrDebug)
00632             {
00633                 printk(KERN_INFO <span class="stringliteral">"lscpcie2: init BAR=%d\n"</span>, i);
00634                 printk(KERN_INFO <span class="stringliteral">"lscpcie2: init start=%lx\n"</span>, p-&gt;pci_start);
00635                 printk(KERN_INFO <span class="stringliteral">"lscpcie2: init end=%lx\n"</span>, p-&gt;pci_end);
00636                 printk(KERN_INFO <span class="stringliteral">"lscpcie2: init len=0x%lx\n"</span>, p-&gt;len);
00637                 printk(KERN_INFO <span class="stringliteral">"lscpcie2: init flags=0x%lx\n"</span>, p-&gt;pci_flags);
00638             }
00639         }
00640     }
00641 
00642 
00643     <span class="comment">// Map the BAR into kernel space so the driver can access registers.</span>
00644     <span class="comment">// The driver can not directly read/write the PCI physical bus address returned</span>
00645     <span class="comment">// by pci_resource_start().  In our current implementation the driver really</span>
00646     <span class="comment">// doesn't access the device registers, so this is not used.  It could be used</span>
00647     <span class="comment">// if the driver took a more active role in managing the devices on the board.</span>
00648 
00649     <span class="comment">// Map the default BAR into the driver's address space for access to LED registers,</span>
00650     <span class="comment">// masking off interrupts, and any other direct hardware controlled by the driver.</span>
00651     <span class="comment">// Note that the BAR may be different per demo.  Basic uses BAR1, SFIF &amp; SGDMA use BAR0</span>
00652     pBAR = &amp;(pBrd-&gt;Dev_BARs[pBrd-&gt;ctrlBAR]);
00653     <span class="keywordflow">if</span> (pBAR-&gt;pci_start)
00654     {
00655         pBrd-&gt;ctrlBARaddr = ioremap(pBAR-&gt;pci_start,   <span class="comment">// PCI bus start address</span>
00656                         pBAR-&gt;len);    <span class="comment">// BAR size</span>
00657         pBAR-&gt;kvm_addr = pBrd-&gt;ctrlBARaddr;  <span class="comment">// for historic reasons</span>
00658 
00659         <span class="keywordflow">if</span> (pBrd-&gt;ctrlBARaddr)
00660         {
00661             writew(0x80f3, pBrd-&gt;ctrlBARaddr + 8);   <span class="comment">// display an 'E' for error (erased if all goes well)</span>
00662         }
00663         <span class="keywordflow">else</span> 
00664         {
00665             printk(KERN_ERR <span class="stringliteral">"lscpcie2: init ERROR with ioremap\n"</span>);
00666             <span class="keywordflow">return</span>(NULL);
00667         }
00668 
00669     }
00670     <span class="keywordflow">else</span>
00671     {
00672         printk(KERN_ERR <span class="stringliteral">"lscpcie2: init ERROR ctrlBAR %d not avail!\n"</span>, pBrd-&gt;ctrlBAR);
00673         <span class="keywordflow">return</span>(NULL);
00674     }
00675 
00676     ++lscpcie2.numBoards;
00677 
00678     <span class="keywordflow">return</span>(pBrd);  <span class="comment">// pointer to board found and initialized</span>
00679 
00680 }
00681 
00682 
00683 <span class="comment">/*========================================================================*/</span>
00684 <span class="comment">/*========================================================================*/</span>
00685 <span class="comment">/*========================================================================*/</span>
00686 <span class="comment">/*</span>
00687 <span class="comment"> *            DRIVER FILE OPERATIONS (OPEN, CLOSE, MMAP, IOCTL)</span>
00688 <span class="comment"> */</span>
00689 <span class="comment">/*========================================================================*/</span>
00690 <span class="comment">/*========================================================================*/</span>
00691 <span class="comment">/*========================================================================*/</span>
00692 
00693 
<a name="l00708"></a><a class="code" href="lscpcie2_8c.html#a32">00708</a> <span class="keywordtype">int</span> <a class="code" href="lscpcie2_8c.html#a32">lscpcie2_open</a>(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)
00709 {
00710     u32 brdNum;
00711     pcie_board_t *pBrd; 
00712 
00713 
00714     <span class="comment">/* Extract the board number from the minor number */</span>
00715     brdNum = iminor(inode);
00716 
00717     <span class="keywordflow">if</span> (DrvrDebug)
00718         printk(KERN_INFO <span class="stringliteral">"lscpcie2: open(): board#=%d\n"</span>, brdNum);
00719 
00720     <span class="comment">/* Validate (paranoid) */</span>
00721     <span class="keywordflow">if</span> (brdNum &gt;= lscpcie2.numBoards)
00722         <span class="keywordflow">return</span>(-ENODEV);
00723 
00724     <span class="comment">// This is what the user wants to access</span>
00725     pBrd = &amp;lscpcie2.Board[brdNum];
00726 
00727 
00728     <span class="keywordflow">if</span> (pBrd-&gt;ID == 0)
00729         <span class="keywordflow">return</span>(-ENODEV);  <span class="comment">// Board[] entry not configured correctly</span>
00730 
00731 <span class="comment">// TODO</span>
00732     <span class="comment">// Maybe increment a reference count, don't let more than one user open a board???</span>
00733 
00734     <span class="comment">/* This allows ioctl quick access to the boards global resources */</span>
00735     filp-&gt;private_data = pBrd;
00736 
00737     <span class="comment">// Need to possibly connect up interrupts</span>
00738     <span class="comment">// pci_enable_device(pBrd-&gt;pPciDev);  // we may want to do this to "power-up" a closed board?</span>
00739 
00740     <span class="comment">// Write an 'O' to the LEDs to signal its openned</span>
00741     <span class="keywordflow">if</span> (pBrd-&gt;ctrlBARaddr)
00742         writew(0x00ff, pBrd-&gt;ctrlBARaddr + 8);   <span class="comment">// display an 'O' </span>
00743 
00744     <span class="keywordflow">return</span>(0);
00745 }
00746 
00747 
<a name="l00752"></a><a class="code" href="lscpcie2_8c.html#a33">00752</a> <span class="keywordtype">int</span> <a class="code" href="lscpcie2_8c.html#a33">lscpcie2_release</a>(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)
00753 {
00754     <span class="keyword">struct </span>PCIE_Board *pBrd = filp-&gt;private_data;
00755 
00756     u32 mnr = iminor(inode);
00757 
00758     <span class="keywordflow">if</span> (DrvrDebug)
00759         printk(KERN_INFO <span class="stringliteral">"lscpcie2: close() - closing board=%d\n"</span>, mnr);
00760 
00761     <span class="comment">// Write a 'C' to the LEDs to signal its closed</span>
00762     <span class="keywordflow">if</span> (pBrd-&gt;ctrlBARaddr)
00763         writew(0x00f3, pBrd-&gt;ctrlBARaddr + 8);   <span class="comment">// display a 'C' </span>
00764 
00765 <span class="comment">// TODO</span>
00766     <span class="comment">// Maybe decrement a reference count</span>
00767 
00768     <span class="comment">// pci_disable_device(pBrd-&gt;pPciDev);  // we may want to do this to "power-down" the board?</span>
00769 
00770     <span class="keywordflow">return</span>(0);
00771 }
00772 
00773 
00774 
<a name="l00781"></a><a class="code" href="lscpcie2_8c.html#a34">00781</a> <span class="keywordtype">int</span> <a class="code" href="lscpcie2_8c.html#a34">lscpcie2_ioctl</a>(<span class="keyword">struct</span> inode *inode, 
00782           <span class="keyword">struct</span> file *filp,
00783           <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cmd,
00784           <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> arg)
00785 {
00786     <span class="keywordtype">int</span> i;
00787     <span class="keywordtype">int</span> status = OK;
00788     <span class="keywordtype">int</span> mnr = iminor(inode);
00789     pcie_board_t *pBrd = NULL; 
00790     <a class="code" href="struct_p_c_i_resource_info__t.html">PCIResourceInfo_t</a> *pInfo;
00791     <a class="code" href="struct_extra_resource_info__t.html">ExtraResourceInfo_t</a> *pExtra;
00792 
00793     <span class="keywordflow">if</span> (DrvrDebug)
00794         printk(KERN_INFO <span class="stringliteral">"lscpcie2: ioctl(minor=%d cmd=%d arg=%lx size=%d)\n"</span>, 
00795                         mnr, _IOC_NR(cmd), arg, _IOC_SIZE(cmd));
00796 
00797     <span class="keywordflow">if</span> (_IOC_TYPE(cmd) != LSCPCIE_MAGIC)
00798         <span class="keywordflow">return</span>(-EINVAL);
00799     <span class="keywordflow">if</span> (_IOC_NR(cmd) &gt; IOCTL_LSCPCIE_MAX_NR)
00800         <span class="keywordflow">return</span>(-EINVAL);
00801 
00802     pBrd = filp-&gt;private_data;
00803     <span class="keywordflow">switch</span> (cmd)
00804     {
00805 
00806         <span class="keywordflow">case</span> <a class="code" href="_ioctl_8h.html#a4">IOCTL_LSCPCIE_GET_VERSION_INFO</a>:
00807             <span class="comment">// first make sure the pointer passed in arg is still valid user page</span>
00808             <span class="keywordflow">if</span> (!access_ok(VERIFY_WRITE, (<span class="keywordtype">void</span> *)arg, _IOC_SIZE(cmd)))
00809             {
00810                 status = -EFAULT;
00811                 <span class="keywordflow">break</span>;  <span class="comment">// abort</span>
00812             }
00813 
00814             pInfo = kmalloc(<span class="keyword">sizeof</span>(MAX_DRIVER_VERSION_LEN ), GFP_KERNEL);
00815             <span class="keywordflow">if</span> (pInfo == NULL)
00816             {
00817                 status = -EFAULT;
00818                 <span class="keywordflow">break</span>;  <span class="comment">// abort</span>
00819             }
00820 
00821 
00822             strncpy((<span class="keywordtype">void</span> *)arg, Version, MAX_DRIVER_VERSION_LEN - 1);
00823             kfree(pInfo);  <span class="comment">// release kernel temp buffer</span>
00824 
00825             <span class="keywordflow">break</span>;
00826 
00827         <span class="keywordflow">case</span> <a class="code" href="_ioctl_8h.html#a6">IOCTL_LSCPCIE_SET_BAR</a>:
00828             <span class="comment">// The argument passed in is the direct BAR number (0-5) to use for mmap</span>
00829             pBrd-&gt;mmapBAR = arg;
00830             <span class="keywordflow">break</span>;
00831 
00832 
00833         <span class="keywordflow">case</span> <a class="code" href="_ioctl_8h.html#a5">IOCTL_LSCPCIE_GET_RESOURCES</a>:
00834             <span class="comment">// first make sure the pointer passed in arg is still valid user page</span>
00835             <span class="keywordflow">if</span> (!access_ok(VERIFY_WRITE, (<span class="keywordtype">void</span> *)arg, _IOC_SIZE(cmd)))
00836             {
00837                 status = -EFAULT;
00838                 <span class="keywordflow">break</span>;  <span class="comment">// abort</span>
00839             }
00840 
00841             pInfo = kmalloc(<span class="keyword">sizeof</span>(<a class="code" href="struct_p_c_i_resource_info__t.html">PCIResourceInfo_t</a>), GFP_KERNEL);
00842             <span class="keywordflow">if</span> (pInfo == NULL)
00843             {
00844                 status = -EFAULT;
00845                 <span class="keywordflow">break</span>;  <span class="comment">// abort</span>
00846             }
00847 
00848             <span class="keywordflow">if</span> (pBrd-&gt;IRQ &gt; 0)
00849                 pInfo-&gt;<a class="code" href="struct_p_c_i_resource_info__t.html#o3">hasInterrupt</a> = TRUE;
00850             <span class="keywordflow">else</span>
00851                 pInfo-&gt;<a class="code" href="struct_p_c_i_resource_info__t.html#o3">hasInterrupt</a> = FALSE;
00852             pInfo-&gt;<a class="code" href="struct_p_c_i_resource_info__t.html#o4">intrVector</a> = pBrd-&gt;IRQ;
00853             pInfo-&gt;<a class="code" href="struct_p_c_i_resource_info__t.html#o0">numBARs</a> = pBrd-&gt;numBars;
00854             <span class="keywordflow">for</span> (i = 0; i &lt; MAX_PCI_BARS; i++)
00855             {
00856                 pInfo-&gt;<a class="code" href="struct_p_c_i_resource_info__t.html#o1">BAR</a>[i].<a class="code" href="struct_p_c_i___b_a_r__t.html#o0">nBAR</a> = pBrd-&gt;Dev_BARs[i].bar;
00857                 pInfo-&gt;<a class="code" href="struct_p_c_i_resource_info__t.html#o1">BAR</a>[i].<a class="code" href="struct_p_c_i___b_a_r__t.html#o1">physStartAddr</a> = (ULONG)pBrd-&gt;Dev_BARs[i].pci_addr;
00858                 pInfo-&gt;<a class="code" href="struct_p_c_i_resource_info__t.html#o1">BAR</a>[i].<a class="code" href="struct_p_c_i___b_a_r__t.html#o2">size</a> = pBrd-&gt;Dev_BARs[i].len;
00859                 pInfo-&gt;<a class="code" href="struct_p_c_i_resource_info__t.html#o1">BAR</a>[i].<a class="code" href="struct_p_c_i___b_a_r__t.html#o3">memMapped</a> = (pBrd-&gt;Dev_BARs[i].kvm_addr) ? 1 : 0;
00860                 pInfo-&gt;<a class="code" href="struct_p_c_i_resource_info__t.html#o1">BAR</a>[i].<a class="code" href="struct_p_c_i___b_a_r__t.html#o4">flags</a> = (USHORT)(pBrd-&gt;Dev_BARs[i].pci_flags);
00861                 pInfo-&gt;<a class="code" href="struct_p_c_i_resource_info__t.html#o1">BAR</a>[i].<a class="code" href="struct_p_c_i___b_a_r__t.html#o5">type</a> = (UCHAR)((pBrd-&gt;Dev_BARs[i].memType)&gt;&gt;8);  <span class="comment">// get the bits that show IO or mem</span>
00862             }
00863             <span class="keywordflow">for</span> (i = 0; i &lt; 0x100; ++i)
00864                 pci_read_config_byte(pBrd-&gt;pPciDev, i, &amp;(pInfo-&gt;<a class="code" href="struct_p_c_i_resource_info__t.html#o2">PCICfgReg</a>[i]));
00865 
00866             <span class="keywordflow">if</span> (copy_to_user((<span class="keywordtype">void</span> *)arg, (<span class="keywordtype">void</span> *)pInfo, <span class="keyword">sizeof</span>(PCIResourceInfo_t)) != 0)
00867                 status = -EFAULT; <span class="comment">// Not all bytes were copied so this is an error</span>
00868             kfree(pInfo);  <span class="comment">// release kernel temp buffer</span>
00869 
00870             <span class="keywordflow">break</span>;
00871 
00872 
00873         <span class="keywordflow">case</span> <a class="code" href="_ioctl_8h.html#a7">IOCTL_LSCPCIE2_GET_EXTRA_INFO</a>:
00874             <span class="comment">// first make sure the pointer passed in arg is still valid user page</span>
00875             <span class="keywordflow">if</span> (!access_ok(VERIFY_WRITE, (<span class="keywordtype">void</span> *)arg, _IOC_SIZE(cmd)))
00876             {
00877                 status = -EFAULT;
00878                 <span class="keywordflow">break</span>;  <span class="comment">// abort</span>
00879             }
00880 
00881             pExtra = kmalloc(<span class="keyword">sizeof</span>(<a class="code" href="struct_extra_resource_info__t.html">ExtraResourceInfo_t</a>), GFP_KERNEL);
00882             <span class="keywordflow">if</span> (pExtra == NULL)
00883             {
00884                 status = -EFAULT;
00885                 <span class="keywordflow">break</span>;  <span class="comment">// abort</span>
00886             }
00887 
00888             pExtra-&gt;<a class="code" href="struct_extra_resource_info__t.html#o0">devID</a> = pBrd-&gt;minorNum;     <span class="comment">// board number of specific device</span>
00889 
00890             pExtra-&gt;<a class="code" href="struct_extra_resource_info__t.html#o1">busNum</a> = pBrd-&gt;pPciDev-&gt;bus-&gt;number;  <span class="comment">// PCI bus number board located on</span>
00891             pExtra-&gt;<a class="code" href="struct_extra_resource_info__t.html#o2">deviceNum</a> = PCI_SLOT(pBrd-&gt;pPciDev-&gt;devfn);     <span class="comment">// PCI device number assigned to board</span>
00892             pExtra-&gt;<a class="code" href="struct_extra_resource_info__t.html#o3">functionNum</a> = PCI_FUNC(pBrd-&gt;pPciDev-&gt;devfn);   <span class="comment">// our function number</span>
00893             pExtra-&gt;<a class="code" href="struct_extra_resource_info__t.html#o4">UINumber</a> = pBrd-&gt;minorNum;      <span class="comment">// slot number (not implemented) </span>
00894 
00895             <span class="comment">// Device DMA Common buffer memory info</span>
00896             pExtra-&gt;<a class="code" href="struct_extra_resource_info__t.html#o5">hasDmaBuf</a> = pBrd-&gt;hasDMA;        <span class="comment">// true if DMA buffer has been allocated by driver </span>
00897             pExtra-&gt;<a class="code" href="struct_extra_resource_info__t.html#o6">DmaBufSize</a> = pBrd-&gt;dmaBufSize;   <span class="comment">// size in bytes of said buffer </span>
00898             pExtra-&gt;<a class="code" href="struct_extra_resource_info__t.html#o7">DmaAddr64</a> = 0;      <span class="comment">// driver only asks for 32 bit, SGDMA only supports 32 bit </span>
00899             pExtra-&gt;<a class="code" href="struct_extra_resource_info__t.html#o8">DmaPhyAddrHi</a> = 0;    <span class="comment">// not used, only 32 bit</span>
00900             pExtra-&gt;<a class="code" href="struct_extra_resource_info__t.html#o9">DmaPhyAddrLo</a> = pBrd-&gt;dmaPCIBusAddr;    <span class="comment">// DMA bus address to be programmed into device </span>
00901 
00902             strncpy(pExtra-&gt;<a class="code" href="struct_extra_resource_info__t.html#o10">DriverName</a>, Version, MAX_DRIVER_NAME_LEN-1);   <span class="comment">// version and name</span>
00903 
00904             <span class="keywordflow">if</span> (copy_to_user((<span class="keywordtype">void</span> *)arg, (<span class="keywordtype">void</span> *)pExtra, <span class="keyword">sizeof</span>(ExtraResourceInfo_t)) != 0)
00905                 status = -EFAULT; <span class="comment">// Not all bytes were copied so this is an error</span>
00906             kfree(pExtra);  <span class="comment">// release kernel temp buffer</span>
00907 
00908             <span class="keywordflow">break</span>;
00909 
00910         <span class="keywordflow">default</span>:
00911             status = -EINVAL;   <span class="comment">// invalid IOCTL argument</span>
00912     }
00913 
00914     <span class="keywordflow">return</span>(status);
00915 }
00916 
00917 
<a name="l00924"></a><a class="code" href="lscpcie2_8c.html#a35">00924</a> <span class="keywordtype">int</span> <a class="code" href="lscpcie2_8c.html#a35">lscpcie2_mmap</a>(<span class="keyword">struct</span> file *filp,
00925                  <span class="keyword">struct</span> vm_area_struct *vma)
00926 {
00927     <span class="keywordtype">int</span> num;
00928     <span class="keywordtype">int</span> sysErr;
00929     pcie_board_t *pBrd = filp-&gt;private_data;
00930     <a class="code" href="lscpcie2_8c.html#a13">pci_dev_bar_t</a> *pBAR;
00931     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> phys_start;    <span class="comment">/* starting address to map */</span>
00932     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> mapSize;          <span class="comment">/* requested size to map */</span>
00933     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> offset;        <span class="comment">/* how far into window to start map */</span>
00934 
00935     <span class="comment">// Map the BAR of the board, specified by mmapBAR (normally the default one that the</span>
00936     <span class="comment">// demo supports - normally only one valid BAR in our demos)</span>
00937     pBAR = &amp;(pBrd-&gt;Dev_BARs[pBrd-&gt;mmapBAR]);
00938 
00939     mapSize = vma-&gt;vm_end - vma-&gt;vm_start;
00940     offset = vma-&gt;vm_pgoff &lt;&lt; PAGE_SHIFT;
00941 
00942     num = pBAR-&gt;bar;  <span class="comment">// this is a check to make sure we really initialized the BAR and structures</span>
00943 
00944     <span class="keywordflow">if</span> (DrvrDebug)
00945         printk(KERN_INFO <span class="stringliteral">"lscpcie2: mmap Board=%d  BAR=%d\n"</span>, pBrd-&gt;minorNum, num);
00946 
00947     <span class="keywordflow">if</span> (num == -1)
00948         <span class="keywordflow">return</span>(-ENOMEM);   <span class="comment">/* BAR not activated, no memory */</span>
00949 
00950     <span class="keywordflow">if</span> (mapSize &gt; pBAR-&gt;len)
00951         <span class="keywordflow">return</span>(-EINVAL);  <span class="comment">/* asked for too much memory. */</span>
00952 
00953     <span class="comment">/* Calculate the starting address, based on the offset passed by user */</span>
00954     phys_start = (<span class="keywordtype">unsigned</span> long)(pBAR-&gt;pci_addr) + offset;
00955 
00956     <span class="keywordflow">if</span> (DrvrDebug)
00957     {
00958         printk(KERN_INFO <span class="stringliteral">"lscpcie2: remap_page_range(0x%lx, 0x%x, %d, ...)\n"</span>,
00959            vma-&gt;vm_start, (uint32_t)phys_start, (uint32_t)mapSize);
00960     }
00961 
00962     <span class="comment">/* Make sure the memory is treated as uncached, non-swap device memory */</span>
00963     vma-&gt;vm_flags = vma-&gt;vm_flags | VM_LOCKED | VM_IO | VM_RESERVED;
00964 
00965 <span class="preprocessor">#if (LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,6,10))</span>
00966 <span class="preprocessor"></span>    <span class="comment">/* Do the page mapping the new 2.6.10+ way */</span>
00967     sysErr = remap_pfn_range(vma,
00968                   (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)vma-&gt;vm_start,
00969                   (phys_start&gt;&gt;PAGE_SHIFT),
00970                   mapSize,
00971                   vma-&gt;vm_page_prot);
00972 
00973 <span class="preprocessor">#elif (LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,6,8))</span>
00974 <span class="preprocessor"></span>    <span class="comment">/* Do the page mapping the intermediate way */</span>
00975     sysErr = remap_page_range(vma,
00976                   (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)vma-&gt;vm_start,
00977                   phys_start,
00978                   mapSize,
00979                   vma-&gt;vm_page_prot);
00980 <span class="preprocessor">#else</span>
00981 <span class="preprocessor"></span><span class="preprocessor">    #error Unsupported kernel version!!!!</span>
00982 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00983 <span class="preprocessor"></span>
00984 
00985     <span class="keywordflow">if</span> (sysErr &lt; 0)
00986     {
00987         printk(KERN_ERR <span class="stringliteral">"lscpcie2: remap_page_range() failed!\n"</span>);
00988         <span class="keywordflow">return</span>(-EAGAIN);
00989     }
00990 
00991     <span class="keywordflow">return</span>(0);
00992 }
00993 
00994 
00995 
00996 
<a name="l01002"></a><a class="code" href="lscpcie2_8c.html#a36">01002</a> ssize_t <a class="code" href="lscpcie2_8c.html#a36">lscpcie2_read</a>(<span class="keyword">struct</span> file *filp,
01003             <span class="keywordtype">char</span> __user *userBuf,
01004             size_t len,
01005             loff_t *offp)
01006 {
01007     pcie_board_t *pBrd = filp-&gt;private_data;
01008 
01009     <span class="keywordflow">if</span> (DrvrDebug)
01010         printk(KERN_INFO <span class="stringliteral">"lscpcie2: read len=%d\n"</span>, (u32)len);
01011 
01012     <span class="keywordflow">if</span> (!pBrd-&gt;hasDMA)
01013         <span class="keywordflow">return</span>(-EINVAL);   <span class="comment">// invalid, no DMA buffer allocated</span>
01014 
01015     <span class="keywordflow">if</span> (len &gt; pBrd-&gt;dmaBufSize)
01016         len = pBrd-&gt;dmaBufSize;  <span class="comment">// trim it down</span>
01017 
01018     <span class="keywordflow">if</span> (copy_to_user(userBuf, pBrd-&gt;dmaCPUAddr, len) != 0)
01019         <span class="keywordflow">return</span>(-EFAULT);
01020     
01021     <span class="keywordflow">return</span>(len);
01022 }
01023 
01024 
<a name="l01030"></a><a class="code" href="lscpcie2_8c.html#a37">01030</a> ssize_t <a class="code" href="lscpcie2_8c.html#a37">lscpcie2_write</a>(<span class="keyword">struct</span> file *filp,
01031             <span class="keyword">const</span> <span class="keywordtype">char</span> __user *userBuf,
01032             size_t len,
01033             loff_t *offp)
01034 {
01035     pcie_board_t *pBrd = filp-&gt;private_data;
01036 
01037     <span class="keywordflow">if</span> (DrvrDebug)
01038         printk(KERN_INFO <span class="stringliteral">"lscpcie2: write len=%d\n"</span>, (u32)len);
01039 
01040     <span class="keywordflow">if</span> (!pBrd-&gt;hasDMA)
01041         <span class="keywordflow">return</span>(-EINVAL);   <span class="comment">// invalid, no DMA buffer allocated</span>
01042 
01043     <span class="keywordflow">if</span> (len &gt; pBrd-&gt;dmaBufSize)
01044         len = pBrd-&gt;dmaBufSize;  <span class="comment">// trim it down</span>
01045 
01046     <span class="keywordflow">if</span> (copy_from_user(pBrd-&gt;dmaCPUAddr, userBuf, len) != 0)
01047         <span class="keywordflow">return</span>(-EFAULT);
01048     
01049     <span class="keywordflow">return</span>(len);
01050 }
01051 
01052 
01053 
01054 
01055 
01056 <span class="comment">/*==================================================================*/</span>
01057 <span class="comment">/*==================================================================*/</span>
01058 <span class="comment">/*==================================================================*/</span>
01059 <span class="comment">/*</span>
01060 <span class="comment"> *              M O D U L E   F U N C T I O N S</span>
01061 <span class="comment"> */</span>
01062 <span class="comment">/*==================================================================*/</span>
01063 <span class="comment">/*==================================================================*/</span>
01064 <span class="comment">/*==================================================================*/</span>
01065 
01071 <span class="keyword">static</span> <span class="keyword">struct </span>file_operations drvr_fops =
01072 {
01073     owner:   THIS_MODULE,
01074     open:    lscpcie2_open,
01075     release: lscpcie2_release,
01076     ioctl:   lscpcie2_ioctl,
01077     mmap:    lscpcie2_mmap,
01078     read:    lscpcie2_read,
01079     write:   lscpcie2_write,
01080 };
01081 
01082 
01083 <span class="comment">/*------------------------------------------------------------------*/</span>
01084 
01085 
01086 
01095 <span class="keyword">static</span> <span class="keywordtype">int</span> __init lscpcie2_probe(<span class="keyword">struct</span> pci_dev *pdev,
01096                  <span class="keyword">const</span> <span class="keyword">struct</span> pci_device_id *ent)
01097 {
01098     <span class="keyword">static</span> <span class="keywordtype">char</span> devNameStr[12] = <span class="stringliteral">"lscpcie2__"</span>;
01099     pcie_board_t *brd;
01100     <span class="keywordtype">int</span> err;
01101 
01102     devNameStr[9] = <span class="charliteral">'0'</span> + lscpcie2.numBoards;
01103 
01104     <span class="keywordflow">if</span> (DrvrDebug)
01105         printk(KERN_INFO <span class="stringliteral">"lscpcie2: pci probe for: %s  pdev=%p  ent=%p\n"</span>, 
01106                     devNameStr, pdev, ent);
01107 
01108     <span class="comment">/*</span>
01109 <span class="comment">     * Enable the bus-master bit values.</span>
01110 <span class="comment">     * Some PCI BIOSes fail to set the master-enable bit.</span>
01111 <span class="comment">     * Some demos support being an initiator, so need bus master ability.</span>
01112 <span class="comment">     */</span>
01113     err = pci_request_regions(pdev, devNameStr);
01114     <span class="keywordflow">if</span> (err)
01115         <span class="keywordflow">return</span> err;
01116 
01117     pci_set_master(pdev);
01118 
01119     err = pci_enable_device(pdev);
01120     <span class="keywordflow">if</span> (err)
01121         <span class="keywordflow">return</span> err;
01122 
01123     <span class="comment">/*</span>
01124 <span class="comment">     * Call to perform board specific initialization and figure out</span>
01125 <span class="comment">     * which BARs are active, interrupt vectors, register ISR, what board</span>
01126 <span class="comment">     * it is (SC or ECP2M), what demo (Basic or SFIF) and what instance</span>
01127 <span class="comment">     * number (is it the 2nd time we've seen a SC Basic?)</span>
01128 <span class="comment">     * Returns pointer to the Board structure after all info filled in.</span>
01129 <span class="comment">     */</span>
01130     brd = initBoard(pdev, (<span class="keywordtype">void</span> *)ent);
01131 
01132     <span class="keywordflow">if</span> (brd == NULL)
01133     {
01134         printk(KERN_ERR <span class="stringliteral">"lscpcie2: Error initializing Eval Board\n"</span>);
01135         <span class="comment">// Clean up any resources we acquired along the way</span>
01136         pci_release_regions(pdev);
01137         
01138         <span class="keywordflow">return</span>(-1);
01139     }
01140         
01141 
01142 
01143     <span class="comment">// Initialize the CharDev entry for this new found eval board device</span>
01144     brd-&gt;charDev.owner = THIS_MODULE;
01145     kobject_set_name(&amp;(brd-&gt;charDev.kobj), <span class="stringliteral">"lscpcie2"</span>);
01146 
01147     cdev_init(&amp;(brd-&gt;charDev), &amp;drvr_fops);
01148 
01149 <span class="comment">//?????</span>
01150 <span class="comment">// Does cdev_add initialize reference count in the kobj?</span>
01151 <span class="comment">//?????</span>
01152 
01153     <span class="comment">/* Create the minor numbers here and register the device as a character device.</span>
01154 <span class="comment">     * A number of minor devices can be associated with this particular board.</span>
01155 <span class="comment">     * The hope/idea is that we give the starting minor number and the number of them</span>
01156 <span class="comment">     * and all those devices will be associated to this one particular device.</span>
01157 <span class="comment">     */</span>
01158     <span class="keywordflow">if</span> (cdev_add(&amp;(brd-&gt;charDev), MKDEV(brd-&gt;majorNum,brd-&gt;minorNum), MINORS_PER_BOARD))
01159     {
01160         printk(KERN_ERR <span class="stringliteral">"lscpcie2: Error adding char device\n"</span>);
01161         kobject_put(&amp;(brd-&gt;charDev.kobj));
01162         <span class="keywordflow">return</span>(-1); 
01163     }
01164 
01165 
01166     <span class="comment">/* This creates a new entry in the /sys/class/lscpcie2/ tree that represents this</span>
01167 <span class="comment">     * new device in user space.  An entry in /dev will be created based on the name</span>
01168 <span class="comment">     * given in the last argument.  udev is responsible for mapping sysfs Classes to</span>
01169 <span class="comment">     * device nodes, and is done outside this kernel driver.</span>
01170 <span class="comment">     *</span>
01171 <span class="comment">     * The name is constructed from the board type, demo type and board instance.</span>
01172 <span class="comment">     * Examples are "sc_basic_0", "sc_basic_1", "ecp2m_sfif_0"</span>
01173 <span class="comment">     */</span>
01174 <span class="preprocessor">#if (LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,6,12))</span>
01175 <span class="preprocessor"></span>    class_device_create(lscpcie2.sysClass,
01176                 NULL,
01177                 MKDEV(brd-&gt;majorNum,brd-&gt;minorNum),
01178                  &amp;(pdev-&gt;dev),   <span class="comment">// this is of type struct device, the PCI device?</span>
01179                 <span class="stringliteral">"%s_%s_%d"</span>, BoardName[brd-&gt;boardType], DemoName[brd-&gt;demoType], brd-&gt;instanceNum);
01180 <span class="preprocessor">#else</span>
01181 <span class="preprocessor"></span>    class_simple_device_add(lscpcie2.sysClass,
01182                 MKDEV(brd-&gt;majorNum,brd-&gt;minorNum),
01183                 NULL,   <span class="comment">// this is of type struct device, but who?????</span>
01184                 <span class="stringliteral">"%s_%s_%d"</span>, BoardName[brd-&gt;boardType], DemoName[brd-&gt;demoType], brd-&gt;instanceNum);
01185 <span class="preprocessor">#endif</span>
01186 <span class="preprocessor"></span>
01187 
01188 
01189     <span class="comment">/* Store a pointer to the Board structure with this PCI device instance for easy access</span>
01190 <span class="comment">     * to board info later on.</span>
01191 <span class="comment">     */</span>
01192     pci_set_drvdata(pdev, brd);
01193 
01194     <span class="comment">// Write an 'I' to the LEDs at end of initialization</span>
01195     <span class="keywordflow">if</span> (brd-&gt;ctrlBARaddr)
01196         writew(0x2233, brd-&gt;ctrlBARaddr + 8);   <span class="comment">// display an 'I' </span>
01197 
01198     <span class="keywordflow">return</span> 0;
01199 }
01200 
01201 
01202 
01211 <span class="keyword">static</span> <span class="keywordtype">void</span> __devexit lscpcie2_remove(<span class="keyword">struct</span> pci_dev *pdev)
01212 {
01213     pcie_board_t *brd = pci_get_drvdata(pdev);
01214 
01215     <span class="keywordflow">if</span> (DrvrDebug)
01216         printk(KERN_INFO <span class="stringliteral">"lscpcie2: pci remove for device: pdev=%p board=%p\n"</span>, pdev, brd);
01217 
01218 
01219     <span class="comment">// Write an 'R' to the LEDs when device is removed</span>
01220     <span class="keywordflow">if</span> (brd-&gt;ctrlBARaddr)
01221         writew(0x98c7, brd-&gt;ctrlBARaddr + 8);   <span class="comment">// display an 'R' </span>
01222 
01223     <span class="comment">// Release DMA Buffer</span>
01224     <span class="keywordflow">if</span> (brd-&gt;hasDMA)
01225     {
01226         pci_free_consistent(pdev, brd-&gt;dmaBufSize, brd-&gt;dmaCPUAddr, brd-&gt;dmaPCIBusAddr);
01227     }
01228 
01229 
01230     <span class="comment">// Shut off interrupt sources - not implemented in Basic or SFIF</span>
01231 
01232     <span class="comment">// Free our internal access to the control BAR address space</span>
01233     <span class="keywordflow">if</span> (brd-&gt;ctrlBARaddr)
01234         iounmap(brd-&gt;ctrlBARaddr);
01235 
01236     <span class="comment">// No more access after this call</span>
01237     pci_release_regions(pdev);
01238 
01239     <span class="comment">// Unbind the minor numbers of this device</span>
01240     <span class="comment">// using the MAJOR_NUM + board_num + Minor Range of this board</span>
01241     cdev_del(&amp;(brd-&gt;charDev));
01242 
01243     unregister_chrdev_region(MKDEV(brd-&gt;majorNum, brd-&gt;minorNum), MINORS_PER_BOARD);
01244 
01245 
01246     <span class="comment">// Remove the device entry in the /sys/class/lscpcie2/ tree</span>
01247 
01248 <span class="preprocessor">#if (LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,6,12))</span>
01249 <span class="preprocessor"></span>    class_device_destroy(lscpcie2.sysClass, MKDEV(brd-&gt;majorNum, brd-&gt;minorNum));
01250 <span class="preprocessor">#else</span>
01251 <span class="preprocessor"></span>    class_simple_device_remove(MKDEV(brd-&gt;majorNum, brd-&gt;minorNum));
01252 <span class="preprocessor">#endif</span>
01253 <span class="preprocessor"></span>
01254 }
01255 
01256 
01257 <span class="comment">/*-------------------------------------------------------------------------*/</span>
01258 <span class="comment">/*             DRIVER INSTALL/REMOVE POINTS                                */</span>
01259 <span class="comment">/*-------------------------------------------------------------------------*/</span>
01260 
01261 <span class="comment">/*</span>
01262 <span class="comment"> *  Variables that can be overriden from module command line</span>
01263 <span class="comment"> */</span>
01264 <span class="keyword">static</span> <span class="keywordtype">int</span>  debug = 0;
01265 module_param(debug, <span class="keywordtype">int</span>, 0);
01266 MODULE_PARM_DESC(debug, <span class="stringliteral">"lscpcie2 enable debugging (0-1)"</span>);
01267 
01277 <span class="keyword">static</span> <span class="keyword">struct </span>pci_driver lscpcie2_driver = {
01278     .name = <span class="stringliteral">"lscpcie2"</span>,
01279     .id_table = lscpcie2_pci_id_tbl,
01280     .probe = lscpcie2_probe,
01281     .remove = __devexit_p(lscpcie2_remove),
01282 
01283 <span class="comment">/*</span>
01284 <span class="comment">    .save_state - Save a device's state before its suspended</span>
01285 <span class="comment">    .suspend - put device into low power state</span>
01286 <span class="comment">    .resume - wake device from low power state</span>
01287 <span class="comment">    .enable_wake - enable device to generate wake events from low power state</span>
01288 <span class="comment">*/</span>
01289 };
01290 
01291 
01292 <span class="comment">/*-------------------------------------------------------------------------*/</span>
01293 
01298 <span class="keyword">static</span> <span class="keywordtype">int</span> __init lscpcie2_init(<span class="keywordtype">void</span>)
01299 {
01300     <span class="keywordtype">int</span> result;
01301     <span class="keywordtype">int</span> i, n;
01302     <span class="keywordtype">int</span> err;
01303     <span class="comment">//pci_dev_bar_t *p;</span>
01304     <span class="comment">//pcie_board_t *pB;</span>
01305 
01306     printk(KERN_INFO <span class="stringliteral">"lscpcie2: _init()   debug=%d\n"</span>, debug);
01307     DrvrDebug = debug;
01308 
01309     <span class="comment">/* Initialize the driver database to nothing found, no BARs, no devices */</span>
01310     memset(&amp;lscpcie2, 0, <span class="keyword">sizeof</span>(lscpcie2));
01311     <span class="keywordflow">for</span> (n = 0; n &lt; NUM_BOARDS; n++)
01312         <span class="keywordflow">for</span> (i = 0; i &lt; NUM_BARS; i++)
01313             lscpcie2.Board[n].Dev_BARs[i].bar = -1;
01314 
01315     <span class="comment">/*</span>
01316 <span class="comment">     * Register device driver as a character device and get a dynamic Major number</span>
01317 <span class="comment">         * and reserve enough minor numbers for the maximum amount of boards * BARs</span>
01318 <span class="comment">         * we'd expect to find in a system.</span>
01319 <span class="comment">     */</span>
01320     result = alloc_chrdev_region(&amp;lscpcie2.drvrDevNum,   <span class="comment">// return allocated Device Num here</span>
01321                       0,        <span class="comment">// first minor number</span>
01322                       MAX_MINORS,   
01323                                       <span class="stringliteral">"lscpcie2"</span>);
01324 
01325     <span class="keywordflow">if</span> (result &lt; 0)
01326     {
01327         printk(KERN_WARNING <span class="stringliteral">"lscpcie2: can't get major/minor numbers!\n"</span>);
01328         <span class="keywordflow">return</span>(result);
01329     }
01330 
01331 
01332     <span class="keywordflow">if</span> (DrvrDebug)
01333         printk(KERN_INFO <span class="stringliteral">"lscpcie2: Major=%d  num boards=%d\n"</span>, MAJOR(lscpcie2.drvrDevNum), lscpcie2.numBoards );
01334 
01335     
01336     <span class="keywordflow">if</span> (DrvrDebug)
01337         printk(KERN_INFO <span class="stringliteral">"lscpcie2: cdev_init()\n"</span>);
01338 
01339 
01340 
01341     <span class="comment">/* Create the new sysfs Class entry that will hold the tree of detected Lattice PCIe Eval</span>
01342 <span class="comment">     * board devices.</span>
01343 <span class="comment">     */</span>
01344 <span class="preprocessor">#if (LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,6,12))</span>
01345 <span class="preprocessor"></span>    lscpcie2.sysClass = class_create(THIS_MODULE, <span class="stringliteral">"lscpcie2"</span>);
01346 <span class="preprocessor">#else</span>
01347 <span class="preprocessor"></span>    lscpcie2.sysClass = class_simple_create(THIS_MODULE, <span class="stringliteral">"lscpcie2"</span>);
01348 <span class="preprocessor">#endif</span>
01349 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (IS_ERR(lscpcie2.sysClass))
01350     {
01351         printk(KERN_ERR <span class="stringliteral">"lscpcie2: Error creating simple class interface\n"</span>);
01352         <span class="keywordflow">return</span>(-1); 
01353     }
01354 
01355 
01356 
01357     <span class="keywordflow">if</span> (DrvrDebug)
01358         printk(KERN_INFO <span class="stringliteral">"lscpcie2: registering driver with PCI\n"</span>);
01359 
01360 
01361     <span class="comment">/* Register our PCI components and functions with the Kernel PCI core.</span>
01362 <span class="comment">     * Returns negative number for error, and 0 if success.  It does not always</span>
01363 <span class="comment">     * return the number of devices found and bound to the driver because of hot</span>
01364 <span class="comment">     * plug - they could be bound later.</span>
01365 <span class="comment">     */</span>
01366     err = pci_register_driver(&amp;lscpcie2_driver);
01367 
01368     <span class="keywordflow">if</span> (DrvrDebug)
01369         printk(KERN_INFO <span class="stringliteral">"lscpcie2: pci_register_driver()=%d\n"</span>, err);
01370 
01371     <span class="keywordflow">if</span> (err &lt; 0)
01372         <span class="keywordflow">return</span>(err);
01373 
01374 
01375 <span class="preprocessor">#ifdef USE_PROC </span><span class="comment">/* only when available */</span>
01376     create_proc_read_entry(<span class="stringliteral">"driver/lscpcie2"</span>, 0, 0, lscpcie2_read_procmem, NULL);
01377 <span class="preprocessor">#endif</span>
01378 <span class="preprocessor"></span>
01379 
01380     <span class="keywordflow">return</span>(0); <span class="comment">/* succeed */</span>
01381 
01382 }
01383 
01384 
01389 <span class="keyword">static</span> <span class="keywordtype">void</span> __exit lscpcie2_exit(<span class="keywordtype">void</span>)
01390 {
01391     <span class="keywordtype">int</span> i;
01392 
01393     printk(KERN_INFO <span class="stringliteral">"lscpcie2: _exit()\n"</span>);
01394 
01395 
01396     pci_unregister_driver(&amp;lscpcie2_driver);
01397 
01398     <span class="keywordflow">for</span> (i = 0; i &lt; NUM_BOARDS; i++)
01399     {
01400         <span class="keywordflow">if</span> (lscpcie2.Board[i].ID != 0)
01401         {
01402             <span class="comment">/* Do the cleanup for each active board */</span>
01403             printk(KERN_INFO <span class="stringliteral">"lscpcie2: Cleaning up board: %d\n"</span>, i);
01404 
01405             <span class="comment">// Disable and release IRQ if still active</span>
01406         }
01407     }
01408 
01409 
01410 <span class="preprocessor">#if (LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,6,12))</span>
01411 <span class="preprocessor"></span>    class_destroy(lscpcie2.sysClass);
01412 <span class="preprocessor">#else</span>
01413 <span class="preprocessor"></span>    class_simple_destroy(lscpcie2.sysClass);
01414 <span class="preprocessor">#endif</span>
01415 <span class="preprocessor"></span>
01416     <span class="comment">// Free every minor number and major number we reserved in init</span>
01417     unregister_chrdev_region(lscpcie2.drvrDevNum, MAX_MINORS);
01418 
01419 
01420 <span class="preprocessor">#ifdef USE_PROC</span>
01421 <span class="preprocessor"></span>    remove_proc_entry(<span class="stringliteral">"driver/lscpcie2"</span>, NULL);
01422 <span class="preprocessor">#endif</span>
01423 <span class="preprocessor"></span>
01424     <span class="keywordflow">return</span>;
01425 }
01426 
01427 
01428 <span class="comment">/*</span>
01429 <span class="comment"> * Kernel Dynamic Loadable Module Interface APIs</span>
01430 <span class="comment"> */</span>
01431 
01432 module_init(lscpcie2_init);
01433 module_exit(lscpcie2_exit);
01434 
01435 
01436 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Jul 16 12:05:23 2008 for Lattice lscpcie2 Device Driver  by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
