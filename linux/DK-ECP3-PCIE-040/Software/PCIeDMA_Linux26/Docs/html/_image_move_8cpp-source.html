<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Lattice PCIe DMA Demos: ImageMove.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<div class="nav">
<a class="el" href="dir_000002.html">ImageMove</a></div>
<h1>ImageMove.cpp</h1><a href="_image_move_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment"> *  COPYRIGHT (c) 2008 by Lattice Semiconductor Corporation</span>
00003 <span class="comment"> *</span>
00004 <span class="comment"> * All rights reserved. All use of this software and documentation is</span>
00005 <span class="comment"> * subject to the License Agreement located in the file LICENSE.</span>
00006 <span class="comment"> */</span>
00081 <span class="preprocessor">#include &lt;cstdlib&gt;</span>
00082 <span class="preprocessor">#include &lt;iostream&gt;</span>
00083 <span class="preprocessor">#include &lt;string&gt;</span> 
00084 
00085 <span class="preprocessor">#include &lt;stdio.h&gt;</span>   <span class="comment">// Always a good idea.</span>
00086 <span class="preprocessor">#include &lt;string.h&gt;</span>   <span class="comment">// Always a good idea.</span>
00087 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>   <span class="comment">// Always a good idea.</span>
00088 <span class="preprocessor">#include &lt;time.h&gt;</span>    <span class="comment">// For our FPS stats.</span>
00089 
00090 <span class="preprocessor">#include &lt;GL/glut.h&gt;</span> <span class="comment">// GLUT support library.</span>
00091 
00092 <span class="keyword">using</span> <span class="keyword">namespace </span>std;
00093 
00094 <span class="preprocessor">#include "PCIeAPI.h"</span>
00095 <span class="preprocessor">#include "DebugPrint.h"</span>
00096 <span class="preprocessor">#include "MiscUtils.h"</span>
00097 <span class="preprocessor">#include "LSCDMA_IF.h"</span>
00098 <span class="preprocessor">#include "GPIO.h"</span>
00099 <span class="preprocessor">#include "../MemMap.h"</span>   <span class="comment">// definition of all IP devices in this design</span>
00100 
00101 <span class="keyword">using</span> <span class="keyword">namespace </span>LatticeSemi_PCIe;
00102 
00103 
00104 <span class="preprocessor">#define IMAGE_FRAME_SIZE (256 * 256 * 4)</span>
00105 <span class="preprocessor"></span><span class="preprocessor">#define RUN_DMA 1</span>
00106 <span class="preprocessor"></span><span class="preprocessor">#define PAUSE 2</span>
00107 <span class="preprocessor"></span>
00108 
00109 <span class="comment">//----------------------------</span>
00110 <span class="comment">// Function Declarations</span>
00111 <span class="comment">//----------------------------</span>
00112 
00113 <span class="keywordtype">void</span> <a class="code" href="_color_bars_8cpp.html#a20">cleanUpAndExit</a>(<span class="keywordtype">void</span>);
00114 <span class="keywordtype">void</span> <a class="code" href="_color_bars_8cpp.html#a21">cbDraw</a>(<span class="keywordtype">void</span>);
00115 <span class="keywordtype">void</span> <a class="code" href="_image_move_8cpp.html#a16">cbKeyPressed</a>( <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> key, <span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y);
00116 <span class="keywordtype">void</span> <a class="code" href="_image_move_8cpp.html#a17">cbSpecialKeyPressed</a>( <span class="keywordtype">int</span> key, <span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y);
00117 <span class="keywordtype">void</span> <a class="code" href="_image_move_8cpp.html#a18">cbReshape</a>( <span class="keywordtype">int</span> Width, <span class="keywordtype">int</span> Height);
00118 <span class="keywordtype">void</span> <a class="code" href="_image_move_8cpp.html#a19">setupDrawing</a>(<span class="keywordtype">int</span> Width, <span class="keywordtype">int</span> Height);
00119 
00120 
00121 <span class="comment">//----------------------------</span>
00122 <span class="comment">// Global Variables</span>
00123 <span class="comment">//----------------------------</span>
00124 
00125 ULONG LoopCnt;
00126 ULONG ElpsCnt;
00127 clock_t StartTime;
00128 
00129 <span class="keywordtype">int</span> SrcWindow_ID;
00130 <span class="keywordtype">int</span> DstWindow_ID;
00131 <span class="keywordtype">int</span> Window_Width = 256;
00132 <span class="keywordtype">int</span> Window_Height = 256;
00133 
00134 ULONG *pSrcImgBuf, *pDstImgBuf; 
00135 
00136 LSCDMA_IF *pDrvr;
00137 
00138 <span class="keyword">const</span> <span class="keywordtype">char</span>* SrcWindowTitle = <span class="stringliteral">"LatticeSGDMA: Src Img"</span>;
00139 <span class="keyword">const</span> <span class="keywordtype">char</span>* DstWindowTitle = <span class="stringliteral">"LatticeSGDMA: Dest Img"</span>;
00140 
00141 ULONG PixelTransformMask = 0xcc33aa55;
00142 
00143 ULONG OpMode = RUN_DMA;
00144 
00145 
<a name="l00151"></a><a class="code" href="_image_move_8cpp.html#a20">00151</a> <span class="keywordtype">int</span> <a class="code" href="_image_move_8cpp.html#a20">main</a>( <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)
00152 {
00153     <span class="keywordtype">char</span> title[256];
00154 
00155     <span class="keywordtype">char</span> boardName[LSC_PCIE_BOARD_NAME_LEN + 1];
00156     <span class="keywordtype">char</span> demoName[LSC_PCIE_DEMO_NAME_LEN + 1];
00157     uint32_t boardNum;
00158     string infoStr;
00159     ULONG regVal;
00160 
00161     ENTER();
00162 
00163     <span class="comment">//--------------------------------------------------------------------</span>
00164     <span class="comment">// Create an instance of the Lattice PCIeAPI DLL to ensure library is</span>
00165     <span class="comment">// loaded and initialized and get the and display the version info</span>
00166     <span class="comment">// for diagnostic purposes.</span>
00167     <span class="comment">//--------------------------------------------------------------------</span>
00168     PCIeAPI theDLL;
00169     DEBUGPRINT((<span class="stringliteral">"Dll version info: %s\n"</span>, theDLL.getVersionStr()));
00170 
00171     <span class="comment">//--------------------------------------------------------------------</span>
00172     <span class="comment">// Allocate 2 buffers to hold the source and destination image buffer.</span>
00173     <span class="comment">// The buffers are 256 x 256 pixels.  Each pixel is 4 bytes, so get 256KB total.</span>
00174     <span class="comment">// Use the PCIeAPI function to allocate a page (or 64KB) aligned buffer.</span>
00175     <span class="comment">// This is nice because the start of the buffer will be the start of a</span>
00176     <span class="comment">// page so all BDs setup in the SGDMA will map to complete virtual pages.</span>
00177     <span class="comment">// NOTE: buffers not allocated using this have the potential to cause</span>
00178     <span class="comment">// longer transfer times because fragmented pages could result.  The</span>
00179     <span class="comment">// SGDMA has 256 BDs which is just enough to hold a SG list of 4KB pages</span>
00180     <span class="comment">// to describe an entire 1MB buffer.  If partial pages are used (exceeding</span>
00181     <span class="comment">// 256 maximum), then multiple SG list setups will be needed, increasing</span>
00182     <span class="comment">// setup and xfer time.</span>
00183     <span class="comment">//--------------------------------------------------------------------</span>
00184     pSrcImgBuf = (ULONG *)AllocAlignedBuffer(IMAGE_FRAME_SIZE);
00185     <span class="keywordflow">if</span> (pSrcImgBuf == NULL)
00186     {
00187         ERRORSTR(<span class="stringliteral">"ERROR! AllocAlignedBuffer failed.  exiting\n"</span>);
00188         exit(-1);
00189     }
00190 
00191     pDstImgBuf = (ULONG *)AllocAlignedBuffer(IMAGE_FRAME_SIZE);
00192     <span class="keywordflow">if</span> (pDstImgBuf == NULL)
00193     {
00194         FreeAlignedBuffer(pSrcImgBuf, IMAGE_FRAME_SIZE);
00195         ERRORSTR(<span class="stringliteral">"ERROR! AllocAlignedBuffer failed.  exiting\n"</span>);
00196         exit(-1);
00197     }
00198     LoopCnt = 0;
00199 
00200     <span class="comment">//--------------------------------------------------------------------</span>
00201     <span class="comment">// Get the environment variables needed to open the desired eval board.</span>
00202     <span class="comment">// These are setup by the scan utility program or defined at the command</span>
00203     <span class="comment">// line. Pre-load with defaults in case env vars are not found.</span>
00204     <span class="comment">//--------------------------------------------------------------------</span>
00205     strcpy(boardName, <span class="stringliteral">"ECP2M"</span>);
00206     strcpy(demoName, <span class="stringliteral">"DMA"</span>);
00207     <span class="keywordflow">if</span> (!GetPCIeEnvVars(boardName, demoName, boardNum))
00208         DEBUGSTR(<span class="stringliteral">"\nEnvVars not found.  Using defaults.\n"</span>);
00209 
00210     DEBUGPRINT((<span class="stringliteral">"boardName = %s"</span>, boardName));
00211     DEBUGPRINT((<span class="stringliteral">"  boardNum = %d"</span>, boardNum));
00212     DEBUGPRINT((<span class="stringliteral">"  demoName = %s\n"</span>, demoName));
00213 
00214 
00215 
00216     <span class="comment">//--------------------------------------------------------------------</span>
00217     <span class="comment">// Open the Lattice DMA driver to the board.</span>
00218     <span class="comment">// An exception will be thrown if any problems occur finding or </span>
00219     <span class="comment">// accessing the hardware.</span>
00220     <span class="comment">//--------------------------------------------------------------------</span>
00221     <span class="keywordflow">try</span>
00222     {
00223         DEBUGPRINT((<span class="stringliteral">"Opening LSCDMA_IF...ImageMove\n"</span>));
00224         pDrvr = <span class="keyword">new</span> LSCDMA_IF(boardName, 
00225                           <span class="stringliteral">"_IM"</span>,    <span class="comment">// function = ImageMove</span>
00226                           boardNum);
00227     }
00228     <span class="keywordflow">catch</span> (std::exception &amp;e)
00229     {
00230         ERRORSTR(<span class="stringliteral">"\nError opening driver: "</span>);
00231         ERRORSTR(e.what());
00232         ShowLastError();
00233         FreeAlignedBuffer(pSrcImgBuf, IMAGE_FRAME_SIZE);
00234         FreeAlignedBuffer(pDstImgBuf, IMAGE_FRAME_SIZE);
00235         printf(<span class="stringliteral">"Error opening lscdma ImageMove driver.\n"</span>);
00236         exit(-1);
00237     }
00238 
00239 
00240     <span class="comment">//=========================================================</span>
00241     <span class="comment">// Verify access to the driver and resources.</span>
00242     <span class="comment">//=========================================================</span>
00243     <span class="keyword">const</span> DMAResourceInfo_t *pLinkInfo;
00244     <span class="keywordflow">if</span> (pDrvr-&gt;getDriverDMAInfo(&amp;pLinkInfo) == <span class="keyword">false</span>)
00245     {
00246         printf(<span class="stringliteral">"Error accessing driver.\n"</span>);
00247         FreeAlignedBuffer(pSrcImgBuf, IMAGE_FRAME_SIZE);
00248         FreeAlignedBuffer(pDstImgBuf, IMAGE_FRAME_SIZE);
00249         exit(-1);
00250     }
00251 
00252 
00253 
00254 
00255     <span class="comment">//===============================================================</span>
00256     <span class="comment">// Verify the IP is accessable over the PCIe/Wishbone bus</span>
00257     <span class="comment">//===============================================================</span>
00258     regVal = pDrvr-&gt;read32(memGPIO(0x00));
00259     <span class="keywordflow">if</span> ((regVal &amp; 0xffff0000) != 0x12040000)
00260     {
00261         ERRORSTR(<span class="stringliteral">"\nError accessing GPIO ID register."</span>);
00262         FreeAlignedBuffer(pSrcImgBuf, IMAGE_FRAME_SIZE);
00263         FreeAlignedBuffer(pDstImgBuf, IMAGE_FRAME_SIZE);
00264         printf(<span class="stringliteral">"Error accessing IP registers.\n"</span>);
00265         exit(-1);
00266     }
00267 
00268 
00269     <span class="comment">//===============================================================</span>
00270     <span class="comment">// Reset the ColorBar Pixel Data Generator</span>
00271     <span class="comment">//===============================================================</span>
00272     pDrvr-&gt;write32(memGPIO(0x30), 1);
00273     pDrvr-&gt;write32(memGPIO(0x30), 0);
00274 
00275 
00276     <span class="comment">//===============================================================</span>
00277     <span class="comment">// Create the OpenGL Window.</span>
00278     <span class="comment">//===============================================================</span>
00279     glutInit(&amp;argc, argv);
00280 
00281     <span class="comment">//------------- DESTINATION IMAGE WINDOW -------------</span>
00282     glutInitWindowPosition(400, 200);
00283     glutInitWindowSize(Window_Width, Window_Height);
00284     glutInitDisplayMode(GLUT_RGBA | GLUT_DOUBLE);
00285 
00286     sprintf(title, <span class="stringliteral">"%s :  %d FPS"</span>, DstWindowTitle, ElpsCnt);
00287     DstWindow_ID = glutCreateWindow(title);
00288     <span class="keywordflow">if</span> (DstWindow_ID == GL_FALSE)
00289     {
00290         printf(<span class="stringliteral">"Failed to create Destination Window!\n"</span>);
00291         FreeAlignedBuffer(pSrcImgBuf, IMAGE_FRAME_SIZE);
00292         FreeAlignedBuffer(pDstImgBuf, IMAGE_FRAME_SIZE);
00293         exit(-1);
00294     }
00295 
00296     <span class="comment">//------------- SOURCE IMAGE WINDOW -------------</span>
00297     <span class="comment">// Set display and drawing mode</span>
00298     glutInitWindowPosition(100, 100);
00299     glutInitDisplayMode(GLUT_RGBA | GLUT_DOUBLE);
00300     glutInitWindowSize(Window_Width, Window_Height);
00301 
00302     <span class="comment">// Open a window </span>
00303     sprintf(title, <span class="stringliteral">"%s :  %d FPS"</span>, SrcWindowTitle, ElpsCnt);
00304     SrcWindow_ID = glutCreateWindow(title);
00305     <span class="keywordflow">if</span> (SrcWindow_ID == GL_FALSE)
00306     {
00307         printf(<span class="stringliteral">"Failed to create Source Window!\n"</span>);
00308         FreeAlignedBuffer(pSrcImgBuf, IMAGE_FRAME_SIZE);
00309         FreeAlignedBuffer(pDstImgBuf, IMAGE_FRAME_SIZE);
00310         exit(-1);
00311     }
00312 
00313 
00314     <span class="comment">// Assign all the controls to the source window</span>
00315     <span class="comment">// Cursor has to be in Source Window to change pixel mask and exit</span>
00316     glutSetWindow(SrcWindow_ID);
00317 
00318 
00319     <span class="comment">// Register the callback function to do the drawing. </span>
00320     glutDisplayFunc(&amp;<a class="code" href="_color_bars_8cpp.html#a21">cbDraw</a>);
00321 
00322     <span class="comment">// If there's nothing to do, draw.</span>
00323     glutIdleFunc(&amp;<a class="code" href="_color_bars_8cpp.html#a21">cbDraw</a>);
00324 
00325     <span class="comment">// It's a good idea to know when our window's resized.</span>
00326     glutReshapeFunc(&amp;<a class="code" href="_color_bars_8cpp.html#a24">cbReshape</a>);
00327 
00328     <span class="comment">// And let's get some keyboard input.</span>
00329     glutKeyboardFunc(&amp;<a class="code" href="_color_bars_8cpp.html#a22">cbKeyPressed</a>);
00330     glutSpecialFunc(&amp;<a class="code" href="_color_bars_8cpp.html#a23">cbSpecialKeyPressed</a>);
00331 
00332     <span class="comment">// OpenGL's ready to go.  Call init function to setup colors and matrixes.</span>
00333     <a class="code" href="_image_move_8cpp.html#a19">setupDrawing</a>(Window_Width, Window_Height);
00334 
00335     <span class="comment">// Print out a bit of help dialog.</span>
00336     printf(<span class="stringliteral">"\n\nLattice PCIe DMA Image Move Demo\n"</span>);
00337     printf(<span class="stringliteral">"&lt;Esc&gt;|Q|X - terminates program and closes the window\n"</span>);
00338     printf(<span class="stringliteral">"&lt;F1&gt; - XOR filter set to 0xcc33aa55 (changes resulting display).\n"</span>);
00339     printf(<span class="stringliteral">"&lt;F2&gt; - XOR filter set to 0xf0f0f0f0 (changes resulting display).\n"</span>);
00340     printf(<span class="stringliteral">"&lt;F3&gt; - XOR filter set to 0x0f0f0f0f (changes resulting display).\n"</span>);
00341     printf(<span class="stringliteral">"OpenGL window must have focus to accept input.\n"</span>);
00342 
00343     StartTime = clock();
00344 
00345     <span class="comment">// Pass off control to OpenGL.</span>
00346     <span class="comment">// OpenGL will invoke the callbacks when needed to Draw, process KeyPress, etc.</span>
00347     glutMainLoop();
00348 
00349 
00350     <span class="comment">// Never get here because glutMainLoop never returns.</span>
00351     <span class="keywordflow">return</span>(0);   
00352 }
00353 
00354 
00355 
00363 <span class="keywordtype">void</span>    <a class="code" href="_color_bars_8cpp.html#a20">cleanUpAndExit</a>(<span class="keywordtype">void</span>)
00364 {
00365     ENTER();    
00366     <span class="comment">//-----------------------------------------------------</span>
00367     <span class="comment">// Exiting and shutting down</span>
00368     <span class="comment">//-----------------------------------------------------</span>
00369 
00370     glutDestroyWindow(SrcWindow_ID);
00371     glutDestroyWindow(DstWindow_ID);
00372 
00373 
00374     <span class="comment">/* Close all LSC_PCIe objects i.e. driver interface */</span>
00375     <span class="keyword">delete</span> pDrvr;
00376     FreeAlignedBuffer(pSrcImgBuf, IMAGE_FRAME_SIZE);
00377     FreeAlignedBuffer(pDstImgBuf, IMAGE_FRAME_SIZE);
00378 
00379     LEAVE();    
00380 
00381         exit(0);
00382 }
00383 
00384 
00389 <span class="keywordtype">void</span> <a class="code" href="_color_bars_8cpp.html#a21">cbDraw</a>(<span class="keywordtype">void</span>)
00390 {
00391     <span class="keywordtype">char</span> buf[256];
00392     clock_t c1;
00393     <span class="keywordtype">double</span> elpstime;
00394     <span class="keyword">static</span> <span class="keywordtype">float</span> theta = 0.0f;
00395     ULONG *pSrc, *pDst;
00396     ULONG i, j;
00397 
00398 
00399     <span class="comment">//-------------------------------------------------</span>
00400     <span class="comment">// FIRST: draw to the Source window the original image</span>
00401     <span class="comment">//-------------------------------------------------</span>
00402 
00403     glutSetWindow(SrcWindow_ID);
00404 
00405     <span class="comment">// Clear the color buffer.</span>
00406     glClear(GL_COLOR_BUFFER_BIT);
00407 
00408 
00409     glPushMatrix();
00410     glRotatef(theta, 0.0f, 0.0f, 1.0f);
00411     glBegin(GL_TRIANGLES);
00412         glColor3f(1.0f, 0.0f, 0.0f);   glVertex2f(0.0f, 1.0f);
00413         glColor3f(0.0f, 1.0f, 0.0f);   glVertex2f(0.87f, -0.5f);
00414         glColor3f(0.0f, 0.0f, 1.0f);   glVertex2f(-0.87f, -0.5f);
00415     glEnd();
00416     glPopMatrix ();
00417 
00418     <span class="comment">// All done drawing.  Let's show it.</span>
00419     glFlush();
00420     glutSwapBuffers();
00421 
00422 
00423     <span class="comment">//------------------------------------------------------------------------</span>
00424     <span class="comment">// SECOND: Copy the drawn image from the Source window to a memory buffer</span>
00425     <span class="comment">//------------------------------------------------------------------------</span>
00426     glReadPixels(0, 0, 256, 256, GL_RGBA, GL_UNSIGNED_BYTE, pSrcImgBuf);
00427 
00428 
00429 
00430     <span class="comment">//------------------------------------------------------------------------</span>
00431     <span class="comment">// THIRD: Move the source image buffer through the EBR64 and modify</span>
00432     <span class="comment">// the pixel values on the way back out to the destination buffer</span>
00433     <span class="comment">//------------------------------------------------------------------------</span>
00434 <span class="preprocessor">#if 1</span>
00435 <span class="preprocessor"></span>    <span class="comment">// Hardware moves the image</span>
00436 
00437     <span class="comment">//---------------------------------------------------</span>
00438     <span class="comment">// Write to the Pixel Mask register in the GPIO block.</span>
00439     <span class="comment">// This 32 bit value is XORed with each pixel when its</span>
00440     <span class="comment">// read back out of the EBR64 memory, thus changing the</span>
00441     <span class="comment">// colors of the pixels between source image and</span>
00442     <span class="comment">// destination image.</span>
00443     <span class="comment">//---------------------------------------------------</span>
00444     pDrvr-&gt;write32(memGPIO(0x28), PixelTransformMask);
00445 
00446     <span class="comment">//---------------------------------------------------</span>
00447     <span class="comment">// Have to do the write/read in 4 stages cause the</span>
00448     <span class="comment">// EBR memory on the Eval Board is only 64KB in size</span>
00449     <span class="comment">// and can't hold an entire image frame at once.</span>
00450     <span class="comment">//---------------------------------------------------</span>
00451     pSrc = pSrcImgBuf;
00452     pDst = pDstImgBuf;
00453     <span class="keywordflow">for</span> (i = 0; i &lt; 4; i++)
00454     {
00455         <span class="comment">//-----------------------------------------------------------------------</span>
00456         <span class="comment">// Send 64KB of the source image to the Image Filter Memory on the board</span>
00457         <span class="comment">//-----------------------------------------------------------------------</span>
00458         <span class="keywordflow">if</span> (pDrvr-&gt;WriteToDevice(pSrc, IMAGE_FRAME_SIZE/4) == <span class="keyword">false</span>)
00459         {
00460             ERRORSTR(<span class="stringliteral">"DEVICE WRITE ERROR!\nExiting.\n"</span>);
00461             <a class="code" href="_color_bars_8cpp.html#a20">cleanUpAndExit</a>();
00462         }
00463 
00464         <span class="comment">//-----------------------------------------------------------------------</span>
00465         <span class="comment">// Read back 64KB of the modified image into the destination buffer</span>
00466         <span class="comment">//-----------------------------------------------------------------------</span>
00467         <span class="keywordflow">if</span> (pDrvr-&gt;ReadFromDevice(pDst, IMAGE_FRAME_SIZE/4) == <span class="keyword">false</span>)
00468         {
00469             ERRORSTR(<span class="stringliteral">"DEVICE READ ERROR!\nExiting.\n"</span>);
00470             <a class="code" href="_color_bars_8cpp.html#a20">cleanUpAndExit</a>();
00471         }
00472 
00473         pSrc = pSrc + ((IMAGE_FRAME_SIZE/4) / <span class="keyword">sizeof</span>(ULONG));
00474         pDst = pDst + ((IMAGE_FRAME_SIZE/4) / <span class="keyword">sizeof</span>(ULONG));
00475 
00476     }
00477 
00478 
00479 <span class="preprocessor">#else // software moves pixels from source buffer to destination buffer</span>
00480 <span class="preprocessor"></span>    pSrc = pSrcImgBuf;
00481     pDst = pDstImgBuf;
00482     <span class="keywordflow">for</span> (i = 0; i &lt; 256; i++)
00483     {
00484         <span class="keywordflow">for</span> (j = 0; j &lt; 256; j++)
00485         {
00486             *pDst = *pSrc ^ PixelTransformMask;
00487             ++pDst;
00488             ++pSrc;
00489         }
00490     }
00491 <span class="preprocessor">#endif   </span>
00492 <span class="preprocessor"></span>
00493 
00494     <span class="comment">//---------------------------------------------------------</span>
00495     <span class="comment">// FOURTH: draw the changed image to the Destination window </span>
00496     <span class="comment">//---------------------------------------------------------</span>
00497 
00498     glutSetWindow(DstWindow_ID);
00499 
00500     glDrawPixels(256, 256, GL_RGBA, GL_UNSIGNED_BYTE, pDstImgBuf);
00501 
00502     <span class="comment">// All done drawing.  Let's show it.</span>
00503     glFlush();
00504     glutSwapBuffers();
00505 
00506     theta += 1.0f;
00507 
00508     ++LoopCnt;
00509     ++ElpsCnt;
00510 
00511 <span class="comment">//TODO</span>
00512 <span class="preprocessor">#if 0</span>
00513 <span class="preprocessor"></span>    <span class="keywordflow">if</span> ((LoopCnt % 100) == 0)
00514     {
00515         printf(<span class="stringliteral">"."</span>);
00516         fflush(stdout);
00517     }
00518 <span class="preprocessor">#endif</span>
00519 <span class="preprocessor"></span>
00520     <span class="comment">//------------------------------------------------------------</span>
00521     <span class="comment">// Time how many frames are drawn per second.</span>
00522     <span class="comment">// This is a relative benchmark for DMA performance when compared</span>
00523     <span class="comment">// to software or baseline</span>
00524     <span class="comment">//------------------------------------------------------------</span>
00525     c1 = clock();
00526     elpstime = (double)(c1 - StartTime)/(CLOCKS_PER_SEC );
00527 
00528     <span class="keywordflow">if</span> (elpstime &gt;= 1.0)
00529     {
00530         sprintf(buf, <span class="stringliteral">"%s: %d FPS"</span>, DstWindowTitle, ElpsCnt);
00531         glutSetWindowTitle(buf);
00532         ElpsCnt = 0;
00533         StartTime = c1;
00534     }
00535 
00536     glutSetWindow(SrcWindow_ID);
00537 }
00538 
00539 
00540 
00546 <span class="keywordtype">void</span> <a class="code" href="_image_move_8cpp.html#a16">cbKeyPressed</a>( <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> key, <span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y)
00547 {
00548     <span class="keywordtype">char</span> buf[256];
00549 
00550     <span class="keywordflow">switch</span> (key) 
00551     {
00552             <span class="keywordflow">case</span> <span class="charliteral">'X'</span>: 
00553             <span class="keywordflow">case</span> <span class="charliteral">'x'</span>: 
00554             <span class="keywordflow">case</span> <span class="charliteral">'Q'</span>: 
00555         <span class="keywordflow">case</span> <span class="charliteral">'q'</span>: 
00556         <span class="keywordflow">case</span> 27: <span class="comment">// Escape</span>
00557             <a class="code" href="_color_bars_8cpp.html#a20">cleanUpAndExit</a>();
00558                 <span class="keywordflow">break</span>; <span class="comment">// exit doesn't return, but anyway...</span>
00559 
00560         <span class="keywordflow">case</span> 0x20: <span class="comment">// SPACE</span>
00561             <span class="keywordflow">if</span> (OpMode == PAUSE)
00562                 OpMode = RUN_DMA;
00563             <span class="keywordflow">else</span>
00564                 OpMode = PAUSE;
00565             <span class="keywordflow">break</span>;
00566             
00567 
00568         <span class="keywordflow">case</span> <span class="charliteral">'d'</span>:
00569         <span class="keywordflow">case</span> <span class="charliteral">'D'</span>:
00570             glutPostRedisplay();  <span class="comment">// for debugging can step 1 frame per key</span>
00571             <span class="keywordflow">break</span>;
00572 
00573         <span class="keywordflow">default</span>:
00574                 <span class="comment">//printf ("KP: No action for %d.\n", key);</span>
00575             <span class="keywordflow">break</span>;
00576     }
00577 }
00578 
00579 
00580 
00586 <span class="keywordtype">void</span> <a class="code" href="_image_move_8cpp.html#a17">cbSpecialKeyPressed</a>( <span class="keywordtype">int</span> key, <span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y)
00587 {
00588     <span class="keywordtype">char</span> buf[256];
00589 
00590     <span class="keywordflow">switch</span> (key) 
00591     {
00592 
00593         <span class="keywordflow">case</span> GLUT_KEY_F1:
00594             PixelTransformMask = 0xcc33aa55;
00595             <span class="keywordflow">break</span>;
00596 
00597         <span class="keywordflow">case</span> GLUT_KEY_F2:
00598             PixelTransformMask = 0xf0f0f0f0;
00599             <span class="keywordflow">break</span>;
00600 
00601         <span class="keywordflow">case</span> GLUT_KEY_F3:
00602             PixelTransformMask = 0x0f0f0f0f;
00603             <span class="keywordflow">break</span>;
00604 
00605         <span class="keywordflow">case</span> GLUT_KEY_F4:
00606             PixelTransformMask = 0x00000000;
00607             <span class="keywordflow">break</span>;
00608 
00609 
00610         <span class="keywordflow">default</span>:
00611                 <span class="comment">//printf ("SKP: No action for %d.\n", key);</span>
00612             <span class="keywordflow">break</span>;
00613     }
00614 
00615 }
00616 
00617 
00623 <span class="keywordtype">void</span> <a class="code" href="_image_move_8cpp.html#a18">cbReshape</a>( <span class="keywordtype">int</span> Width, <span class="keywordtype">int</span> Height)
00624 {
00625     <span class="comment">// Make sure denominator is never 0</span>
00626     <span class="keywordflow">if</span> (Height == 0)
00627         Height = 1;
00628 
00629     glViewport(0, 0, Width, Height);
00630 
00631     glMatrixMode(GL_PROJECTION);
00632     glLoadIdentity();
00633     gluOrtho2D(-1, 1, -1, 1);
00634 
00635     glMatrixMode(GL_MODELVIEW);
00636 
00637     Window_Width  = Width;
00638     Window_Height = Height;
00639 }
00640 
00641 
00646 <span class="keywordtype">void</span> <a class="code" href="_image_move_8cpp.html#a19">setupDrawing</a>(<span class="keywordtype">int</span> Width, <span class="keywordtype">int</span> Height) 
00647 {
00648 
00649     <span class="comment">// Color to clear color buffer to.</span>
00650     glClearColor(0.1f, 0.1f, 0.1f, 0.0f);
00651 
00652     <span class="comment">// Enables Smooth Color Shading</span>
00653     glShadeModel(GL_SMOOTH);
00654 
00655     <span class="comment">// Load up the correct perspective matrix; using a callback directly.</span>
00656     <a class="code" href="_image_move_8cpp.html#a18">cbReshape</a>(Width, Height);
00657 }
00658 
00659 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Jul 16 12:05:28 2008 for Lattice PCIe DMA Demos by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
