<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Lattice PCIe DMA Demos: ColorBars.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<div class="nav">
<a class="el" href="dir_000000.html">ColorBars</a></div>
<h1>ColorBars.cpp</h1><a href="_color_bars_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment"> *  COPYRIGHT (c) 2008 by Lattice Semiconductor Corporation</span>
00003 <span class="comment"> *</span>
00004 <span class="comment"> * All rights reserved. All use of this software and documentation is</span>
00005 <span class="comment"> * subject to the License Agreement located in the file LICENSE.</span>
00006 <span class="comment"> */</span>
00086 <span class="preprocessor">#include &lt;cstdlib&gt;</span>
00087 <span class="preprocessor">#include &lt;iostream&gt;</span>
00088 <span class="preprocessor">#include &lt;string&gt;</span> 
00089 
00090 <span class="preprocessor">#include &lt;stdio.h&gt;</span>   <span class="comment">// Always a good idea.</span>
00091 <span class="preprocessor">#include &lt;string.h&gt;</span>   <span class="comment">// Always a good idea.</span>
00092 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>   <span class="comment">// Always a good idea.</span>
00093 <span class="preprocessor">#include &lt;time.h&gt;</span>    <span class="comment">// For our FPS stats.</span>
00094 
00095 <span class="preprocessor">#include &lt;GL/glut.h&gt;</span> <span class="comment">// GLUT support library.</span>
00096 
00097 <span class="keyword">using</span> <span class="keyword">namespace </span>std;
00098 
00099 <span class="preprocessor">#include "PCIeAPI.h"</span>
00100 <span class="preprocessor">#include "DebugPrint.h"</span>
00101 <span class="preprocessor">#include "MiscUtils.h"</span>
00102 <span class="preprocessor">#include "LSCDMA_IF.h"</span>
00103 <span class="preprocessor">#include "GPIO.h"</span>
00104 <span class="preprocessor">#include "../MemMap.h"</span>   <span class="comment">// definition of all IP devices in this design</span>
00105 
00106 <span class="keyword">using</span> <span class="keyword">namespace </span>LatticeSemi_PCIe;
00107 
00108 
00109 
00110 <span class="preprocessor">#define CB_IMAGE_FRAME_SIZE (1024 * 1024)</span>
00111 <span class="preprocessor"></span>
00112 <span class="preprocessor">#define BASE_RATE 1</span>
00113 <span class="preprocessor"></span><span class="preprocessor">#define SOFTWARE_RATE 2</span>
00114 <span class="preprocessor"></span><span class="preprocessor">#define DMA_RATE 3</span>
00115 <span class="preprocessor"></span><span class="preprocessor">#define PAUSE 4</span>
00116 <span class="preprocessor"></span>
00117 
00118 <span class="comment">//----------------------------</span>
00119 <span class="comment">// Function Declarations</span>
00120 <span class="comment">//----------------------------</span>
00121 
00122 <span class="keywordtype">void</span> <a class="code" href="_color_bars_8cpp.html#a20">cleanUpAndExit</a>(<span class="keywordtype">void</span>);
00123 <span class="keywordtype">void</span> <a class="code" href="_color_bars_8cpp.html#a21">cbDraw</a>(<span class="keywordtype">void</span>);
00124 <span class="keywordtype">void</span> <a class="code" href="_image_move_8cpp.html#a16">cbKeyPressed</a>( <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> key, <span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y);
00125 <span class="keywordtype">void</span> <a class="code" href="_image_move_8cpp.html#a17">cbSpecialKeyPressed</a>( <span class="keywordtype">int</span> key, <span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y);
00126 <span class="keywordtype">void</span> <a class="code" href="_image_move_8cpp.html#a18">cbReshape</a>( <span class="keywordtype">int</span> Width, <span class="keywordtype">int</span> Height);
00127 <span class="keywordtype">void</span> <a class="code" href="_image_move_8cpp.html#a19">setupDrawing</a>(<span class="keywordtype">int</span> Width, <span class="keywordtype">int</span> Height);
00128 
00129 
00130 <span class="comment">//----------------------------</span>
00131 <span class="comment">// Global Variables</span>
00132 <span class="comment">//----------------------------</span>
00133 
00134 ULONG WaitTime = 0;
00135 ULONG OpMode = DMA_RATE;
00136 ULONG PrevMode = DMA_RATE;
00137 ULONG PixelVal = 0x00000000;
00138 
00139 ULONG *pImgBuf;      
00140 ULONG LoopCnt;
00141 ULONG ElpsCnt;
00142 clock_t StartTime;
00143 
00144 <span class="keywordtype">int</span> Window_ID;
00145 <span class="keywordtype">int</span> Window_Width = 512;
00146 <span class="keywordtype">int</span> Window_Height = 512;
00147 
00148 
00149 LSCDMA_IF *pDrvr;
00150 
00151 <span class="keyword">const</span> <span class="keywordtype">char</span>* WindowTitle = <span class="stringliteral">"LatticeSGDMA: ColorBars"</span>;
00152 
00153 <span class="keyword">const</span> <span class="keywordtype">char</span> *ModeName[5] = {<span class="stringliteral">""</span>, <span class="stringliteral">"BASE_Rate"</span>, <span class="stringliteral">"SW_Rate"</span>, <span class="stringliteral">"DMA_Rate"</span>, <span class="stringliteral">"Paused"</span>};
00154 
00155 <span class="comment">//----------------------------------------------------------</span>
00156 <span class="comment">// Pixel data used for drawing image in software mode.</span>
00157 <span class="comment">// Emulate the color data read from hardware.</span>
00158 <span class="comment">//----------------------------------------------------------</span>
00159 <span class="comment">//</span>
00160 <span class="comment">// Pixel = [Alpha][Blue][Green][Red]</span>
00161 <span class="comment">//</span>
00162 <span class="comment">// PixelVal = 0xff000000;  // alpha on</span>
00163 <span class="comment">// PixelVal = 0x00ff0000;  // blue on</span>
00164 <span class="comment">// PixelVal = 0x0000ff00;  // green on</span>
00165 <span class="comment">// PixelVal = 0x000000ff;  // red on</span>
00166 
00167 ULONG Color[64] =
00168 { 
00169     0x000000ff,  <span class="comment">// 0</span>
00170     0x00000ef3,
00171     0x00001ce7,
00172     0x000028db,
00173     0x000034cf,
00174     0x000040c3,
00175     0x00004cb7,
00176     0x000058ab,
00177     0x0000649f,
00178     0x00007093,
00179     0x00007c87,
00180     0x0000887b,
00181     0x0000946f,
00182     0x0000a063,
00183     0x0000ac57,
00184     0x0000b84b,
00185     0x0000c43f,   <span class="comment">// 16</span>
00186     0x0000d033,
00187     0x0000dc27,
00188     0x0000e81b,
00189     0x0000f40f,
00190     0x0000ff00,
00191     0x000ef300,
00192     0x001ce700,
00193     0x0028db00,
00194     0x0034cf00,
00195     0x0040c300,
00196     0x004cb700,
00197     0x0058ab00,
00198     0x00649f00,
00199     0x00709300,
00200     0x007c8700,
00201     0x00887b00,   <span class="comment">// 32</span>
00202     0x00946f00,
00203     0x00a06300,
00204     0x00ac5700,
00205     0x00b84b00,
00206     0x00c43f00,
00207     0x00d03300,
00208     0x00dc2700,
00209     0x00e81b00,
00210     0x00f40f00,
00211     0x00ff0300,
00212     0x00ff0000,
00213     0x00f3000e,
00214     0x00e7001c,
00215     0x00db0028,
00216     0x00cf0034,
00217     0x00c30040,   <span class="comment">// 48</span>
00218     0x00b7004c,
00219     0x00ab0058,
00220     0x009f0064,
00221     0x00930070,
00222     0x0087007c,
00223     0x007b0088,
00224     0x006f0094,
00225     0x006300a0,
00226     0x005700ac,
00227     0x004b00b8,
00228     0x003f00c4,
00229     0x003300d0,
00230     0x002700dc,
00231     0x001b00e8,
00232     0x000f00f4   <span class="comment">// 63</span>
00233 };
00234 
00235 
<a name="l00241"></a><a class="code" href="_color_bars_8cpp.html#a26">00241</a> <span class="keywordtype">int</span> <a class="code" href="_image_move_8cpp.html#a20">main</a>( <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)
00242 {
00243 
00244     <span class="keywordtype">char</span> title[256];
00245 
00246 
00247     <span class="keywordtype">char</span> boardName[LSC_PCIE_BOARD_NAME_LEN + 1];
00248     <span class="keywordtype">char</span> demoName[LSC_PCIE_DEMO_NAME_LEN + 1];
00249     uint32_t boardNum;
00250     string infoStr;
00251     ULONG regVal;
00252 
00253     ENTER();
00254 
00255     <span class="comment">//--------------------------------------------------------------------</span>
00256     <span class="comment">// Create an instance of the Lattice PCIeAPI DLL to ensure library is</span>
00257     <span class="comment">// loaded and initialized and get the and display the version info</span>
00258     <span class="comment">// for diagnostic purposes.</span>
00259     <span class="comment">//--------------------------------------------------------------------</span>
00260     PCIeAPI theDLL;
00261     DEBUGPRINT((<span class="stringliteral">"Dll version info: %s\n"</span>, theDLL.getVersionStr()));
00262 
00263 
00264     <span class="comment">//--------------------------------------------------------------------</span>
00265     <span class="comment">// Allocate a buffer to hold the ColorBar image buffer.  This buffer is </span>
00266     <span class="comment">// 512 x 512 pixels.  Each pixel is 4 bytes, so get 1MB total.</span>
00267     <span class="comment">// Use the PCIeAPI function to allocate a page (or 64KB) aligned buffer.</span>
00268     <span class="comment">// This is nice because the start of the buffer will be the start of a</span>
00269     <span class="comment">// page so all BDs setup in the SGDMA will map to complete virtual pages.</span>
00270     <span class="comment">// NOTE: buffers not allocated using this have the potential to cause</span>
00271     <span class="comment">// longer transfer times because fragmented pages could result.  The</span>
00272     <span class="comment">// SGDMA has 256 BDs which is just enough to hold a SG list of 4KB pages</span>
00273     <span class="comment">// to describe an entire 1MB buffer.  If partial pages are used (exceeding</span>
00274     <span class="comment">// 256 maximum), then multiple SG list setups will be needed, increasing</span>
00275     <span class="comment">// setup and xfer time.</span>
00276     <span class="comment">//--------------------------------------------------------------------</span>
00277     pImgBuf = (ULONG *)AllocAlignedBuffer(CB_IMAGE_FRAME_SIZE);
00278 
00279     <span class="keywordflow">if</span> (pImgBuf == NULL)
00280     {
00281         ERRORSTR(<span class="stringliteral">"ERROR! VirtualAlloc failed.  exiting\n"</span>);
00282         exit(-1);
00283     }
00284 
00285     LoopCnt = 0;
00286 
00287     <span class="comment">//--------------------------------------------------------------------</span>
00288     <span class="comment">// Get the environment variables needed to open the desired eval board.</span>
00289     <span class="comment">// These are setup by the scan utility program or defined at the command</span>
00290     <span class="comment">// line. Pre-load with defaults in case env vars are not found.</span>
00291     <span class="comment">//--------------------------------------------------------------------</span>
00292     strcpy(boardName, <span class="stringliteral">"ECP2M"</span>);
00293     strcpy(demoName, <span class="stringliteral">"DMA"</span>);
00294     <span class="keywordflow">if</span> (!GetPCIeEnvVars(boardName, demoName, boardNum))
00295         DEBUGSTR(<span class="stringliteral">"\nEnvVars not found.  Using defaults.\n"</span>);
00296 
00297     DEBUGPRINT((<span class="stringliteral">"boardName = %s"</span>, boardName));
00298     DEBUGPRINT((<span class="stringliteral">"  boardNum = %d"</span>, boardNum));
00299     DEBUGPRINT((<span class="stringliteral">"  demoName = %s\n"</span>, demoName));
00300 
00301 
00302 
00303     <span class="comment">//--------------------------------------------------------------------</span>
00304     <span class="comment">// Open the Lattice DMA driver to the board.</span>
00305     <span class="comment">// An exception will be thrown if any problems occur finding or </span>
00306     <span class="comment">// accessing the hardware.</span>
00307     <span class="comment">//--------------------------------------------------------------------</span>
00308     <span class="keywordflow">try</span>
00309     {
00310         DEBUGPRINT((<span class="stringliteral">"Opening LSCDMA_IF...ColorBars\n"</span>));
00311         pDrvr = <span class="keyword">new</span> LSCDMA_IF(boardName, 
00312                               <span class="stringliteral">"_CB"</span>,    <span class="comment">// function = ColorBars</span>
00313                               boardNum);
00314     }
00315     <span class="keywordflow">catch</span> (std::exception &amp;e)
00316     {
00317         ERRORSTR(<span class="stringliteral">"\nError opening driver: "</span>);
00318         ERRORSTR(e.what());
00319         ShowLastError();
00320         FreeAlignedBuffer(pImgBuf, CB_IMAGE_FRAME_SIZE);
00321         printf(<span class="stringliteral">"Error opening lscdma ColorBars driver.\n"</span>);
00322         exit(-1);
00323     }
00324 
00325 
00326     <span class="comment">//=========================================================</span>
00327     <span class="comment">// Verify access to the driver and resources.</span>
00328     <span class="comment">//=========================================================</span>
00329     <span class="keyword">const</span> DMAResourceInfo_t *pLinkInfo;
00330     <span class="keywordflow">if</span> (pDrvr-&gt;getDriverDMAInfo(&amp;pLinkInfo) == <span class="keyword">false</span>)
00331     {
00332         printf(<span class="stringliteral">"Error accessing driver.\n"</span>);
00333         exit(-1);
00334     }
00335 
00336 
00337 
00338 
00339     <span class="comment">//===============================================================</span>
00340     <span class="comment">// Verify the IP is accessable over the PCIe/Wishbone bus</span>
00341     <span class="comment">//===============================================================</span>
00342     regVal = pDrvr-&gt;read32(memGPIO(0x00));
00343     <span class="keywordflow">if</span> ((regVal &amp; 0xffff0000) != 0x12040000)
00344     {
00345         ERRORSTR(<span class="stringliteral">"\nError accessing GPIO ID register."</span>);
00346         FreeAlignedBuffer(pImgBuf, CB_IMAGE_FRAME_SIZE);
00347         printf(<span class="stringliteral">"Error accessing IP registers.\n"</span>);
00348         exit(-1);
00349     }
00350 
00351 
00352     <span class="comment">//===============================================================</span>
00353     <span class="comment">// Reset the ColorBar Pixel Data Generator</span>
00354     <span class="comment">//===============================================================</span>
00355     pDrvr-&gt;write32(memGPIO(0x30), 1);
00356     pDrvr-&gt;write32(memGPIO(0x30), 0);
00357 
00358 
00359     <span class="comment">//===============================================================</span>
00360     <span class="comment">// Create the OpenGL Window.</span>
00361     <span class="comment">//===============================================================</span>
00362     glutInit(&amp;argc, argv);
00363 
00364     <span class="comment">// Set display and drawing mode</span>
00365     glutInitDisplayMode(GLUT_RGBA | GLUT_DOUBLE | GLUT_DEPTH);
00366     glutInitWindowSize(Window_Width, Window_Height);
00367 
00368     <span class="comment">// Open a window </span>
00369     sprintf(title, <span class="stringliteral">"%s : %s   %d FPS"</span>, WindowTitle, ModeName[OpMode], ElpsCnt);
00370     Window_ID = glutCreateWindow(title);
00371 
00372     <span class="comment">// Register the callback function to do the drawing. </span>
00373     glutDisplayFunc(&amp;<a class="code" href="_color_bars_8cpp.html#a21">cbDraw</a>);
00374 
00375     <span class="comment">// If there's nothing to do, draw.</span>
00376     glutIdleFunc(&amp;<a class="code" href="_color_bars_8cpp.html#a21">cbDraw</a>);
00377 
00378     <span class="comment">// It's a good idea to know when our window's resized.</span>
00379     glutReshapeFunc(&amp;<a class="code" href="_color_bars_8cpp.html#a24">cbReshape</a>);
00380 
00381     <span class="comment">// And let's get some keyboard input.</span>
00382     glutKeyboardFunc(&amp;<a class="code" href="_color_bars_8cpp.html#a22">cbKeyPressed</a>);
00383     glutSpecialFunc(&amp;<a class="code" href="_color_bars_8cpp.html#a23">cbSpecialKeyPressed</a>);
00384 
00385     <span class="comment">// OpenGL's ready to go.  Call init function to setup colors and matrixes.</span>
00386     <a class="code" href="_image_move_8cpp.html#a19">setupDrawing</a>(Window_Width, Window_Height);
00387 
00388     <span class="comment">// Print out a bit of help dialog.</span>
00389     printf(<span class="stringliteral">"\n\n%s\n"</span>, WindowTitle);
00390     printf(<span class="stringliteral">"&lt;Esc&gt;|Q|X - terminates program and closes the window\n"</span>);
00391     printf(<span class="stringliteral">"&lt;F1&gt; - just draw blank image buffer (don't generate data) - fastest rate.\n"</span>);
00392     printf(<span class="stringliteral">"&lt;F2&gt; - generate color bar data via software, should be slowest data rate.\n"</span>);
00393     printf(<span class="stringliteral">"&lt;F3&gt; - get image data from eval board via DMA transfer.\n"</span>);
00394     printf(<span class="stringliteral">"&lt;F4&gt; - Draw a frame each second (slowly) so it can be viewed and the changes seen.\n"</span>);
00395     printf(<span class="stringliteral">"&lt;Space&gt; - pause/resume image transfer.\n"</span>);
00396     printf(<span class="stringliteral">"OpenGL window must have focus to accept input.\n"</span>);
00397 
00398     StartTime = clock();
00399 
00400     <span class="comment">// Pass off control to OpenGL.</span>
00401     <span class="comment">// OpenGL will invoke the callbacks when needed to Draw, process KeyPress, etc.</span>
00402     glutMainLoop();
00403 
00404 
00405     <span class="comment">// Never get here because glutMainLoop never returns.</span>
00406     <span class="keywordflow">return</span>(0);   
00407 }
00408 
00409 
00410 
<a name="l00418"></a><a class="code" href="_color_bars_8cpp.html#a20">00418</a> <span class="keywordtype">void</span>    <a class="code" href="_color_bars_8cpp.html#a20">cleanUpAndExit</a>(<span class="keywordtype">void</span>)
00419 {
00420     ENTER();    
00421     <span class="comment">//-----------------------------------------------------</span>
00422     <span class="comment">// Exiting and shutting down</span>
00423     <span class="comment">//-----------------------------------------------------</span>
00424 
00425     glutDestroyWindow(Window_ID);
00426 
00427 
00428     <span class="comment">/* Close all LSC_PCIe objects i.e. driver interface */</span>
00429     <span class="keyword">delete</span> pDrvr;
00430     FreeAlignedBuffer(pImgBuf, CB_IMAGE_FRAME_SIZE);
00431 
00432     LEAVE();    
00433 
00434         exit(0);
00435 }
00436 
<a name="l00442"></a><a class="code" href="_color_bars_8cpp.html#a21">00442</a> <span class="keywordtype">void</span> <a class="code" href="_color_bars_8cpp.html#a21">cbDraw</a>(<span class="keywordtype">void</span>)
00443 {
00444     <span class="keywordtype">char</span> buf[256];
00445     clock_t c1;
00446     <span class="keywordtype">double</span> elpstime;
00447 
00448     ULONG *pPixel;      
00449     ULONG i, j;
00450 
00451 
00452     <span class="comment">// Clear the color and depth buffers.</span>
00453     glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
00454 
00455 
00456     <span class="comment">// A B G R</span>
00457     <span class="comment">// PixelVal = 0xff000000;   // alpha on</span>
00458     <span class="comment">// PixelVal = 0x00ff0000;  // blue</span>
00459     <span class="comment">// PixelVal = 0x0000ff00;  // green</span>
00460     <span class="comment">// PixelVal = 0x000000ff;  // red</span>
00461 
00462     <span class="keywordflow">switch</span> (OpMode)
00463     {
00464         <span class="keywordflow">case</span> SOFTWARE_RATE:  <span class="comment">// create image to draw in software</span>
00465             <span class="comment">//------------------------------------------------------------</span>
00466             <span class="comment">// Manually load the image buffer to display the color bar</span>
00467             <span class="comment">// pattern.  This shows how long it takes brute-force software</span>
00468             <span class="comment">// to accomplish the task beign performed in hardware and DMA.</span>
00469             <span class="comment">//------------------------------------------------------------</span>
00470             <span class="keywordflow">for</span> (i = 0; i &lt; 512; i++)
00471             {
00472                 PixelVal = Color[(((i&gt;&gt;3) + LoopCnt) &amp; 0x3f)];
00473                 pPixel = pImgBuf + (i * 512);
00474                 <span class="keywordflow">for</span> (j = 0; j &lt; 512; j++)
00475                 {
00476                     *pPixel = PixelVal;
00477                     ++pPixel;
00478                 }
00479             }
00480             <span class="keywordflow">break</span>;
00481 
00482         <span class="keywordflow">case</span> DMA_RATE:  <span class="comment">// Get image data via DMA</span>
00483             <span class="comment">//------------------------------------------------------------</span>
00484             <span class="comment">// Issue a Windows Read system call that causes the driver to</span>
00485             <span class="comment">// setup the SGDMA IP to write (PCIe MWr TLPs) data read from</span>
00486             <span class="comment">// the ColorBar generator and store into the allocated buffer</span>
00487             <span class="comment">// for later display on the screen.</span>
00488             <span class="comment">//------------------------------------------------------------</span>
00489 <span class="preprocessor">#if 1</span>
00490 <span class="preprocessor"></span>            <span class="keywordflow">if</span> (pDrvr-&gt;ReadFromDevice(pImgBuf, CB_IMAGE_FRAME_SIZE) == <span class="keyword">false</span>)
00491             {
00492                 ERRORSTR(<span class="stringliteral">"DMA READ ERROR!\nExiting.\n"</span>);
00493                 exit(-1);
00494             }
00495 <span class="preprocessor">#endif</span>
00496 <span class="preprocessor"></span>            <span class="keywordflow">break</span>;
00497 
00498 
00499         <span class="keywordflow">case</span> BASE_RATE:  <span class="comment">// just update the image Window ASAP</span>
00500             <span class="comment">//------------------------------------------------------------</span>
00501             <span class="comment">// Do nothing (basically).</span>
00502             <span class="comment">// The first time we clear the image to all black, then do</span>
00503             <span class="comment">// nothing in subsequent draw times. This shows the fastest</span>
00504             <span class="comment">// draw time of the OpenGL library and graphics hardware.</span>
00505             <span class="comment">// this is the benchmark the DMA xfer is measured against.</span>
00506             <span class="comment">//------------------------------------------------------------</span>
00507             <span class="keywordflow">if</span> (LoopCnt == 0)
00508                 memset(pImgBuf, 0, CB_IMAGE_FRAME_SIZE);
00509             <span class="keywordflow">break</span>;
00510 
00511         <span class="keywordflow">case</span> PAUSE:  <span class="comment">// don't do any transfers or image displays</span>
00512             Sleep(10);
00513             <span class="keywordflow">break</span>;
00514 
00515 
00516     }
00517 
00518     ++LoopCnt;
00519     ++ElpsCnt;
00520 
00521     <span class="comment">// Option to Slow down the display rate so its easy to see each frame drawn</span>
00522     <span class="keywordflow">if</span> (WaitTime)
00523         Sleep(WaitTime);
00524 
00525     <span class="comment">//------------------------------------------------------------</span>
00526     <span class="comment">// Draw the image buffer to the screen.</span>
00527     <span class="comment">// Use OpenGL to transfer the 1MB pixel data to the image window.</span>
00528     <span class="comment">// Transfer and draw times are completely system dependent, based</span>
00529     <span class="comment">// on OpenGL library, graphics card hardware, motherboard design,</span>
00530     <span class="comment">// etc.</span>
00531     <span class="comment">//------------------------------------------------------------</span>
00532     <span class="keywordflow">if</span> (OpMode != PAUSE)
00533     {
00534         glDrawPixels(512, 512, GL_RGBA, GL_UNSIGNED_BYTE, pImgBuf);
00535 
00536         <span class="comment">// All done drawing.  Display it.</span>
00537         glutSwapBuffers();
00538     }
00539     <span class="keywordflow">else</span>
00540     {
00541         ElpsCnt = 0;  <span class="comment">// Paused so no frames per second</span>
00542     }
00543 
00544 
00545 
00546 
00547     <span class="comment">//------------------------------------------------------------</span>
00548     <span class="comment">// Time how many frames are drawn per second.</span>
00549     <span class="comment">// This is a relative benchmark for DMA performance when compared</span>
00550     <span class="comment">// to software or baseline</span>
00551     <span class="comment">//------------------------------------------------------------</span>
00552     c1 = clock();
00553     elpstime = (double)(c1 - StartTime)/(CLOCKS_PER_SEC );
00554 
00555     <span class="keywordflow">if</span> (WaitTime)
00556         elpstime = 1.1f;   <span class="comment">// problem is that sleeping kills the process time keeper</span>
00557 
00558     <span class="keywordflow">if</span> (elpstime &gt;= 1.0)
00559     {
00560         sprintf(buf, <span class="stringliteral">"%s : %s   %d FPS"</span>, WindowTitle, ModeName[OpMode], ElpsCnt);
00561         glutSetWindowTitle(buf);
00562         ElpsCnt = 0;
00563         StartTime = c1;
00564     }
00565 
00566 
00567 }
00568 
00569 
00570 
<a name="l00576"></a><a class="code" href="_color_bars_8cpp.html#a22">00576</a> <span class="keywordtype">void</span> <a class="code" href="_image_move_8cpp.html#a16">cbKeyPressed</a>( <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> key, <span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y)
00577 {
00578     <span class="keywordtype">char</span> buf[256];
00579 
00580     <span class="keywordflow">switch</span> (key) 
00581     {
00582             <span class="keywordflow">case</span> <span class="charliteral">'X'</span>: 
00583             <span class="keywordflow">case</span> <span class="charliteral">'x'</span>: 
00584             <span class="keywordflow">case</span> <span class="charliteral">'Q'</span>: 
00585         <span class="keywordflow">case</span> <span class="charliteral">'q'</span>: 
00586         <span class="keywordflow">case</span> 27: <span class="comment">// Escape</span>
00587             <a class="code" href="_color_bars_8cpp.html#a20">cleanUpAndExit</a>();
00588                 <span class="keywordflow">break</span>; <span class="comment">// exit doesn't return, but anyway...</span>
00589 
00590 
00591         <span class="keywordflow">case</span> <span class="charliteral">' '</span>:  <span class="comment">// SPACE</span>
00592             <span class="keywordflow">if</span> (OpMode == PAUSE)
00593             {
00594                 OpMode = PrevMode;
00595                 LoopCnt = 0;
00596                 StartTime = clock();
00597             }
00598             <span class="keywordflow">else</span>
00599             {
00600                     PrevMode = OpMode;
00601                     OpMode = PAUSE;
00602                 StartTime = clock();
00603             }
00604             <span class="comment">// Return window to previous title</span>
00605             sprintf(buf, <span class="stringliteral">"%s : %s"</span>, WindowTitle, ModeName[OpMode]);
00606             glutSetWindowTitle(buf);
00607             <span class="keywordflow">break</span>;
00608 
00609         <span class="keywordflow">default</span>:
00610                 <span class="comment">//printf ("KP: No action for %d.\n", key);</span>
00611             <span class="keywordflow">break</span>;
00612     }
00613 }
00614 
00615 
00616 
<a name="l00622"></a><a class="code" href="_color_bars_8cpp.html#a23">00622</a> <span class="keywordtype">void</span> <a class="code" href="_image_move_8cpp.html#a17">cbSpecialKeyPressed</a>( <span class="keywordtype">int</span> key, <span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y)
00623 {
00624     <span class="keywordtype">char</span> buf[256];
00625 
00626     <span class="keywordflow">switch</span> (key) 
00627     {
00628 
00629         <span class="keywordflow">case</span> GLUT_KEY_F1:
00630             WaitTime = 0;
00631             OpMode = BASE_RATE;
00632             LoopCnt = 0;
00633             <span class="keywordflow">break</span>;
00634 
00635         <span class="keywordflow">case</span> GLUT_KEY_F2:
00636             WaitTime = 0;
00637             OpMode = SOFTWARE_RATE;
00638             LoopCnt = 0;
00639             <span class="keywordflow">break</span>;
00640 
00641         <span class="keywordflow">case</span> GLUT_KEY_F3:
00642             WaitTime = 0;
00643             OpMode = DMA_RATE;
00644             LoopCnt = 0;
00645             <span class="keywordflow">break</span>;
00646 
00647         <span class="keywordflow">case</span> GLUT_KEY_F4:
00648             WaitTime = 1001;
00649             <span class="keywordflow">break</span>;
00650 
00651         <span class="keywordflow">default</span>:
00652                 <span class="comment">//printf ("SKP: No action for %d.\n", key);</span>
00653             <span class="keywordflow">break</span>;
00654     }
00655 
00656     sprintf(buf, <span class="stringliteral">"%s : %s"</span>, WindowTitle, ModeName[OpMode]);
00657     glutSetWindowTitle(buf);
00658 }
00659 
00660 
<a name="l00666"></a><a class="code" href="_color_bars_8cpp.html#a24">00666</a> <span class="keywordtype">void</span> <a class="code" href="_image_move_8cpp.html#a18">cbReshape</a>( <span class="keywordtype">int</span> Width, <span class="keywordtype">int</span> Height)
00667 {
00668     <span class="comment">// Make sure denominator is never 0</span>
00669     <span class="keywordflow">if</span> (Height == 0)
00670         Height = 1;
00671 
00672     glViewport(0, 0, Width, Height);
00673 
00674     glMatrixMode(GL_PROJECTION);
00675     glLoadIdentity();
00676     gluPerspective(45.0f,(GLfloat)Width/(GLfloat)Height,0.1f,100.0f);
00677 
00678     glMatrixMode(GL_MODELVIEW);
00679 
00680     Window_Width  = Width;
00681     Window_Height = Height;
00682 }
00683 
00684 
<a name="l00689"></a><a class="code" href="_color_bars_8cpp.html#a25">00689</a> <span class="keywordtype">void</span> <a class="code" href="_image_move_8cpp.html#a19">setupDrawing</a>(<span class="keywordtype">int</span> Width, <span class="keywordtype">int</span> Height) 
00690 {
00691 
00692     <span class="comment">// Color to clear color buffer to.</span>
00693     glClearColor(0.1f, 0.1f, 0.1f, 0.0f);
00694 
00695     <span class="comment">// Depth to clear depth buffer to; type of test.</span>
00696     glClearDepth(1.0);
00697     glDepthFunc(GL_LESS); 
00698 
00699     <span class="comment">// Enables Smooth Color Shading; try GL_FLAT for (lack of) fun.</span>
00700     glShadeModel(GL_SMOOTH);
00701 
00702     <span class="comment">// Load up the correct perspective matrix; using a callback directly.</span>
00703     <a class="code" href="_image_move_8cpp.html#a18">cbReshape</a>(Width, Height);
00704 }
00705 
00706 
00707 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Jul 16 12:05:28 2008 for Lattice PCIe DMA Demos by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
