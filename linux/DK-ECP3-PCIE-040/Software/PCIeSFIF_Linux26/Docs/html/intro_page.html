<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Lattice PCIe Thruput Demo: Introduction to the PCIe Basic Demo Operations</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<HTML>
<HEAD>
<TITLE>
Lattice PCIe IP Thruput Demo Help
</TITLE>

</HEAD>

<BODY BGCOLOR="white" >

<H1><u>Lattice PCIe IP Thruput Demo</u></H1>

<H1>Introduction</H1>
The demo runs on a standard PC, and accesses the Lattice PCIe evaluation board installed in a PCIe slot.  The demo exercises the PCIe IP core's ability to transfer data to/from the PC system memory at maximum data rates.  The Demo uses special IP in the FPGA (Stored FIFO InterFace) to play out sequences of PCIe MRd and MWr data transfers.  The data rates for the trasnfers are computed from counters in the hardware and displayed in the GUI. The demo performs the following functions:

<ul>
    <li> Displays Operating System information on the detected Lattice evaluation board.
    <li> Displays information about the PCIe IP core, such as reading and displaying all the pertinent information in the configuration registers, capability structures and driver allocated resources.
    <li> Performs Memory Writes (MWr TLPs) into PC Common Buffer DMA memory and measures performance
    <li> Performs Memory Reads (MRd TLPs) from PC Common Buffer DMA memory and measures performance
    <li> Performs simultaneous Memory Reads and Writes (MRd/MWr TLPs) to/from PC Common Buffer DMA memory and measures performance
    <li> All of the above and blinks the LEDs to show control-plane path is functional during memory transfers
</ul>


<h2>Supported Boards</h2>
<ul>
    <li> LatticeECP2M PCIe Solutions Board
    <li> LatticeSCM80 x4 PCI Express Board
    <li> LatticeECP2M50 x4 PCI Express Board
</ul>


<H1>Setup</H1>
Consult the appropriate Demo Installation Guides and Evaluation Board User's Guides to ensure the proper bitstream
is loaded into the SPI flash, the board is installed correctly, is functioning correctly, the proper driver has
been loaded and the demo application has be installed.



<H1>Demo Operations</H1>

<H2>Device Info Page</H2>
The opening page, <B>Device Info</B>, displays information about the device driver and the device's PCI configuration registers.
<p>
The data displayed is for informational purposes and can not be edited.  This information is obtained once by the Lattice PCIe driver when the Operating System detects the board and loads the driver.  Displaying this page does not cause the driver to issue PCI Config Type 0 read requests.
<p>
Of interest are the Root Complex's initial credits (bottom of Xfer Info) and PC Common DMA Buffer size and address.  The PCIe link capabilities are displayed in the Capabilites Registers tab.  The link negotiated width, speed, Max Read Size, Max TLP Size and RCB size are displayed.


<H2>Tests Page</H2>
This page operates the demo design.  This page has four parts:
<ol>
<li>Setup - Sets the configuration for the specific test
<li>Controls - Start and Stops the test
<li>Performance - Displays the current data rates and other statistics
<li>Report - Logs all of the test information
</ol>

<H3>Test Mode</H3>
<P>There are two modes of operation: <b>Cycles</b> and <b>Throughput</b>.  
</P>
<OL>
<LI><P STYLE="margin-bottom: 0in"><b>Throughput</b> - This mode
	allows the test to run continuously, looping through the tx_fifo and
	updating the performance numbers every second.  This test will run
	until the user presses the STOP button.</P>
	<LI><P STYLE="margin-bottom: 0in"><b>Cycles</b> - This mode allows
	the user to setup a specific number of times the tx_fifo will be
	looped.  Once complete, the test will stop automatically and the
	performance numbers will be displayed based on the entire run.  Note: the maximum duration of the cycles test is 1 second.
</OL>
<P STYLE="margin-bottom: 0in"><BR>
</P>
<P STYLE="margin-bottom: 0in">
The key difference between the two modes is how the performance data is displayed. A throughput test will provide
new performance data every second. A cycle test will provide performance data after the number of cycles
completes, or one second, whichever comes first. Note that cycles will not run longer than one second. Cycles
tests run once; throughput tests run continuously until stopped.
<P STYLE="margin-bottom: 0in"><BR>
</P>
<H3 CLASS="western" STYLE="margin-left: 0in">TLP Types</H3>
<P STYLE="margin-bottom: 0in">There are 4 types of TLP types which
impact the type of traffic sent over the PCIe link.</P>
<OL>
<LI><P STYLE="margin-bottom: 0in"><b>MWr</b> - Memory Write TLPs to
	write data from the endpoint to the PC system memory.</P>
	<LI><P STYLE="margin-bottom: 0in"><b>MRd</b> - Memory Read TLPs to
	read data from PC system memory to the endpoint.</P>
	<LI><P STYLE="margin-bottom: 0in"><b>MRd+MWr</b> - Both Memory Read
	and Memory Write TLPs are sent to the root complex.</P>
	<LI><P STYLE="margin-bottom: 0in"><b>R+W+Ctl</b> - Read, Write, and
	Control data are present on the PCIe link.  The Read and Write TLPs
	are sent from the SFIF while the PC is also modifying the GPIO
	16-segment display LEDs.  This TLP type shows both data and control
	plane TLPs sharing the PCIe link.</P>
</OL>
<P><BR>
</P>
<H3>TLP Size</H3>
<P><FONT SIZE=3>
The TLP size controls allows the user to select the size of the TLPs to be sent from the SFIF. The maximum
size of the TLP will be dependent on the root complex. In MRd mode, the TLP size is limited by the Max.
Read Request size (512 bytes). In MWr mode, the max TLP size is limited by Max. TLP Size (128 bytes). In
Read/Write mode the following sizes are available for MRd TLP and MWr TLP combinations.
</FONT>
</P>
<OL>
<LI><P STYLE="margin-bottom: 0in"><FONT SIZE=3><b>512/128</b> - 512
	byte Read requests with 128 byte Write TLPs</FONT></P>
	<LI><P STYLE="margin-bottom: 0in"><FONT SIZE=3><b>256/128</b> - 256
	byte Read requests with 128 byte Write TLPs</FONT></P>
	<LI><P STYLE="margin-bottom: 0in"><FONT SIZE=3><b>128/128</b> - 128
	byte Read requests with 128 byte Write TLPs</FONT></P>
	<LI><P STYLE="margin-bottom: 0in"><FONT SIZE=3><b>64/64</b> - 64 byte
	Read requests with 64 byte Write TLPs</FONT></P>
	<LI><P STYLE="margin-bottom: 0in"><FONT SIZE=3><b>32/32</b> - 32 byte
	Read requests with 32 byte Write TLPs</FONT></P>
	<LI><P STYLE="margin-bottom: 0in"><FONT SIZE=3><b>16/16</b> - 16 byte
	Read requests with 16 byte Write TLPs</FONT></P>
</OL>
<P STYLE="margin-bottom: 0in"><BR>
</P>
<H3>Num TLPs</H3>
<P>This control allows the user to select
the ratio of Read requests to Write TLPs.  
</P>
<OL>
<LI><P STYLE="margin-bottom: 0in"><b>1Rd,1Wr</b> -  This ratio results in
	1 Read Request and 1 Write TLPs back to back.  The completion data
	will need to be received before another Read Request can be made.</P>
	<LI><P STYLE="margin-bottom: 0in"><b>1Rd,4Wr</b> - This ratio
	results in 1 Read Request and 4 Write TLPs.  The completion data
	will need to be received before another Read Request can be made. 
	This results in much greater bandwidth since read requests are 4
	times the size of a write TLP.  This ratio balances the PCIe link,
	but still waits for read data.</P>
	<LI><P STYLE="margin-bottom: 0in"><b>4Rd,16Wr</b> - This ratio
	results in 4 Read Requests and 16 Write TLPs.  This ratio allows for
	4 read requests to be outstanding (TAGs).  This ratio is only
	recommended on server class motherboards due to the high bandwidth
	required.  With 4 reads outstanding the root complex can better
	utilize the read data.</P>
	<LI><P STYLE="margin-bottom: 0in"><b>16Rd,64Wr</b> - This ratio results
	in 16 Read Requests and 64 Write TLPs.  This ratio allows for 16
	read requests to be outstanding (TAGs).  This ratio is only
	recommended on server class motherboards due to the high bandwidth
	required.  With 16 read outstanding the root complex can better
	utilize the read data.</P>
</OL>
<P><BR>
</P>
<H3>Cycles</H3>
<P>
This control is only available when the Cycle mode has been selected. This controls the number of times
the tx_fifo is looped before ending the test. The software starts the SFIF and waits one second while the SFIF
transfers data (number of cycles). After one second, the software stops the SFIF and displays the performance.
This has the effect of limiting cycles tests to a maximum of one second of operation. The cycles value cannot be
larger than 65535 (it is a 16-bit counter).
</P>
<P><BR>
</P>
<P>In Throughput mode this control is not
used.  In Throughput mode the SFIF is looping the tx_fifo
continuously until the user presses the STOP button.</P>
<P><BR>
</P>
<H3>ICG (Inter Cycle Gap)</H3>
<P>
This control sets the number of 125MHz clock cycles between cycles. This control allows
for modeling TLP traffic patterns that may be appropriate for a user’s system. The ICG value cannot be larger
than 65535 (it is a 16-bit counter).

<P><BR>
</P>
<P><BR>
</P>
<H3>Performance</H3>
<P>Data rates are displayed as progress
bars, with the rate (MB/sec) displayed in the bar.  The bars are
updated every second when running in the Throughput mode or upon
completion in the Cycles mode.  The rates are computed from the
hardware counters in the SFIF.  
</P>
<P><BR>
</P>
<P>Write rates are computed from the
following SFIF hardware counters:  Tx TLP Count and Elapsed Count.</P>
<P><BR>
</P>
<P>Write Rate (MB/sec) = (Tx TLP Count *
TLP Size) / (Elapsed Count * 8ns)</P>
<P><BR>
</P>
<P>Read rates are computed from the
following SFIF hardware counters: Rx TLP Count and CplD Timestamp.</P>
<P><BR>
</P>
<P>Read Rate (MB/sec) = (Rx TLP Count *
RCB_Size) / (Elapsed Count * 8ns)</P>
<P><BR>
</P>
<P>RCB_Size is the size in bytes of a
CplD.</P>
<P><BR>
</P>
<P>In Throughput mode the performance is
recalculated every second and the counters are reset.  In Cycles mode
the performance is calculated once at the end of the run displaying
the results for the entire transfer.</P>
<P><BR>
</P>
<H3>NP_CA and P_CA</H3>
<P>Time spent waiting for the root complex
to accept TLPs is computed and displayed as a bar graph in percentage
of time waiting over time spent running.  Normal efficient operation
should show a small percentage of time spent waiting for credits and
more time spent sending TLPs.  
</P>
<P><BR>
</P>
<P>Counters record when the SFIF wants to
send a MRd but the credit available ports of the PCIe core indicates
the root complex has not yet processed the read requests.  The PCIe
core is waiting to accept an UpdateFC-NP freeing up Non-Posted
credits to send another MRd TLP.  
</P>
<P><BR>
</P>
<P>Counters record when the SFIF wants to
send a MWr but the credit available ports of the PCIe core indicates
the root complex has not yet processed the previously sent write TLPs.  The PCIe
core is waiting to accept an UpdateFC-P freeing up Posted credits to
send another MWr TLP.</P>
<P><BR>
</P>
<H3>Report</H3>
<P>The Report box provides details about
the test.  In the Throughput mode this report will be updated every
second up to 10 seconds.  After 10 seconds the data is no longer
updated in the report box to prevent system load and excessive
resource usage during long duration tests (over night).  In the
Cycles mode the report window is updated when the test is complete.</P>

<H2>View Memory Section</H2>
This tab allows you to inspect the contents of the PC Common DMA Buffer memory or the SFIF Rx FIFO contents.  The PC Common Buffer is loaded with a pattern that is read by the Eval Board during MRd tests, and is the destination for writes during MWr tests.  The PC Buffer contents can be cleared to all 0's to verify that the Eval Board does write into it during the next MWr test.
<p>
The SFIF RX FIFO contents is valid only after a test that contains MRD requests.  The FIFO will then contain CplD data. If the total transfered size of the test is less than 16kB (including TLP headers and timestamps) then the contents are parsed on a TLP basis and compared with the source pattern in the PC Common Buffer.
<p>
If the MRd length is greater than the 16kB FIFO, then the raw data contents are displayed.  The Rx FIFO contains a series of timestamp words, the TLP header and the CplD payload.


<H1>IP Design Details</H1>

<H2>SFIF IP Overview</H2>
<P>The following block diagram shows a high level view
of the IP blocks within the Lattice FPGA.</P>
<P><IMG SRC="SFIF_IP_html_7ea814a4.gif" NAME="Object1" ALIGN=BOTTOM WIDTH=624 HEIGHT=664></P>
<P><BR><BR>
</P>
<P><BR><BR>
</P>
<P><BR><BR>
</P>
<P><BR><BR>
</P>
<P STYLE="margin-left: 0.4in"><BR><BR>
</P>
<P STYLE="margin-bottom: 0in">The SFIF IP design allows the user to
use the PCIe link as both the control plane and data plane.  For the
control plane 1DW Memory Requests can be made through the Completer
block.  This block converts PCIe TLP Memory Requests into Wishbone
bus cycles.  Both BAR0 and BAR1 are mapped to the same address space
as defined below.</P>
<P><BR><BR>
</P>
<CENTER>
	<TABLE WIDTH=582 BORDER=1 CELLPADDING=2 CELLSPACING=0>
		<COL WIDTH=102>
		<COL WIDTH=470>
		<TR>
			<TD WIDTH=102 VALIGN=TOP>
			<P><B>BAR0/1</B>
				</P>
			</TD>
			<TD WIDTH=470>
				<P><B>Wishbone Bus</B></P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=102>
				<P><B>Address (Hex)</B></P>
			</TD>
			<TD WIDTH=470>
				<P><B>Device Description</B></P>
			</TD>
		</TR>
		<TR>
			<TD WIDTH=102>
				<P>0x00000000</P>
			</TD>
			<TD WIDTH=470>
				<P>GPIO 
				</P>
			</TD>
		</TR>
		<TR>
			<TD WIDTH=102>
				<P>0x00010000</P>
			</TD>
			<TD WIDTH=470>
				<P>SFIF</P>
			</TD>
		</TR>
		<TR>
			<TD WIDTH=102>
				<P>0x00040000</P>
			</TD>
			<TD WIDTH=470 VALIGN=TOP>
				<P>EBR</P>
			</TD>
		</TR>
	</TABLE>
</CENTER>
<P STYLE="margin-bottom: 0in"><BR>
</P>
<P STYLE="margin-bottom: 0in"><BR>
</P>
<P STYLE="margin-bottom: 0in">Using the Completer block the user can
load the SFIF and exercise the data plane. 
</P>
<P STYLE="margin-bottom: 0in"><BR>
</P>
<P STYLE="margin-bottom: 0in">The SFIF details are shown in the
following figure.</P>
<P STYLE="margin-bottom: 0in"><BR>
</P>
<P ALIGN=CENTER STYLE="margin-bottom: 0in"><IMG SRC="SFIF_IP_html_10dba54.gif" NAME="Object2" ALIGN=BOTTOM WIDTH=400 HEIGHT=490></P>
<P STYLE="margin-bottom: 0in"><BR>
</P>
<P STYLE="margin-bottom: 0in"><BR>
</P>
<P STYLE="margin-bottom: 0in">The SFIF is made up of the following
blocks.</P>
<P STYLE="margin-bottom: 0in"><BR>
</P>
<P STYLE="margin-bottom: 0in"><b>Wbs</b> - This module is responsible
for transactions on the wishbone bus.  
</P>
<P STYLE="margin-bottom: 0in"><b>Tx_fifo</b> - This module stores up
to 16KBs of TLPs loaded from the WBs to send over the PCIe link</P>
<P STYLE="margin-bottom: 0in"><b>Rx_fifo</b> - This module stores
completions from the PC memory from read requests. It is 16kB deep.</P>
<P STYLE="margin-bottom: 0in"><b>Ctrl</b> - This module includes a
state machine to perform all of the SFIF features such as looping
through the tx_fifo and providing an inter TLP gap (IPG).</P>
<P STYLE="margin-bottom: 0in"><b>Ca</b> - This module is responsible
for checking if credits are available to send the current TLP.</P>
<P STYLE="margin-bottom: 0in"><b>Ta</b> - This module is responsible
for checking if the tag is available for the next read request.</P>
<P STYLE="margin-bottom: 0in"><b>Cr</b>  - This module is responsible for
freeing CPL credits once completions are received.</P>
<P STYLE="margin-bottom: 0in"><BR>
</P>
<P STYLE="margin-bottom: 0in">The SFIF works by loading TLPs into the
tx_fifo via the wishbone bus.  Once the TLPs are loaded into the
tx_fifo the user can determine how many times to iterate through the
tx_fifo (cycles) and how much gap to provide between the loops (IPG).
 The user then runs the SFIF and plays out the tx_fifo over the PCIe
link.  The SFIF transmitter will honor the credits available reported
by the PCIe core.  It will also make sure not to use an outstanding
request's TAG value on a read request.  
</P>
<P STYLE="margin-bottom: 0in"><BR>
</P>
<P STYLE="margin-bottom: 0in">The rx_fifo will monitor the receive
bus of the PCIe link waiting for completion TLPs with data.  These
TLPs will be stored in the rx_fifo.  As TLPs are stored in the FIFO,
CPL credits are released to the system allowing the system to send
more completions.  Each CPLD TLP is stored along with a timestamp to
mark the latency of read operations.</P>
<P STYLE="margin-bottom: 0in"><BR>
</P>
<P STYLE="margin-bottom: 0in">As shown, the SFIF configuration
registers are accessed at base address 0x1000 on the Wishbone Bus. 
The GUI software will address the registers in this range to setup
the configuration registers, load the SFIF tx_fifo, and read the SFIF
rx_fifo.</P>
<P STYLE="margin-bottom: 0in"><BR>
</P>
<P STYLE="margin-bottom: 0in">The register map for the SFIF is:</P>
<P STYLE="margin-bottom: 0in"><BR>
</P>
<P STYLE="margin-bottom: 0in"><BR>
</P>
<TABLE WIDTH=625 BORDER=1 CELLPADDING=2 CELLSPACING=0>
	<COL WIDTH=121>
	<COL WIDTH=77>
	<COL WIDTH=90>
	<COL WIDTH=55>
	<COL WIDTH=259>
	<TR VALIGN=TOP>
		<TD WIDTH=121>
			<P><B>Name</B></P>
		</TD>
		<TD WIDTH=77>
			<P><B>Addr (hex)</B></P>
		</TD>
		<TD WIDTH=90>
			<P><B>Width</B></P>
		</TD>
		<TD WIDTH=55>
			<P><B>Access</B></P>
		</TD>
		<TD WIDTH=259>
			<P><B>Description</B></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=121>
			<P>Control</P>
		</TD>
		<TD WIDTH=77>
			<P>0</P>
		</TD>
		<TD WIDTH=90>
			<P>32</P>
		</TD>
		<TD WIDTH=55>
			<P>RW</P>
		</TD>
		<TD WIDTH=259>
			<P>Controls operation of SFIF</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=121>
			<P>Tx TLP Control</P>
		</TD>
		<TD WIDTH=77>
			<P>4</P>
		</TD>
		<TD WIDTH=90>
			<P>32</P>
		</TD>
		<TD WIDTH=55>
			<P>W</P>
		</TD>
		<TD WIDTH=259>
			<P>Tx TLP control of loading TLP into FIFO</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=121>
			<P>Tx IPG Control</P>
		</TD>
		<TD WIDTH=77>
			<P>8</P>
		</TD>
		<TD WIDTH=90>
			<P>16</P>
		</TD>
		<TD WIDTH=55>
			<P>RW</P>
		</TD>
		<TD WIDTH=259>
			<P>Tx Inter TLP Gap control</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=121>
			<P>Tx TLP Data</P>
		</TD>
		<TD WIDTH=77>
			<P>c</P>
		</TD>
		<TD WIDTH=90>
			<P>32</P>
		</TD>
		<TD WIDTH=55>
			<P>W</P>
		</TD>
		<TD WIDTH=259>
			<P>DW of TLP data</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=121>
			<P>Rx TLP Data</P>
		</TD>
		<TD WIDTH=77>
			<P>10</P>
		</TD>
		<TD WIDTH=90>
			<P>32</P>
		</TD>
		<TD WIDTH=55>
			<P>R</P>
		</TD>
		<TD WIDTH=259>
			<P>DW of Completion TLP data</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=121>
			<P>Elapsed Count</P>
		</TD>
		<TD WIDTH=77>
			<P>14</P>
		</TD>
		<TD WIDTH=90>
			<P>32</P>
		</TD>
		<TD WIDTH=55>
			<P>R</P>
		</TD>
		<TD WIDTH=259>
			<P>Number of clock cycles in current run</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=121>
			<P>Tx TLP Count</P>
		</TD>
		<TD WIDTH=77>
			<P>18</P>
		</TD>
		<TD WIDTH=90>
			<P>32</P>
		</TD>
		<TD WIDTH=55>
			<P>R</P>
		</TD>
		<TD WIDTH=259>
			<P>Number of Tx TLPs sent in current run</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=121>
			<P>Rx TLP Count</P>
		</TD>
		<TD WIDTH=77>
			<P>1c</P>
		</TD>
		<TD WIDTH=90>
			<P>32</P>
		</TD>
		<TD WIDTH=55>
			<P>R</P>
		</TD>
		<TD WIDTH=259>
			<P>Number of CplDs received in current run</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=121>
			<P>Credit Wait P</P>
		</TD>
		<TD WIDTH=77>
			<P>20</P>
		</TD>
		<TD WIDTH=90>
			<P>32</P>
		</TD>
		<TD WIDTH=55>
			<P>R</P>
		</TD>
		<TD WIDTH=259>
			<P>Number of clock cycles waiting for Posted Credits in current
			run 
			</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=121>
			<P>CplD Timestamp</P>
		</TD>
		<TD WIDTH=77>
			<P>24</P>
		</TD>
		<TD WIDTH=90>
			<P>32</P>
		</TD>
		<TD WIDTH=55>
			<P>R</P>
		</TD>
		<TD WIDTH=259>
			<P>Timestamp for last CplD</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=121>
			<P>Credit Wait NP</P>
		</TD>
		<TD WIDTH=77>
			<P>28</P>
		</TD>
		<TD WIDTH=90>
			<P>32</P>
		</TD>
		<TD WIDTH=55>
			<P>R</P>
		</TD>
		<TD WIDTH=259>
			<P>Number of clocks cycles waiting for Non-Posted Credits or Tags
			in current run</P>
		</TD>
	</TR>
</TABLE>
<P STYLE="margin-bottom: 0in"><BR>
</P>
<P STYLE="margin-bottom: 0in"><BR>
</P>
<P STYLE="margin-bottom: 0in">The remaining IP in the demo design is
used as simple testing blocks and are not part of the demo.  The GPIO
block is used to read the DIP switches and control the 16-segment
LEDs.  It also has the ability to generate an interrupt via the PCIe
core.  The 32K EBR is again simply used for testing data movement via
the completor block and is not part of the demo.</P>
<P STYLE="margin-left: 0.4in; margin-bottom: 0in"><BR>
</P>


<H2>GPIO Register Map</H2>
<CENTER>
	<TABLE WIDTH=586 BORDER=1 BORDERCOLOR="#000000" CELLPADDING=7 CELLSPACING=0>
		<COL WIDTH=91>
		<COL WIDTH=93>
		<COL WIDTH=112>
		<COL WIDTH=100>
		<COL WIDTH=117>
		<TR>
			<TD WIDTH=91 VALIGN=TOP>
				<P><B>BAR1</B></P>
			</TD>
			<TD COLSPAN=4 WIDTH=464>
				<P ALIGN=CENTER><B>Location</B></P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=100>
				<P><B>Offset (Hex)</B></P>
			</TD>
			<TD WIDTH=100>
				<P><B>Byte 3 [31:24]</B></P>
			</TD>
			<TD WIDTH=100>
				<P><B>Byte 2 [23:16]</B></P>
			</TD>
			<TD WIDTH=100>
				<P><B>Byte 1[15:8]</B></P>
			</TD>
			<TD WIDTH=100>
				<P><B>Byte 0 [7:0]</B></P>
			</TD>
		</TR>
		<TR>
			<TD WIDTH=91>
				<P ALIGN=CENTER>0000</P>
			</TD>
			<TD COLSPAN=4 WIDTH=464>
				<P ALIGN=CENTER>ID Register</P>
			</TD>
		</TR>
		<TR>
			<TD WIDTH=91>
				<P ALIGN=CENTER>0004</P>
			</TD>
			<TD COLSPAN=4 WIDTH=464>
				<P ALIGN=CENTER>Scratch Pad Register</P>
			</TD>
		</TR>
		<TR>
			<TD WIDTH=91>
				<P ALIGN=CENTER>0008</P>
			</TD>
			<TD WIDTH=93>
				<P ALIGN=CENTER>DIP Switch</P>
			</TD>
			<TD WIDTH=112>
				<P ALIGN=CENTER>rsvd</P>
			</TD>
			<TD COLSPAN=2 WIDTH=231>
				<P ALIGN=CENTER STYLE="margin-bottom: 0in">16 Segment LED 
				</P>
				<P ALIGN=CENTER>upper 8 bits               lower 8 bits</P>
			</TD>
		</TR>
		<TR>
			<TD WIDTH=91>
				<P ALIGN=CENTER>000C</P>
			</TD>
			<TD WIDTH=93>
				<P ALIGN=CENTER>rsvd</P>
			</TD>
			<TD WIDTH=112>
				<P ALIGN=CENTER>rsvd</P>
			</TD>
			<TD WIDTH=100>
				<P ALIGN=CENTER>rsvd</P>
			</TD>
			<TD WIDTH=117>
				<P ALIGN=CENTER>Counter ctrl</P>
			</TD>
		</TR>
		<TR>
			<TD WIDTH=91>
				<P ALIGN=CENTER>0010</P>
			</TD>
			<TD COLSPAN=4 WIDTH=464>
				<P ALIGN=CENTER>Current Counter Value</P>
			</TD>
		</TR>
		<TR>
			<TD WIDTH=91>
				<P ALIGN=CENTER>0014</P>
			</TD>
			<TD COLSPAN=4 WIDTH=464>
				<P ALIGN=CENTER>Counter Reload Value</P>
			</TD>
		</TR>
	</TABLE>
</CENTER>

<p>
<ul>
    <li>Demo ID Register (0x00): 32 bit pre-programmed, read-only value: 0x12043010
    <li>Scratch Pad Register (0x04): 32 bit register that can be read or written with any user value to verify reads/writes.  Byte, short or long access is supported.
    <li>16 Segment LED Regsiter (0x08): 16 bit register, writing a 1 to a bit lights the LED segment, writing a 0 turns it off; LED segment A wired to lsb (d0) and segment U wired to msb (d15)
    <li> DIP Switch Register (0x0b): Read Only; Each bit indicates the position of a corresponding switch. 0=up, 1=down
</ul>



<H1>Trouble Shooting (Windows)</H1>
<H2>Trouble with the Board</H2>
Ensure the board is installed in a PCIe slot.  It can physically fit into a PCI slot.  This could damage the board or PC if power is applied when it's the wrong type of slot.  
<p>
Ensure the board has a valid PCIe SFIF bitstream loaded in the SPI flash and for ECP2M that the Mode DIP switches are set to program from SPI flash (does not apply to SC eval boards).
<p>
Ensure the 4 Status LEDs are on, indicating the board is seen as a PCIe endpoint.  If the 2 yellow LEDs and 2 green LEDs are not on, the board will not be recognized by the PC BIOS or Windows.  You can try installing in a different PCIe slot to see if that fixes the link-up problem.  You can also try pressing the Eval Board's reset button immediately after the PC boots.
<p>
Ensure the board is seen by Windows. Check <B>My Computer->Properties->Hardware->Device Manager</B> and verify the lscpcie2 driver and eval board are shown in the list.  If not, shutdown the system and try another slot.  If the board is present, check its <B>Properties</B> and the <B>Resource</B> tab to verify memory was assigned to it.  Also verify the <B>Vendor ID</B> and <B>Device ID</B> are valid, as seen by Windows Plug-n-Play.  If the values are invalid, perhaps the bitstream is not the SFIF demo or is corrupt and needs to be reloaded into SPI flash.

<H2>Trouble with the Driver</H2>
The eval board must be installed in the PC, and seen by Windows, for the driver to be installed.  If you do not see the <B>Found New Hardware</B> message when logging in after installing the board for the first time, check the board LEDs.  Try a different PCIe slot.
<p>
Make sure you specify the search location for the driver during installation.  Tell Windows to install from the <B>C:\Program Files\LatticeApps\Drivers</B> directory.
<p>
You may need administrator permission to install device driver files.

<H2>Trouble Running the Demo</H2>
The eval board must be installed in the PC, and seen by Windows, for the driver to be installed or loaded.  The driver must be loaded by Windows in order to run the demo.  Again verify Windows sees the board and has loaded a driver for it.  
<p>
If the GUI displays an error (<B>ERROR LOADING LIBRARY:Cpp_Jni - running in View Only mode</b>) when launched, then the driver could not be found or loaded.  There are 2 probable causes
<ol>
    <li>The driver was never loaded (or the eval board is not installed)
    <li>The board failed to be detected by Windows.
</ol>
Either way, the board needs to be re-installed and seen by Windows and the lscpcie2 driver needs to be associated with the hardware.

<H2>Windows Debug Tools</H2>
Windows offers some utilities to interrogate the operation of hardware devices.  Use these tools to verify the eval board device driver is loaded and running.
<p>
Right-click on the <B>My Computer</B> icon and select <B>Properties</B> to bring up <B>Device Manager</B>.  The <B>Device Manager</B> provides software driver information for devices detected by Windows Plug-n-Play manager.  The most useful utility is to verify that the <b>lscpcie2</b> driver has been installed and associated with the board.  Double click on the Lattice board icon to bring up the device and driver details tabs.

<H1>Trouble Shooting (Linux)</H1>

<H2>Trouble Installing</H2>
You will need root permission to install device driver files.
<p>
The Linux distribution needs to have the <b>udev</b> service running.
You may also need the kernel development package (just the header files, not the complete source package)
installed if you need to rebuild the drivers from their source.
<p>
If you get errors during install such as <b>FATAL: Error inserting lscpcie2...</b> then you will need to rebuild the
drivers to match your Linux kernel and distribution.  
This can be done by simply running <code><b>make drivers</b></code>.
If probelms are encountererd, see the documentation in the <b>lscpcie2</b> or <b>lscdma</b>
driver source for details on building from the source.
You may also need to rebuild the demo applications from the source if the Linux kernel and distribution 
varies greatly. Simply run <b><code>make demos</code></b>.

<H2>Trouble with the Board</H2>
Ensure the board is installed in a PCIe slot.  It can physically fit into a PCI slot.  This could damage the board or PC if power is applied when its the wrong type of slot.  
<p>
Ensure the board has a valid PCIe bitstream loaded in the SPI flash (and if applicable, that the Mode DIP switches are set to program from SPI flash).
<p>
Ensure the 4 Status LEDs are on, indicating the board is seen as a PCIe endpoint.  If the 2 yellow LEDs and 2 green LEDs are not on, the board will not be recognized by the PC BIOS or OS.  You can try installing in a different PCIe slot to see if that fixes the link-up problem.  You can also try pressing the Eval Board's reset button immediately after the PC boots.
<p>
The eval board must be installed in the PC, and seen by Linux for the demo (and driver) to operate properly.
Check that the board is seen with the command: <b><code>/sbin/lspci</code></b>
This will display all enumerated PCI and PCIe devices in the system.  Look for a Lattice board.
If the board is not listed (vendor ID = 0x1204) then try another PCIe slot.  Also verify the 4 PCIe link status LEDs
are all lit.
<p>
If the board is seen with <b>lspci</b>, then verify the 16 segment LED is displaying an "I", which means the driver has
initialized the board.  If the "I" is not displayed then see the next section.
<H2>Trouble with the Driver</H2>
If the board is seen by the PCI subsystem, but does not display an "I" when the driver is first loaded, the driver may
have errored, or not loaded at all.  To check the driver status use the following commands:

    <ul>
	<li><b><code>/sbin/lsmod</code></b> - The output should list either the <b>lscpcie2</b> or <b>lscdma</b> drivers are loaded.
	<li><b><code>dmesg</code></b> - This displays error and status messages from the driver during its load and operation.
	Normal builds will not have much debug info present, but error conditions and warnings will be logged.
	The log entry will be prefixed with <b>lscpcie2</b> or <b>lscdma</b>. 
	<li><b><code>/dev</code></b> - check for <b>lscpcie2</b> or <b>lscdma</b> device nodes in the /dev directory.  If they
	are not present (and the driver module is loaded) then the driver did not find any boards. Check for errors with dmesg.
	<li><b><code>/sys/class</code></b> - check for <b>lscpcie2</b> or <b>lscdma</b> class types in the directory.  If they
	are not present (and the driver module is loaded) then the driver did not find any boards. Check for errors with dmesg.
    </ul>
<p>
The driver directories under each demo contain script files to manually load and remove the driver for debugging.
Try running <b><code>insdrvr debug=1</code></b> to insert the driver and enable debugging.  Check the driver messages with
<b>dmesg</b>.  Use <b>rmdrvr</b> to remove the driver and try inserting again.
<p>
Remember, you will probably need to rebuild the driver to match your Linux kernel distribution. Do not expect the 
distributed driver binary to work on all Linux systems.
<p>
If you can not get the driver to load, please contact Lattice Support for further assistance.

<H2>Trouble Running the Demo</H2>
The eval board must be installed in a PCIe slot in the PC, and seen by Linux, for the driver to properly load.
The driver must be loaded by Linux in order to run the demo.  Again verify Linux sees the board and has loaded a driver for it.  
<p>
If the GUI displays an error (ERROR LOADING LIBRARY:Cpp_Jni - running in View Only mode) when launched, then the driver could not be found or loaded.  There are 3 causes
<ol>
    <li>The driver was never loaded (or eval board is not installed) - run <b>make install</b>
    <li>The board failed to be detected by Linux - verify the status LEDs
    <li>The driver errored during detection of the board - run <b>dmesg</b> for diagnostics
</ol>

<H2>Linux Debug Tools</H2>
The following is a list of command line tools that can be run to discover the status of drivers and devices in the system.
    <ul>
	<li><b><code>/sbin/lsmod</code></b> - The output will list drivers loaded in the system.
	<li><b><code>dmesg</code></b> - This displays error and status messages from the kernel and drivers.
	<li><b><code>cat /proc/devices | grep lsc</code></b> - checks for <b>lscpcie2</b> or <b>lscdma</b> devices detected
	<li><b><code>cat /proc/modules | grep lsc</code></b> - checks for <b>lscpcie2</b> or <b>lscdma</b> drivers installed
	<li><b><code>cat /proc/interrupts</code></b> - displays interrupt connectivity of driver/board when demo is running
	<li><b><code>cat /proc/driver/lscpcie2</code></b> - displays driver parameter information
	<li><b><code>cat /proc/driver/lscdma</code></b> - displays driver parameter information
    </ul>
    
</BODY>
</HTML>

 <hr size="1"><address style="align: right;"><small>Generated on Wed Jul 16 12:05:29 2008 for Lattice PCIe Thruput Demo by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
