<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Lattice PCIe Thruput Demo: Cpp_Jni.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<div class="nav">
<a class="el" href="dir_000000.html">SFIF_GUI</a>&nbsp;/&nbsp;<a class="el" href="dir_000001.html">Cpp_DLL</a></div>
<h1>Cpp_Jni.cpp</h1><a href="_cpp___jni_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*  COPYRIGHT (c) 2008 by Lattice Semiconductor Corporation</span>
00002 <span class="comment"> *</span>
00003 <span class="comment"> * All rights reserved. All use of this software and documentation is</span>
00004 <span class="comment"> * subject to the License Agreement located in the file LICENSE.</span>
00005 <span class="comment"> */</span>
00006 
00110 <span class="preprocessor">#include &lt;cstdlib&gt;</span>
00111 <span class="preprocessor">#include &lt;iostream&gt;</span>
00112 <span class="preprocessor">#include &lt;string&gt;</span>
00113 <span class="preprocessor">#include &lt;sstream&gt;</span>
00114 <span class="preprocessor">#include &lt;iomanip&gt;</span>
00115 <span class="preprocessor">#include &lt;iostream&gt;</span>
00116 <span class="preprocessor">#include &lt;exception&gt;</span>
00117 <span class="keyword">using</span> <span class="keyword">namespace </span>std;
00118 
00119 <span class="comment">// Auto-generated with Java utility javah</span>
00120 <span class="preprocessor">#include "com_latticesemi_lpa_apps_sfif_SFIF_UI.h"</span>
00121 
00122 <span class="preprocessor">#include "PCIeAPI.h"</span>         <span class="comment">// the APIs</span>
00123 <span class="preprocessor">#include "LSCPCIe2_IF.h"</span>     <span class="comment">// the driver interface</span>
00124 <span class="preprocessor">#include "GPIO.h"</span>            <span class="comment">// the GPIO IP module</span>
00125 <span class="preprocessor">#include "SFIF.h"</span>            <span class="comment">// the SFIF IP module</span>
00126 <span class="preprocessor">#include "MiscUtils.h"</span>
00127 <span class="preprocessor">#include "MemFormat.h"</span>
00128 <span class="preprocessor">#include "../../MemMap.h"</span>       <span class="comment">// IP module base addresses</span>
00129 <span class="preprocessor">#include "DebugPrint.h"</span>
00130 
00131 
00132 
00134 <span class="comment">// Required to use Lattice PCIe methods</span>
00136 <span class="comment"></span><span class="keyword">using</span> <span class="keyword">namespace </span>LatticeSemi_PCIe;
00137 
00138 
00139 
00140 <span class="comment">/*===== GLOBAL VARIABLES ========*/</span>
00141 
00142 LSCPCIe2_IF *pDrvr;
00143 SFIF        *pSFIF;
00144 GPIO        *pGPIO;
00145 
00146 uint32_t DmaBufAddr = 0;
00147 
00148 uint32_t WriteDmaBuf[FIFO_SIZE/4];
00149 uint32_t ReadDmaBuf[FIFO_SIZE/4];
00150 
00151 
00152 
00153 <span class="keywordtype">bool</span> SimHdw = <span class="keyword">false</span>;
00154 
00155 
00156 
00157 <span class="comment">/*================= SIMULATION USE ONLY ===============*/</span>
00158 <span class="preprocessor">#include "SimStrings.h"</span>
00159 
00160 
00161 <span class="keywordtype">int</span> Sim_runMode; 
00162 <span class="keywordtype">int</span> Sim_trafficMode; 
00163 <span class="keywordtype">int</span> Sim_cycles; 
00164 <span class="keywordtype">int</span> Sim_ICG; 
00165 <span class="keywordtype">int</span> Sim_rdTLPSize; 
00166 <span class="keywordtype">int</span> Sim_wrTLPSize; 
00167 <span class="keywordtype">int</span> Sim_numRdTLPs; 
00168 <span class="keywordtype">int</span> Sim_numWrTLPs;
00169 
00170 <span class="keywordtype">long</span> Sim_ElapseTime;
00171 <span class="keywordtype">long</span> Sim_TxTLPCntr;
00172 <span class="keywordtype">long</span> Sim_RxTLPCntr;
00173 <span class="keywordtype">long</span> Sim_WrWaitTime;
00174 <span class="keywordtype">long</span> Sim_LastCplDTime;
00175 <span class="keywordtype">long</span> Sim_RdWaitTime;
00176 
00177 
00178 <span class="keywordtype">bool</span>    Sim_SFIFisRunning = <span class="keyword">false</span>;
00179 
00180 <span class="comment">// Buffers Used in Simulation</span>
00181 uint32_t PC_DMA_Buf[16384/4];
00182 uint32_t SFIF_Rx_FIFO[16384/4];
00183 
00184 uint32_t PC_DMA_Buf_val = 0;
00185 
00186 
00187 
00188 <span class="comment">/*=========== FUNCTION PROTOTYPES =========*/</span>
00189 <span class="keywordtype">bool</span> Sim_stopSFIF();
00190 <span class="keywordtype">bool</span> Sim_startSFIF(uint32_t mode);
00191 <span class="keywordtype">int</span> <a class="code" href="_cpp___jni_8cpp.html#a29">Sim_getSFIFRegs</a>(<span class="keywordtype">long</span> <span class="keywordtype">long</span> *elements, <span class="keywordtype">int</span> len);
00192 <span class="keywordtype">bool</span> Sim_setupSFIF(<span class="keywordtype">int</span> runMode, 
00193                    <span class="keywordtype">int</span> trafficMode, 
00194                    <span class="keywordtype">int</span> cycles, 
00195                    <span class="keywordtype">int</span> ICG, 
00196                    <span class="keywordtype">int</span> rdTLPSize, 
00197                    <span class="keywordtype">int</span> wrTLPSize, 
00198                    <span class="keywordtype">int</span> numRdTLPs, 
00199                    <span class="keywordtype">int</span> numWrTLPs);
00200 
00201 <span class="keywordtype">void</span> Sim_getSFIFParseRxFIFO(string &amp;retStr);
00202 <span class="keywordtype">void</span> Sim_getPCSystemBuffer(string &amp;retStr);
00203 <span class="keywordtype">void</span> Sim_clrPCSystemBuffer(string &amp;retStr);
00204 
00205 <span class="keywordtype">bool</span> <a class="code" href="_cpp___jni_8cpp.html#a34">Sim_formatBlockOfWords</a>(string &amp;ostr, uint32_t startAddr, uint32_t len, uint32_t *data);
00206 
00207 <span class="keywordtype">int</span> Sim_PC_DMA_Buf_val = 0;
00208 
<a name="l00213"></a><a class="code" href="dllmain_8cpp.html#a0">00213</a> <span class="keywordtype">bool</span> <a class="code" href="_cpp___jni_8cpp.html#a35">createSFIFDemo</a>(<span class="keywordtype">void</span>)
00214 {
00215     <span class="keywordtype">char</span> boardName[LSC_PCIE_BOARD_NAME_LEN + 1];
00216     <span class="keywordtype">char</span> demoName[LSC_PCIE_DEMO_NAME_LEN + 1];
00217     uint32_t boardNum;
00218 
00219 
00220     ENTER();
00221 
00222     DEBUGSTR(<span class="stringliteral">"Creating the SFIF Demo\n"</span>);
00223     SimHdw = <span class="keyword">false</span>;
00224 
00225 
00226     DEBUGSTR(<span class="stringliteral">"Instantiate the PCIeAPI DLL class\n"</span>);
00227     PCIeAPI theDLL;
00228     DEBUGPRINT((<span class="stringliteral">"PCIeAPI_Lib version info: %s\n"</span>, theDLL.getVersionStr()));
00229 
00230 <span class="preprocessor">#ifndef RELEASE</span>
00231 <span class="preprocessor"></span>    <span class="comment">// Setup so lots of diag output occurs</span>
00232     PCIeAPI::setRunTimeCtrl(PCIeAPI::VERBOSE);
00233     
00234 <span class="preprocessor">#endif</span>
00235 <span class="preprocessor"></span>
00236     <span class="comment">// Get the environment variables needed to open the desired board</span>
00237     <span class="comment">// Pre-load with defaults</span>
00238     strcpy(boardName, <span class="stringliteral">"SIM"</span>);
00239     strcpy(demoName, <span class="stringliteral">"subsys_30301204"</span>);
00240     <span class="keywordflow">if</span> (!GetPCIeEnvVars(boardName, demoName, boardNum))
00241         cout&lt;&lt;<span class="stringliteral">"\nEnvVars not found.  Using defaults.\n"</span>;
00242 
00243     cout&lt;&lt;<span class="stringliteral">"boardName = "</span>&lt;&lt;boardName&lt;&lt;endl;
00244     cout&lt;&lt;<span class="stringliteral">"boardNum = "</span>&lt;&lt;boardNum&lt;&lt;endl;
00245     cout&lt;&lt;<span class="stringliteral">"demoName = "</span>&lt;&lt;demoName&lt;&lt;endl;
00246     
00247     <span class="keywordflow">try</span>
00248     {
00249 
00250         <span class="comment">// Find out what board the user expects to run on</span>
00251         <span class="keywordflow">if</span> (boardName == NULL)
00252             strcpy(boardName, <span class="stringliteral">"SIM"</span>);
00253 
00254         <span class="keywordflow">if</span> (strcmp(boardName, <span class="stringliteral">"SIM"</span>) == 0)
00255         {
00256             DEBUGSTR(<span class="stringliteral">"Using Simualtion Mode!  No Real Hardware Access!\n"</span>);
00257 
00258             pDrvr = NULL;
00259             pSFIF = NULL;
00260             pGPIO = NULL;
00261             SimHdw = <span class="keyword">true</span>;
00262         }
00263         <span class="keywordflow">else</span>
00264         {
00265             cout&lt;&lt;<span class="stringliteral">"Opening LSCPCIe2_IF...\n"</span>;
00266             pDrvr = <span class="keyword">new</span> LSCPCIe2_IF(boardName, 
00267                         demoName, 
00268                             boardNum);
00269 
00270             <span class="comment">// Create Device instances used in the demo</span>
00271             
00272             pGPIO = <span class="keyword">new</span> GPIO(<span class="stringliteral">"GPIO"</span>,         <span class="comment">// a unique name for the IP module instance</span>
00273                       memGPIO(0),    <span class="comment">// its base address</span>
00274                       pDrvr);        <span class="comment">// driver interface to use for register access</span>
00275             pSFIF = <span class="keyword">new</span> SFIF(<span class="stringliteral">"SFIF"</span>,         <span class="comment">// a unique name for the IP module instance</span>
00276                       memSFIF(0),    <span class="comment">// its base address</span>
00277                           pDrvr);        <span class="comment">// driver interface to use for register access</span>
00278 
00279         }
00280 
00281     }
00282     <span class="keywordflow">catch</span> (std::exception &amp;e)
00283     {
00284         DEBUGSTR(<span class="stringliteral">"RUNTIME ERROR!!!...\n"</span>);
00285         DEBUGSTRNL(e.what());
00286         <span class="keywordflow">return</span>(<span class="keyword">false</span>);
00287     }
00288     <span class="keywordflow">return</span>(<span class="keyword">true</span>);
00289 }
00290 
00291 
<a name="l00296"></a><a class="code" href="dllmain_8cpp.html#a1">00296</a> <span class="keywordtype">bool</span> <a class="code" href="_cpp___jni_8cpp.html#a36">deleteSFIFDemo</a>(<span class="keywordtype">void</span>)
00297 {
00298     ENTER();
00299 
00300     <span class="keywordflow">if</span> (!SimHdw)
00301     {
00302         <span class="keywordflow">if</span> (pDrvr &amp;&amp; pSFIF &amp;&amp; pGPIO)
00303         {
00304             <span class="comment">// Ensure the SFIF is totally stopped before exiting</span>
00305             pSFIF-&gt;disableSFIF();
00306 
00307             <span class="comment">// delete the device objects open to the device driver</span>
00308             <span class="keyword">delete</span> pSFIF;
00309             <span class="keyword">delete</span> pGPIO;
00310             <span class="keyword">delete</span> pDrvr;
00311 
00312             pSFIF = NULL;
00313             pGPIO = NULL;
00314             pDrvr = NULL;
00315         }
00316     }
00317     <span class="keywordflow">return</span>(<span class="keyword">true</span>);
00318 }
00319 
00320 
00321 <span class="comment">/*==========================================================================*/</span>
00322 <span class="comment">/*==========================================================================*/</span>
00323 <span class="comment">/*==========================================================================*/</span>
00324 <span class="comment">/*</span>
00325 <span class="comment"> *   IMPLEMENT THE JNI METHODS TO ACCESS AND CONTROL THE FPGA VIA API CLASS</span>
00326 <span class="comment"> *</span>
00327 <span class="comment"> *   NOTE: Function signatures are created by JNI!  Must follow proper</span>
00328 <span class="comment"> *   Java JNI protocol for variable usage and passing.</span>
00329 <span class="comment"> */</span>
00330 <span class="comment">/*==========================================================================*/</span>
00331 <span class="comment">/*==========================================================================*/</span>
00332 <span class="comment">/*==========================================================================*/</span>
00333 <span class="comment">/*</span>
00334 <span class="comment"> * Class:     com_latticesemi_lpa_apps_sfif_SFIF_UI</span>
00335 <span class="comment"> * Method:    CPP_getVersionStr</span>
00336 <span class="comment"> * Signature: ()Ljava/lang/String;</span>
00337 <span class="comment"> */</span>
00338 JNIEXPORT jstring JNICALL Java_com_latticesemi_lpa_apps_sfif_SFIF_1UI_CPP_1getVersionStr(JNIEnv *env, jobject obj)
00339 {
00340     string retStr;
00341 
00342     ENTER();
00343 
00344     <span class="keywordflow">if</span> (SimHdw)
00345     {
00346         <span class="keywordflow">return</span>(env-&gt;NewStringUTF(Sim_DriverVersionStr));         
00347     }
00348     <span class="keywordflow">else</span>
00349     {
00350         pDrvr-&gt;getDriverVersionStr(retStr);
00351 
00352         <span class="keywordflow">return</span>(env-&gt;NewStringUTF(retStr.c_str()));         
00353     }
00354 }
00355 
00356 
00357 
00358 <span class="comment">/*</span>
00359 <span class="comment"> * Class:     com_latticesemi_lpa_apps_sfif_SFIF_UI</span>
00360 <span class="comment"> * Method:    CPP_getDrvrResourceStr</span>
00361 <span class="comment"> * Signature: ()Ljava/lang/String;</span>
00362 <span class="comment"> */</span>
00363 JNIEXPORT jstring JNICALL Java_com_latticesemi_lpa_apps_sfif_SFIF_1UI_CPP_1getDrvrResourceStr(JNIEnv *env, jobject obj)
00364 {
00365     string retStr;
00366 
00367     ENTER();
00368 
00369     <span class="keywordflow">if</span> (SimHdw)
00370         <span class="keywordflow">return</span>(env-&gt;NewStringUTF(Sim_DriverResourcesStr));
00371 
00372     <span class="keywordflow">if</span> (pDrvr-&gt;getDriverResourcesStr(retStr))
00373         <span class="keywordflow">return</span>(env-&gt;NewStringUTF(retStr.c_str()));
00374     <span class="keywordflow">else</span>
00375         <span class="keywordflow">return</span>(env-&gt;NewStringUTF(<span class="stringliteral">"ERROR"</span>));         
00376 }
00377 
00378 
00379 <span class="comment">/*</span>
00380 <span class="comment"> * Class:     com_latticesemi_lpa_apps_sfif_SFIF_UI</span>
00381 <span class="comment"> * Method:    CPP_getPCIResourceStr</span>
00382 <span class="comment"> * Signature: ()Ljava/lang/String;</span>
00383 <span class="comment"> */</span>
00384 JNIEXPORT jstring JNICALL Java_com_latticesemi_lpa_apps_sfif_SFIF_1UI_CPP_1getPCIResourceStr(JNIEnv *env, jobject obj)
00385 {
00386     string retStr;
00387 
00388     ENTER();
00389 
00390     <span class="keywordflow">if</span> (SimHdw)
00391         <span class="keywordflow">return</span>(env-&gt;NewStringUTF(Sim_PCIResourceStr));
00392 
00393     <span class="keywordflow">if</span> (pDrvr-&gt;getPCIResourcesStr(retStr))
00394         <span class="keywordflow">return</span>(env-&gt;NewStringUTF(retStr.c_str()));
00395     <span class="keywordflow">else</span>
00396         <span class="keywordflow">return</span>(env-&gt;NewStringUTF(<span class="stringliteral">"ERROR"</span>));         
00397 }
00398 
00399 
00400 <span class="comment">/*</span>
00401 <span class="comment"> * Class:     com_latticesemi_lpa_apps_sfif_SFIF_UI</span>
00402 <span class="comment"> * Method:    CPP_getCfgRegsStr</span>
00403 <span class="comment"> * Signature: ()Ljava/lang/String;</span>
00404 <span class="comment"> */</span>
00405 JNIEXPORT jstring JNICALL Java_com_latticesemi_lpa_apps_sfif_SFIF_1UI_CPP_1getCfgRegsStr(JNIEnv *env, jobject obj)
00406 {
00407     string regVals, regFields, retStr;
00408     uint8_t cfgs[256];
00409 
00410     ENTER();
00411 
00412     <span class="keywordflow">if</span> (SimHdw)
00413         <span class="keywordflow">return</span>(env-&gt;NewStringUTF(Sim_CfgRegStr));
00414 
00415 
00416     <span class="keywordflow">if</span> (pDrvr-&gt;getPCIResourcesStr(regFields))
00417     {
00418         pDrvr-&gt;getPCIConfigRegs(cfgs);
00419         <span class="comment">// Call routine to format</span>
00420         MemFormat::formatBlockOfBytes(regVals, 0x00, 0x40, cfgs);
00421         retStr = regVals + regFields;
00422         <span class="keywordflow">return</span>(env-&gt;NewStringUTF(retStr.c_str()));         
00423     }
00424     <span class="keywordflow">else</span>
00425     {
00426         <span class="keywordflow">return</span>(env-&gt;NewStringUTF(<span class="stringliteral">"ERROR"</span>));         
00427     }
00428 }
00429 
00430 
00431 <span class="comment">/*</span>
00432 <span class="comment"> * Class:     com_latticesemi_lpa_apps_sfif_SFIF_UI</span>
00433 <span class="comment"> * Method:    CPP_getCapRegStr</span>
00434 <span class="comment"> * Signature: ()Ljava/lang/String;</span>
00435 <span class="comment"> */</span>
00436 JNIEXPORT jstring JNICALL Java_com_latticesemi_lpa_apps_sfif_SFIF_1UI_CPP_1getCapRegStr(JNIEnv *env, jobject obj)
00437 {
00438     string regVals, regFields, retStr;
00439     uint8_t caps[256];
00440 
00441     ENTER();
00442 
00443     <span class="keywordflow">if</span> (SimHdw)
00444         <span class="keywordflow">return</span>(env-&gt;NewStringUTF(Sim_CapRegStr));
00445 
00446     <span class="keywordflow">if</span> (pDrvr-&gt;getPCICapabiltiesStr(regFields))
00447     {
00448         pDrvr-&gt;getPCIConfigRegs(caps);
00449         <span class="comment">// Call routine to format the memory bytes into a table format in a string</span>
00450         MemFormat::formatBlockOfBytes(retStr, 0x40, (0x100-0x40), &amp;caps[0x40]);
00451         retStr = regVals + regFields;
00452         <span class="keywordflow">return</span>(env-&gt;NewStringUTF(retStr.c_str()));         
00453     }
00454     <span class="keywordflow">else</span>
00455     {
00456         <span class="keywordflow">return</span>(env-&gt;NewStringUTF(<span class="stringliteral">"ERROR"</span>));         
00457     }
00458 
00459 
00460 }
00461 
00462 
00463 <span class="comment">/*</span>
00464 <span class="comment"> * Class:     com_latticesemi_lpa_apps_sfif_SFIF_UI</span>
00465 <span class="comment"> * Method:    CPP_getExtraInfoStr</span>
00466 <span class="comment"> * Signature: ()Ljava/lang/String;</span>
00467 <span class="comment"> */</span>
00468 JNIEXPORT jstring JNICALL Java_com_latticesemi_lpa_apps_sfif_SFIF_1UI_CPP_1getExtraInfoStr(JNIEnv *env, jobject obj)
00469 {
00470     string retStr, outs;
00471 
00472     ENTER();
00473 
00474     <span class="keywordflow">if</span> (SimHdw)
00475         <span class="keywordflow">return</span>(env-&gt;NewStringUTF(Sim_ExtrInfoStr));
00476 
00477 
00478     <span class="keywordflow">if</span> (pDrvr-&gt;getPCIExtraInfoStr(retStr))
00479     {
00480         std::ostringstream oss;
00481 
00482         oss&lt;&lt;<span class="stringliteral">"\nRoot Complex Initial Credits:\n"</span>;
00483         oss&lt;&lt;<span class="stringliteral">"PD_CA (Wr): "</span>&lt;&lt;((pGPIO-&gt;read32(0x24))&gt;&gt;16)&lt;&lt;<span class="stringliteral">"\n"</span>;
00484         oss&lt;&lt;<span class="stringliteral">"NPH_CA(Rd): "</span>&lt;&lt;((pGPIO-&gt;read32(0x24)) &amp; 0xffff)&lt;&lt;<span class="stringliteral">"\n"</span>;
00485 
00486         outs = oss.str();
00487 
00488         retStr.append(outs);
00489         <span class="keywordflow">return</span>(env-&gt;NewStringUTF(retStr.c_str()));         
00490     }
00491     <span class="keywordflow">else</span>
00492     {
00493         <span class="keywordflow">return</span>(env-&gt;NewStringUTF(<span class="stringliteral">"ERROR"</span>));         
00494     }
00495 }
00496 
00497 
00498 <span class="comment">/*</span>
00499 <span class="comment"> * Class:     com_latticesemi_lpa_apps_sfif_SFIF_UI</span>
00500 <span class="comment"> * Method:    CPP_getPCSysBufStr</span>
00501 <span class="comment"> * Signature: ()Ljava/lang/String;</span>
00502 <span class="comment"> */</span>
00503 JNIEXPORT jstring JNICALL Java_com_latticesemi_lpa_apps_sfif_SFIF_1UI_CPP_1getPCSysBufStr(JNIEnv *env, jobject obj)
00504 {
00505     string retStr;
00506 
00507     ENTER();
00508 
00509     <span class="keywordflow">if</span> (SimHdw)
00510     {
00511         Sim_getPCSystemBuffer(retStr);
00512     }
00513     <span class="keywordflow">else</span>
00514     {
00515         uint32_t *buf;
00516 
00517         buf = (uint32_t *)malloc(SYS_DMA_BUF_SIZE);
00518         <span class="keywordflow">if</span> (buf == NULL)
00519         {
00520         retStr.append(<span class="stringliteral">"Memory Allocation Error!"</span>);
00521         }
00522         <span class="keywordflow">else</span>
00523         {
00524         pDrvr-&gt;readSysDmaBuf(buf, SYS_DMA_BUF_SIZE);
00525         MemFormat::formatBlockOfWords(retStr, DmaBufAddr, SYS_DMA_BUF_SIZE / 4, buf);
00526         free(buf);
00527         }
00528 
00529     }
00530 
00531     <span class="keywordflow">return</span>(env-&gt;NewStringUTF(retStr.c_str()));         
00532 }
00533 
00534 
00535 
00536 <span class="comment">/*</span>
00537 <span class="comment"> * Class:     com_latticesemi_lpa_apps_sfif_SFIF_UI</span>
00538 <span class="comment"> * Method:    CPP_clrPCSysBuf</span>
00539 <span class="comment"> * Signature: ()Ljava/lang/String;</span>
00540 <span class="comment"> */</span>
00541 JNIEXPORT jstring JNICALL Java_com_latticesemi_lpa_apps_sfif_SFIF_1UI_CPP_1clrPCSysBuf(JNIEnv *env, jobject obj)
00542 {
00543     string retStr;
00544 
00545     ENTER();
00546 
00547     <span class="keywordflow">if</span> (SimHdw)
00548     {
00549         Sim_clrPCSystemBuffer(retStr);
00550     }
00551     <span class="keywordflow">else</span>
00552     {
00553         uint32_t *buf;
00554 
00555         buf = (uint32_t *)malloc(SYS_DMA_BUF_SIZE);
00556         <span class="keywordflow">if</span> (buf == NULL)
00557         {
00558             retStr = <span class="stringliteral">"Memory Allocation Error!"</span>;
00559         }
00560         <span class="keywordflow">else</span>
00561         {
00562         memset(buf, 0, SYS_DMA_BUF_SIZE);
00563         pDrvr-&gt;writeSysDmaBuf(buf, SYS_DMA_BUF_SIZE);
00564 
00565         free(buf);
00566         }
00567     }
00568     <span class="keywordflow">return</span>(env-&gt;NewStringUTF(retStr.c_str()));         
00569 }
00570 
00571 
00572 
00573 <span class="comment">/*</span>
00574 <span class="comment"> * Class:     com_latticesemi_lpa_apps_sfif_SFIF_UI</span>
00575 <span class="comment"> * Method:    CPP_getSFIFRxFIFOStr</span>
00576 <span class="comment"> * Signature: ()Ljava/lang/String;</span>
00577 <span class="comment"> */</span>
00578 JNIEXPORT jstring JNICALL Java_com_latticesemi_lpa_apps_sfif_SFIF_1UI_CPP_1getSFIFRxFIFOStr(JNIEnv *env, jobject obj)
00579 {
00580     string retStr;
00581 
00582     ENTER();
00583 
00584     <span class="keywordflow">if</span> (SimHdw)
00585         Sim_getSFIFParseRxFIFO(retStr);
00586     <span class="keywordflow">else</span>
00587         pSFIF-&gt;getSFIFParseRxFIFO(retStr);
00588 
00589     <span class="keywordflow">return</span>(env-&gt;NewStringUTF(retStr.c_str()));         
00590 }
00591 
00592 
00593 
00594 <span class="comment">/*</span>
00595 <span class="comment"> * Class:     com_latticesemi_lpa_apps_sfif_SFIF_UI</span>
00596 <span class="comment"> * Method:    CPP_setupSFIF</span>
00597 <span class="comment"> * Signature: (IIIIIIII)Ljava/lang/String;</span>
00598 <span class="comment"> */</span>
00599 JNIEXPORT jstring JNICALL Java_com_latticesemi_lpa_apps_sfif_SFIF_1UI_CPP_1setupSFIF(JNIEnv *env, 
00600                                                                                      jobject obj, 
00601                                                                                      jint runMode, 
00602                                                                                      jint trafficMode, 
00603                                                                                      jint cycles, 
00604                                                                                      jint ICG, 
00605                                                                                      jint rdTLPSize, 
00606                                                                                      jint wrTLPSize, 
00607                                                                                      jint numRdTLPs, 
00608                                                                                      jint numWrTLPs)
00609 {
00610     <span class="keywordtype">bool</span> ok;
00611 
00612     ENTER();
00613 
00614     <span class="keywordflow">if</span> (SimHdw)
00615     {
00616         ok = Sim_setupSFIF(runMode, trafficMode, cycles, ICG, rdTLPSize, wrTLPSize, numRdTLPs, numWrTLPs);
00617     }
00618     <span class="keywordflow">else</span>
00619     {
00620         ok = pSFIF-&gt;setupSFIF(runMode, trafficMode, cycles, ICG, rdTLPSize, wrTLPSize, numRdTLPs, numWrTLPs);
00621     }
00622 
00623     <span class="keywordflow">if</span> (ok)
00624         <span class="keywordflow">return</span>(env-&gt;NewStringUTF(<span class="stringliteral">"OK"</span>));
00625     <span class="keywordflow">else</span>
00626         <span class="keywordflow">return</span>(env-&gt;NewStringUTF(<span class="stringliteral">"ERROR"</span>));         
00627 }
00628 
00629 
00630 <span class="comment">/*</span>
00631 <span class="comment"> * Class:     com_latticesemi_lpa_apps_sfif_SFIF_UI</span>
00632 <span class="comment"> * Method:    CPP_getSFIFRegsArray</span>
00633 <span class="comment"> * Signature: ([J)I</span>
00634 <span class="comment"> */</span>
00635 JNIEXPORT jint JNICALL Java_com_latticesemi_lpa_apps_sfif_SFIF_1UI_CPP_1getSFIFRegsArray (JNIEnv *env, 
00636                                                                                           jobject obj,
00637                                                                                           jlongArray jla)
00638 {
00639     <span class="keywordtype">int</span> nRead;
00640 
00641     ENTER();
00642 
00643 
00644     jsize len = env-&gt;GetArrayLength(jla);
00645 
00646     jlong *elements = env-&gt;GetLongArrayElements(jla, 0);
00647 
00648     <span class="keywordflow">if</span> (SimHdw)
00649         nRead = <a class="code" href="_cpp___jni_8cpp.html#a29">Sim_getSFIFRegs</a>((<span class="keywordtype">long</span> <span class="keywordtype">long</span> *)elements, len);
00650     <span class="keywordflow">else</span>
00651         nRead = pSFIF-&gt;getSFIFRegs((<span class="keywordtype">long</span> <span class="keywordtype">long</span> *)elements, len);
00652 
00653     env-&gt;ReleaseLongArrayElements(jla, elements, 0);
00654 
00655     <span class="keywordflow">return</span>(nRead);
00656 }
00657 
00658 
00659 
00660 <span class="comment">/*</span>
00661 <span class="comment"> * Class:     com_latticesemi_lpa_apps_sfif_SFIF_UI</span>
00662 <span class="comment"> * Method:    CPP_startSFIF</span>
00663 <span class="comment"> * Signature: (I)Ljava/lang/String;</span>
00664 <span class="comment"> */</span>
00665 JNIEXPORT jstring JNICALL Java_com_latticesemi_lpa_apps_sfif_SFIF_1UI_CPP_1startSFIF(JNIEnv *env, jobject obj, jint mode)
00666 {
00667     <span class="keywordtype">bool</span> ok;
00668 
00669     ENTER();
00670 
00671     <span class="keywordflow">if</span> (SimHdw)
00672         ok = Sim_startSFIF((uint32_t)mode);
00673     <span class="keywordflow">else</span>
00674         ok = pSFIF-&gt;startSFIF((uint32_t)mode);
00675 
00676     <span class="keywordflow">if</span> (ok)
00677         <span class="keywordflow">return</span>(env-&gt;NewStringUTF(<span class="stringliteral">"OK"</span>));
00678     <span class="keywordflow">else</span>
00679         <span class="keywordflow">return</span>(env-&gt;NewStringUTF(<span class="stringliteral">"ERROR"</span>));         
00680 }
00681 
00682 <span class="comment">/*</span>
00683 <span class="comment"> * Class:     com_latticesemi_lpa_apps_sfif_SFIF_UI</span>
00684 <span class="comment"> * Method:    CPP_stopSFIF</span>
00685 <span class="comment"> * Signature: ()Ljava/lang/String;</span>
00686 <span class="comment"> */</span>
00687 JNIEXPORT jstring JNICALL Java_com_latticesemi_lpa_apps_sfif_SFIF_1UI_CPP_1stopSFIF(JNIEnv *env, jobject obj)
00688 {
00689     <span class="keywordtype">bool</span> ok;
00690 
00691     ENTER();
00692 
00693     <span class="keywordflow">if</span> (SimHdw)
00694         ok = Sim_stopSFIF();
00695     <span class="keywordflow">else</span>
00696         ok = pSFIF-&gt;stopSFIF();
00697 
00698     <span class="keywordflow">if</span> (ok)
00699         <span class="keywordflow">return</span>(env-&gt;NewStringUTF(<span class="stringliteral">"OK"</span>));
00700     <span class="keywordflow">else</span>
00701         <span class="keywordflow">return</span>(env-&gt;NewStringUTF(<span class="stringliteral">"ERROR"</span>));         
00702 }
00703 
00704 
00705 <span class="comment">/*</span>
00706 <span class="comment"> * Class:     com_latticesemi_lpa_apps_sfif_SFIF_UI</span>
00707 <span class="comment"> * Method:    CPP_testGPIOAccess</span>
00708 <span class="comment"> * Signature: ()I</span>
00709 <span class="comment"> */</span>
00710 JNIEXPORT jint JNICALL Java_com_latticesemi_lpa_apps_sfif_SFIF_1UI_CPP_1testGPIOAccess(JNIEnv *env, jobject obj)
00711 {
00712 
00713     ENTER();
00714 
00715     <span class="keywordflow">if</span> (SimHdw)
00716         <span class="keywordflow">return</span>(0);
00717 
00718     <span class="keywordtype">int</span> i = 10; <span class="comment">// fudge factor to get it to run for 100 msec</span>
00719 
00720     uint32_t led = pGPIO-&gt;read32(0x08);  <span class="comment">// don't have a getLED method yet</span>
00721     <span class="keywordtype">int</span> err = 0;
00722     <span class="keywordflow">while</span> (i)
00723     {
00724         <span class="comment">// do a burst of 100 GPIO accesses to PCIe board</span>
00725         <span class="keywordflow">for</span> (uint32_t jj = 0; jj &lt; 100; jj++)
00726         {
00727             <span class="comment">// write Scratch Pad</span>
00728             pGPIO-&gt;setScratchPad(jj);
00729             <span class="comment">// Read GPIO ID register and verify</span>
00730             <span class="keywordflow">if</span> ((pGPIO-&gt;getID() != GPIO_ID_VALID) &amp;&amp; (pGPIO-&gt;getID() != OLD_GPIO_ID_VALID))
00731                 ++err;
00732             <span class="comment">// read scratch pad and verify</span>
00733             <span class="keywordflow">if</span> (pGPIO-&gt;getScratchPad() != jj)
00734                 ++err;
00735         }
00736 
00737         <span class="keywordflow">if</span> ((i % 10) == 0)  <span class="comment">// every 100msec show some activity</span>
00738         {
00739             led = (led&lt;&lt;1) &amp; 0xffff;
00740             <span class="keywordflow">if</span> (led == 0)
00741                 led = 1;
00742             pGPIO-&gt;setLED16Display((uint16_t)led);
00743         }
00744 
00745         Sleep(1);
00746         --i;
00747     }
00748 
00749 
00750     <span class="keywordflow">return</span>(err);    
00751 
00752 }
00753 
00754 
00755 
00756 
00757 <span class="comment">/*==================================================================*/</span>
00758 <span class="comment">/*==================================================================*/</span>
00759 <span class="comment">// SIMULATION FUNCTIONS RUN WHEN HARDWARE NOT PRESENT</span>
00760 <span class="comment">// For GUI testing mostly or for demo eval when no board avail</span>
00761 <span class="comment">/*==================================================================*/</span>
00762 <span class="comment">/*==================================================================*/</span>
00763 
00764 <span class="keywordtype">void</span> Sim_clrPCSystemBuffer(string &amp;retStr)
00765 {
00766     ENTER();
00767 
00768     memset(PC_DMA_Buf, 0, 16384);
00769     retStr.append(<span class="stringliteral">"OK"</span>);
00770 
00771 }
00772 
00773 
00774 <span class="keywordtype">void</span> Sim_getPCSystemBuffer(string &amp;retStr)
00775 {
00776     ENTER();
00777 
00778     <span class="comment">// retStr = "PC DMA buffer contents:  0000";</span>
00779     <a class="code" href="_cpp___jni_8cpp.html#a34">Sim_formatBlockOfWords</a>(retStr, 0x0000, 16384/4, PC_DMA_Buf);
00780 }
00781 
00782 
00783 <span class="keywordtype">void</span> Sim_getSFIFParseRxFIFO(string &amp;retStr)
00784 {
00785     ENTER();
00786 
00787     <a class="code" href="_cpp___jni_8cpp.html#a34">Sim_formatBlockOfWords</a>(retStr, 0x0000, 16384, SFIF_Rx_FIFO);
00788 
00789 }
00790 
00791 
00792 <span class="keywordtype">bool</span> Sim_setupSFIF(<span class="keywordtype">int</span> runMode, 
00793                    <span class="keywordtype">int</span> trafficMode, 
00794                    <span class="keywordtype">int</span> cycles, 
00795                    <span class="keywordtype">int</span> ICG, 
00796                    <span class="keywordtype">int</span> rdTLPSize, 
00797                    <span class="keywordtype">int</span> wrTLPSize, 
00798                    <span class="keywordtype">int</span> numRdTLPs, 
00799                    <span class="keywordtype">int</span> numWrTLPs)
00800 {
00801 
00802     ENTER();
00803 
00804     <span class="keywordflow">if</span> (cycles &lt; 1)
00805         cycles = 1;
00806     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cycles &gt; 0xffff)
00807         cycles = 0xffff;
00808 
00809     <span class="keywordflow">if</span> (ICG &lt; 1)
00810         ICG = 1;
00811     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ICG &gt; 0xffff)
00812         ICG = 0xffff;
00813 
00814     Sim_runMode = runMode; 
00815     Sim_trafficMode = trafficMode; 
00816     Sim_cycles = cycles; 
00817     Sim_ICG = ICG; 
00818     Sim_rdTLPSize = rdTLPSize; 
00819     Sim_wrTLPSize = wrTLPSize; 
00820     Sim_numRdTLPs = numRdTLPs; 
00821     Sim_numWrTLPs = numWrTLPs;
00822 
00823 
00824     ++Sim_PC_DMA_Buf_val;
00825     memset(PC_DMA_Buf, PC_DMA_Buf_val, 16384);
00826 
00827     <span class="keywordflow">return</span>(<span class="keyword">true</span>);
00828 
00829 }
00830 
00831 
00832 
<a name="l00838"></a><a class="code" href="_cpp___jni_8cpp.html#a29">00838</a> <span class="keywordtype">int</span> <a class="code" href="_cpp___jni_8cpp.html#a29">Sim_getSFIFRegs</a>(<span class="keywordtype">long</span> <span class="keywordtype">long</span> *elements, <span class="keywordtype">int</span> len)
00839 {
00840 
00841     ENTER();
00842 
00843     <span class="keywordflow">if</span> (Sim_SFIFisRunning)
00844     {
00845         Sim_stopSFIF();  <span class="comment">// have to fake stop to update counters</span>
00846         Sim_SFIFisRunning = <span class="keyword">true</span>;
00847     }
00848     elements[0] = (<span class="keywordtype">long</span> long)Sim_ElapseTime;
00849     elements[1] = (<span class="keywordtype">long</span> long)Sim_TxTLPCntr;
00850     elements[2] = (<span class="keywordtype">long</span> long)Sim_RxTLPCntr;
00851     elements[3] = (<span class="keywordtype">long</span> long)Sim_WrWaitTime;
00852     elements[4] = (<span class="keywordtype">long</span> long)Sim_LastCplDTime;
00853     elements[5] = (<span class="keywordtype">long</span> long)Sim_RdWaitTime;
00854 
00855 
00856     <span class="keywordflow">return</span>(6);
00857 
00858 }
00859 
00860 <span class="keywordtype">bool</span> Sim_startSFIF(uint32_t mode)
00861 {
00862     ENTER();
00863     <span class="comment">// First reset all the stats counters for this run</span>
00864     <span class="comment">// We can't just let them go continuously because they're 32 bit and </span>
00865     <span class="comment">// can wrap after only a minute</span>
00866     Sim_ElapseTime = 0;
00867     Sim_TxTLPCntr = 0;
00868     Sim_RxTLPCntr = 0;
00869     Sim_WrWaitTime = 0;
00870     Sim_LastCplDTime = 0;
00871     Sim_RdWaitTime = 0;
00872 
00873     Sim_SFIFisRunning = <span class="keyword">true</span>;
00874 
00875     <span class="keywordflow">return</span>(<span class="keyword">true</span>);
00876 }
00877 
00878 
00879 <span class="preprocessor">#define TX_FUDGE 4</span>
00880 <span class="preprocessor"></span>
00881 <span class="keywordtype">bool</span> Sim_stopSFIF()
00882 {
00883     <span class="keywordtype">int</span> CplDs;
00884     <span class="keywordtype">int</span> CpldSize;
00885     uint32_t MWr_clks, MRd_clks,MRdWait_clks;
00886     <span class="keywordtype">float</span> WrTLPSize;
00887     <span class="keywordtype">float</span> RdTLPSize;
00888     <span class="keywordtype">float</span> ICG;
00889     <span class="keywordtype">float</span> numWrTLPs;
00890     <span class="keywordtype">float</span> numRdTLPs;
00891     <span class="keywordtype">float</span> rate;
00892     <span class="keywordtype">float</span> Rd_factor, ICG_factor;
00893     <span class="keywordtype">float</span> frand;
00894 
00895 
00896     ENTER();
00897 
00898     Sim_SFIFisRunning = <span class="keyword">false</span>;
00899 
00900     <span class="comment">// Calculate the new counter values now based on the traffic that was to be sent</span>
00901     <span class="comment">// The run-time parameters are from the setupSFIF().</span>
00902 
00903 
00904     <span class="comment">// This is all bogus, made-up guestimates of a totally fictious system.</span>
00905     <span class="comment">// it is not meant to emulate any real hardware performance, just to</span>
00906     <span class="comment">// produce some numbers.</span>
00907 
00908     <span class="keywordflow">if</span> (Sim_runMode == 0)
00909     {
00910         ICG = (float)Sim_ICG;
00911         WrTLPSize = (float)Sim_wrTLPSize;
00912         RdTLPSize = (float)Sim_rdTLPSize;
00913         numRdTLPs = (float)Sim_numRdTLPs ;
00914         numWrTLPs = (float)Sim_numWrTLPs ;
00915 
00916         <span class="keywordflow">if</span> (Sim_rdTLPSize &lt; 64)
00917         {
00918             CplDs = 1;
00919             CpldSize = Sim_rdTLPSize;
00920         }
00921         <span class="keywordflow">else</span>
00922         {
00923             CplDs = Sim_rdTLPSize/64;
00924             CpldSize = 64;
00925         }
00926 
00927         frand = ((float)(5 - (rand() % 10)) * 0.01)  + 1.0;
00928         <span class="comment">//frand = 1.0;</span>
00929         cout&lt;&lt;<span class="stringliteral">"frand="</span>&lt;&lt;frand&lt;&lt;endl;
00930 
00931 
00932         <span class="comment">// Thruput mode. it ran for 1 second</span>
00933         Sim_ElapseTime = (long)(125E6 * frand);   <span class="comment">// 125MHz clock counting for 1 second</span>
00934 
00935         <span class="keywordflow">if</span> (Sim_numRdTLPs &gt; 0)
00936             Sim_LastCplDTime = (long)(125E6 * frand);   <span class="comment">// 125MHz clock counting for 1 second</span>
00937         <span class="keywordflow">else</span>
00938             Sim_LastCplDTime = 0;
00939 
00940         <span class="keywordflow">if</span> (ICG &gt; 0.0)
00941         {
00942             ICG_factor = (0.5 * (ICG / ((WrTLPSize/8.0) * numWrTLPs)));
00943             <span class="keywordflow">if</span> (ICG_factor &gt; 0.1)
00944                 ICG_factor = 0.1;
00945         }
00946         <span class="keywordflow">else</span>
00947         {
00948             ICG_factor = 0.0;
00949         }
00950 
00951         <span class="keywordflow">if</span> ((WrTLPSize != 0.0) &amp;&amp; (numWrTLPs != 0.0))
00952         {
00953             Rd_factor = 0.1 * (numRdTLPs / (WrTLPSize / 8.0));
00954             <span class="keywordflow">if</span> (Rd_factor &gt; 0.1)
00955                 Rd_factor = 0.1;
00956         }
00957         <span class="keywordflow">else</span>
00958         {
00959             Rd_factor = 0.1;
00960         }
00961 
00962         <span class="keywordflow">if</span> (Sim_numRdTLPs &gt; 0)
00963         {
00964             rate = 600.0 * (0.2 + (RdTLPSize / 512.0) - ICG_factor - (0.1 - Rd_factor));
00965             <span class="keywordflow">if</span> (rate &gt; 750.0)
00966                 rate = 750.0;
00967             Sim_RxTLPCntr = (long)(rate * 1E6 / CpldSize + 0.5);
00968             Sim_TxTLPCntr = (Sim_RxTLPCntr / 8);
00969             Sim_RdWaitTime = ((<span class="keywordtype">unsigned</span> int)rand() % 5000) * (Sim_numRdTLPs * Sim_rdTLPSize);
00970         }
00971         <span class="keywordflow">else</span>
00972         {
00973             rate = 0.0;
00974             Sim_TxTLPCntr = 0;
00975         }
00976 
00977         <span class="keywordflow">if</span> (numWrTLPs &gt; 0.0)
00978         {
00979             rate = 650.0 * (0.2 + (WrTLPSize / 128.0) - ICG_factor - Rd_factor);
00980             <span class="keywordflow">if</span> (rate &gt; 820.0)
00981                 rate = 820.0;
00982             Sim_TxTLPCntr = (long)(rate * 1E6 / WrTLPSize + 0.5);
00983             Sim_WrWaitTime = ((<span class="keywordtype">unsigned</span> int)rand() % 500) * (Sim_numWrTLPs * Sim_wrTLPSize);
00984         }
00985         <span class="keywordflow">else</span>
00986         {
00987             Sim_WrWaitTime = 0;
00988         }
00989 
00990     }
00991     <span class="keywordflow">else</span>
00992     {
00993 
00994 
00995         MWr_clks = Sim_numWrTLPs * (TX_FUDGE + 2 + Sim_wrTLPSize/8);
00996         MRd_clks = Sim_numRdTLPs * (TX_FUDGE + 2);
00997         MRdWait_clks = (Sim_numRdTLPs / 16) * 100;  <span class="comment">// assume have to wait after 16 tags have been sent</span>
00998         Sim_ElapseTime = (long)(MWr_clks  + MRd_clks + MRdWait_clks + Sim_ICG) * Sim_cycles;
00999 
01000         Sim_TxTLPCntr = (Sim_numWrTLPs + Sim_numRdTLPs) * Sim_cycles;
01001         <span class="keywordflow">if</span> (Sim_rdTLPSize &lt; 64)
01002         {
01003             CplDs = 1;
01004             CpldSize = Sim_rdTLPSize;
01005         }
01006         <span class="keywordflow">else</span>
01007         {
01008             CplDs = Sim_rdTLPSize/64;
01009             CpldSize = 64;
01010         }
01011 
01012         <span class="keywordflow">if</span> (Sim_numRdTLPs)
01013             Sim_LastCplDTime = Sim_ElapseTime + (long)(CplDs * Sim_numRdTLPs * 10) * Sim_cycles;
01014         <span class="keywordflow">else</span>
01015             Sim_LastCplDTime =  0;
01016         Sim_RxTLPCntr = (CplDs * Sim_numRdTLPs) * Sim_cycles;  <span class="comment">// based on RCB=64</span>
01017 
01018         Sim_WrWaitTime = Sim_cycles;  <span class="comment">// assume hardly no waiting (always reads atleast 1)</span>
01019         Sim_RdWaitTime = (long)((double)Sim_ElapseTime * ((double)Sim_numRdTLPs/32.0) + 0.5);
01020 
01021     }
01022 
01023     <span class="keywordflow">return</span>(<span class="keyword">true</span>);
01024 }
01025 
01026 
<a name="l01032"></a><a class="code" href="_cpp___jni_8cpp.html#a34">01032</a> <span class="keywordtype">bool</span> <a class="code" href="_cpp___jni_8cpp.html#a34">Sim_formatBlockOfWords</a>(string &amp;ostr, uint32_t startAddr, uint32_t len, uint32_t *data)
01033 {
01034     uint32_t i, j;
01035     uint32_t addr;
01036     <span class="keywordtype">char</span> *blank;
01037     <span class="keywordtype">char</span> buf[256];
01038 
01039     <span class="keywordflow">if</span> (len == 1)
01040     {
01041         sprintf(buf, <span class="stringliteral">"%08x: %08x\n"</span>, startAddr, *data);
01042         ostr.append(buf);
01043         <span class="keywordflow">return</span>(<span class="keyword">true</span>);
01044     }
01045 
01046     <span class="keywordflow">if</span> (len &gt; 2)
01047     {
01048         ostr.append(<span class="stringliteral">"\n"</span>);  <span class="comment">/* can't fit all on one line so start its own block */</span>
01049         blank = <span class="stringliteral">"          "</span>;
01050     }
01051     <span class="keywordflow">else</span>
01052     {
01053         blank = <span class="stringliteral">""</span>;
01054     }
01055 
01056     addr = (startAddr &amp; 0xfffffff0);
01057     len = len + (startAddr - addr) / 4;
01058 
01059     j = 0;
01060     <span class="keywordflow">for</span> (i = 0; i &lt; len; i++)
01061     {
01062         <span class="keywordflow">if</span> ((i % 4) == 0)
01063         {
01064             <span class="keywordflow">if</span> (i &gt; 0)
01065                 sprintf(buf, <span class="stringliteral">"\n%08x:"</span>, addr);
01066             <span class="keywordflow">else</span>
01067                 sprintf(buf, <span class="stringliteral">"%08x:"</span>, startAddr);
01068             ostr.append(buf);
01069         }
01070         <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((i % 2) == 0)
01071         {
01072             ostr.append(<span class="stringliteral">"  "</span>);  <span class="comment">// divide output into 2 cols</span>
01073         }
01074 
01075         <span class="keywordflow">if</span> (addr &lt; startAddr)
01076         {
01077             ostr.append(blank);
01078         }
01079         <span class="keywordflow">else</span>
01080         {
01081             sprintf(buf, <span class="stringliteral">"  %08x"</span>, data[j]);
01082             ostr.append(buf);
01083             ++j;
01084         }
01085 
01086         addr = addr + 4;
01087     }
01088 
01089     ostr.append(<span class="stringliteral">"\n"</span>);
01090 
01091     <span class="keywordflow">return</span>(<span class="keyword">true</span>);
01092 }
01093 
01094 
01095 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Jul 16 12:05:29 2008 for Lattice PCIe Thruput Demo by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
