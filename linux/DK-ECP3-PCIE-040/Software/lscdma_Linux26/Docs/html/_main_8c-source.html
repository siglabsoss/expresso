<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Lattice PCIeDMA Device Driver : Main.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>Main.c</h1><a href="_main_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment"> *  COPYRIGHT (c) 2008 by Lattice Semiconductor Corporation</span>
00003 <span class="comment"> *</span>
00004 <span class="comment"> * All rights reserved. All use of this software and documentation is</span>
00005 <span class="comment"> * subject to the License Agreement located in the file LICENSE.</span>
00006 <span class="comment"> */</span>
00098 <span class="preprocessor">#include "<a class="code" href="lscdma_8h.html">lscdma.h</a>"</span>
00099 
00100 <span class="preprocessor">#ifndef CONFIG_PCI</span>
00101 <span class="preprocessor"></span><span class="preprocessor">    #error No PCI Bus Support in kernel!</span>
00102 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00103 <span class="preprocessor"></span>
00104 <span class="preprocessor">#define USE_PROC  </span><span class="comment">/* For debugging */</span>
00105 
00106 <span class="comment">// Comment out this define if your kernel has no MSI API's </span>
00107 <span class="preprocessor">#define MSI    </span><span class="comment">/* attempt to use MSI interrupt support */</span>
00108 
00109 
00110 
00111 
00112 MODULE_AUTHOR(<span class="stringliteral">"Lattice Semiconductor"</span>);
00113 MODULE_DESCRIPTION(<span class="stringliteral">"LSC_PCIe DMA Device Driver"</span>);
00114 
00115 <span class="comment">/* License this so no annoying messages when loading module */</span>
00116 MODULE_LICENSE(<span class="stringliteral">"Dual BSD/GPL"</span>);
00117 
00118 MODULE_ALIAS(<span class="stringliteral">"lscdma"</span>);
00119 
00120 
00121 
00122 
00123 <span class="comment">/*-------------------------------------------------*/</span>
00124 <span class="comment">/*-------------------------------------------------*/</span>
00125 <span class="comment">/*-------------------------------------------------*/</span>
00126 <span class="comment">/*</span>
00127 <span class="comment"> *            DRIVER GLOBAL VARIABLES</span>
00128 <span class="comment"> */</span>
00129 <span class="comment">/*-------------------------------------------------*/</span>
00130 <span class="comment">/*-------------------------------------------------*/</span>
00131 <span class="comment">/*-------------------------------------------------*/</span>
00132 
00133 
00137 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="struct_l_s_c_d_m_a.html">LSCDMA</a> lscdma;
00138 
00139 
00140 
00141 <span class="keywordtype">int</span> DrvrDebug = 0;
00142 
00143 
00144 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> Version[] = <span class="stringliteral">"lscdma v1.0.10 - fix write() wait"</span>;  
00147 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *BoardName[3] = {<span class="stringliteral">"??"</span>, <span class="stringliteral">"SC"</span>, <span class="stringliteral">"ECP2M"</span>};
00148 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *DemoName[3] = {<span class="stringliteral">"??"</span>, <span class="stringliteral">"DMA"</span>};
00149 
00150 
00151 
00155 <span class="keyword">static</span> <span class="keyword">struct </span>pci_device_id lscdma_pci_id_tbl[] = 
00156 {
00157     { 0x1204, 0x5303, 0x1204, 0x3040, },   <span class="comment">// SC DMA</span>
00158     { 0x1204, 0xe250, 0x1204, 0x3040, },   <span class="comment">// ECP2M DMA</span>
00159     { }         <span class="comment">/* Terminating entry */</span>
00160 };
00161 
00162 MODULE_DEVICE_TABLE(pci, lscdma_pci_id_tbl);
00163 
00164 
00165 <span class="comment">// Wait Q's to park user's read/write requests while DMAing</span>
00166 DECLARE_WAIT_QUEUE_HEAD(lscdma_ReadQ);
00167 DECLARE_WAIT_QUEUE_HEAD(lscdma_WriteQ);
00168 
00169 
00170 
00171 <span class="comment">/*========================================================================*/</span>
00172 <span class="comment">/*========================================================================*/</span>
00173 <span class="comment">/*========================================================================*/</span>
00174 <span class="comment">/*</span>
00175 <span class="comment"> *            PROC DEBUG STUFF</span>
00176 <span class="comment"> */</span>
00177 <span class="comment">/*========================================================================*/</span>
00178 <span class="comment">/*========================================================================*/</span>
00179 <span class="comment">/*========================================================================*/</span>
00180 <span class="preprocessor">#ifdef USE_PROC </span><span class="comment">/* don't waste space if unused */</span>
00181 
<a name="l00186"></a><a class="code" href="_main_8c.html#a18">00186</a> <span class="keywordtype">int</span> <a class="code" href="_main_8c.html#a18">lscdma_read_procmem</a>(<span class="keywordtype">char</span> *buf, <span class="keywordtype">char</span> **start, off_t offset,
00187                          <span class="keywordtype">int</span> count, <span class="keywordtype">int</span> *eof, <span class="keywordtype">void</span> *data)
00188 {
00189     <span class="keywordtype">int</span> i, n;
00190     <span class="keywordtype">int</span> len = 0;
00191     <span class="comment">// int limit = count - 80; /* Don't print more than this */</span>
00192     <a class="code" href="struct_p_c_i___dev___b_a_r.html">pci_dev_bar_t</a> *p;  
00193 
00194     *start = buf + offset;
00195 
00196     <span class="keywordflow">if</span> (DrvrDebug)
00197         printk(KERN_INFO <span class="stringliteral">"lscdma: /proc entry created\n"</span>);
00198 
00199     <span class="comment">/* Put any messages in here that will be displayed by cat /proc/driver/.. */</span>
00200     len += sprintf(buf+len, <span class="stringliteral">"\nLSC PCIE Device Driver Info\n"</span>);
00201     len += sprintf(buf+len, <span class="stringliteral">"\nNumBoards: %d  Major#: %d\n"</span>, lscdma.<a class="code" href="struct_l_s_c_d_m_a.html#o1">numBoards</a>, MAJOR(lscdma.<a class="code" href="struct_l_s_c_d_m_a.html#o0">drvrDevNum</a>));
00202 
00203     <span class="keywordflow">for</span> (n = 0; n &lt; NUM_BOARDS; n++)
00204     {
00205 
00206         <span class="keywordflow">if</span> (lscdma.<a class="code" href="struct_l_s_c_d_m_a.html#o7">Board</a>[n].<a class="code" href="struct_p_c_i_e___board.html#o0">ID</a> != 0)
00207         {
00208 
00209             len += sprintf(buf+len, <span class="stringliteral">"Board:%d = %x  Demo=%x IRQ=%d\n"</span>, lscdma.<a class="code" href="struct_l_s_c_d_m_a.html#o7">Board</a>[n].<a class="code" href="struct_p_c_i_e___board.html#o5">instanceNum</a>, 
00210                                     lscdma.<a class="code" href="struct_l_s_c_d_m_a.html#o7">Board</a>[n].<a class="code" href="struct_p_c_i_e___board.html#o0">ID</a>,
00211                                     lscdma.<a class="code" href="struct_l_s_c_d_m_a.html#o7">Board</a>[n].<a class="code" href="struct_p_c_i_e___board.html#o1">demoID</a>,
00212                                     lscdma.<a class="code" href="struct_l_s_c_d_m_a.html#o7">Board</a>[n].<a class="code" href="struct_p_c_i_e___board.html#o15">IRQ</a>);
00213 
00214             <span class="keywordflow">for</span> (i = 0; i &lt; NUM_BARS; i++)
00215             {
00216                 p = &amp;lscdma.<a class="code" href="struct_l_s_c_d_m_a.html#o7">Board</a>[n].<a class="code" href="struct_p_c_i_e___board.html#o20">Dev_BARs</a>[i];
00217                 len += sprintf(buf+len, <span class="stringliteral">"BAR[%d]  pci_addr=%p  kvm_addr=%p\n"</span>
00218                                <span class="stringliteral">"          type=%d  dataSize=%d  len=%ld\n"</span>
00219                                <span class="stringliteral">"          start=%lx  end=%lx  flags=%lx\n"</span>,
00220                                i, 
00221                                p-&gt;<a class="code" href="struct_p_c_i___dev___b_a_r.html#o1">pci_addr</a>,
00222                                p-&gt;<a class="code" href="struct_p_c_i___dev___b_a_r.html#o2">kvm_addr</a>,
00223                                p-&gt;<a class="code" href="struct_p_c_i___dev___b_a_r.html#o3">memType</a>,
00224                                p-&gt;<a class="code" href="struct_p_c_i___dev___b_a_r.html#o4">dataSize</a>,
00225                                p-&gt;<a class="code" href="struct_p_c_i___dev___b_a_r.html#o5">len</a>,
00226                                p-&gt;<a class="code" href="struct_p_c_i___dev___b_a_r.html#o6">pci_start</a>,
00227                                p-&gt;<a class="code" href="struct_p_c_i___dev___b_a_r.html#o7">pci_end</a>,
00228                                p-&gt;<a class="code" href="struct_p_c_i___dev___b_a_r.html#o8">pci_flags</a>);
00229             }
00230         }
00231     }
00232 
00233     <span class="keywordflow">if</span> (len &lt; offset + count)
00234         *eof = 1;   <span class="comment">/* Mark that this is a complete buffer (the End of File) */</span>
00235 
00236     <span class="comment">/* Not sure about all this, but it works */</span>
00237     len = len - offset;
00238     <span class="keywordflow">if</span> (len &gt; count)
00239         len = count;
00240     <span class="keywordflow">if</span> (len &lt; 0)
00241         len = 0;
00242 
00243 
00244     <span class="keywordflow">return</span>(len);
00245 }
00246 
00247 
00248 <span class="preprocessor">#endif </span><span class="comment">/* USE_PROC */</span>
00249 
00250 
00251 
00252 <span class="comment">/*====================================================================================*/</span>
00253 <span class="comment">/*====================================================================================*/</span>
00254 <span class="comment">/*====================================================================================*/</span>
00255 <span class="comment">/*</span>
00256 <span class="comment"> *     HARDWARE BOARD DISCOVERY AND SETUP</span>
00257 <span class="comment"> */</span>
00258 <span class="comment">/*====================================================================================*/</span>
00259 <span class="comment">/*====================================================================================*/</span>
00260 <span class="comment">/*====================================================================================*/</span>
00261 
00262 
00269 <span class="keyword">static</span> <a class="code" href="struct_p_c_i_e___board.html">pcie_board_t</a>* initBoard(<span class="keyword">struct</span> pci_dev *PCI_Dev_Cfg, <span class="keywordtype">void</span> * devID)
00270 {
00271     <span class="keywordtype">int</span> i;
00272     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> irq;
00273     <a class="code" href="struct_p_c_i_e___board.html">pcie_board_t</a> *pBrd;
00274     <a class="code" href="struct_p_c_i___dev___b_a_r.html">pci_dev_bar_t</a> *pBAR;
00275     <a class="code" href="struct_p_c_i___dev___b_a_r.html">pci_dev_bar_t</a> *p;
00276     u16 SubSystem;
00277     u16 VendorID;
00278     u16 DeviceID;
00279 
00280     <span class="comment">/****************************************************/</span>
00281     <span class="comment">/* Device info passed in from the PCI controller via probe() */</span>
00282     <span class="comment">/****************************************************/</span>
00283 
00284 <span class="comment">// TODO</span>
00285 <span class="comment">// Add writing an 'E' to the LEDs to show an error if initialization fails</span>
00286 <span class="comment">// Problem is we don't have BARs setup till end of this function :-(</span>
00287 
00288 
00289     <span class="keywordflow">if</span> (DrvrDebug)
00290         printk(KERN_INFO <span class="stringliteral">"lscdma: init EvalBoard\n"</span>);
00291 
00292     <span class="keywordflow">if</span> (lscdma.<a class="code" href="struct_l_s_c_d_m_a.html#o1">numBoards</a> &gt;= NUM_BOARDS)
00293     {
00294         printk(KERN_WARNING <span class="stringliteral">"lscdma: init: Too many boards! Increase NUM_BOARDS!\n"</span>);
00295         <span class="keywordflow">return</span>(NULL);
00296     }
00297 
00298 
00299     <span class="comment">/* Next available board structure in data base */</span>
00300     pBrd = &amp;lscdma.<a class="code" href="struct_l_s_c_d_m_a.html#o7">Board</a>[lscdma.<a class="code" href="struct_l_s_c_d_m_a.html#o1">numBoards</a>];
00301 
00302     <span class="comment">// Initialize new board structure to all 0's</span>
00303     memset(pBrd, 0, <span class="keyword">sizeof</span>(<a class="code" href="struct_p_c_i_e___board.html">pcie_board_t</a>));
00304 
00305 
00306     <span class="keywordflow">if</span> (pci_read_config_word(PCI_Dev_Cfg, PCI_VENDOR_ID, &amp;VendorID))
00307     {
00308         printk(KERN_ERR <span class="stringliteral">"lscdma: init EvalBoard cfg access failed!\n"</span>);
00309         <span class="keywordflow">return</span>(NULL);
00310     }
00311     <span class="keywordflow">if</span> (VendorID != 0x1204)
00312     {
00313         printk(KERN_ERR <span class="stringliteral">"lscdma: init EvalBoard not Lattice ID!\n"</span>);
00314         <span class="keywordflow">return</span>(NULL);
00315     }
00316 
00317     <span class="keywordflow">if</span> (pci_read_config_word(PCI_Dev_Cfg, PCI_DEVICE_ID, &amp;DeviceID))
00318     {
00319         printk(KERN_ERR <span class="stringliteral">"lscdma: init EvalBoard cfg access failed!\n"</span>);
00320         <span class="keywordflow">return</span>(NULL);
00321     }
00322 
00323     <span class="keywordflow">if</span> (pci_read_config_word(PCI_Dev_Cfg, PCI_SUBSYSTEM_ID, &amp;SubSystem))
00324     {
00325         printk(KERN_ERR <span class="stringliteral">"lscdma: init EvalBoard cfg access failed!\n"</span>);
00326         <span class="keywordflow">return</span>(NULL);
00327     }
00328 
00329 
00330     <span class="comment">// Start initializing data for new board</span>
00331     pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o0">ID</a> = DeviceID;
00332     pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o1">demoID</a> = SubSystem;
00333     pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o25">pPciDev</a> = PCI_Dev_Cfg;
00334     pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o8">majorNum</a> = MAJOR(lscdma.<a class="code" href="struct_l_s_c_d_m_a.html#o0">drvrDevNum</a>);
00335     pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o9">minorNum</a> = MINOR(lscdma.<a class="code" href="struct_l_s_c_d_m_a.html#o0">drvrDevNum</a>) + lscdma.<a class="code" href="struct_l_s_c_d_m_a.html#o1">numBoards</a>;
00336     atomic_set(&amp;(pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o6">OpenToken</a>), 1);   <span class="comment">// initialize "open" token to available </span>
00337     spin_lock_init(&amp;pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o7">hdwAccess</a>);   <span class="comment">// initialize spin-lock for register access protection</span>
00338 
00339     <span class="comment">// Figure out if board is SC or ECP2M, if demo is DMA or its an unknown board</span>
00340     <span class="keywordflow">if</span> ((DeviceID == 0x5303) &amp;&amp; (SubSystem == 0x3040))
00341     {
00342         ++lscdma.<a class="code" href="struct_l_s_c_d_m_a.html#o3">numSC_SFIF</a>;
00343         pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o5">instanceNum</a>  = lscdma.<a class="code" href="struct_l_s_c_d_m_a.html#o3">numSC_SFIF</a>;
00344         pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o4">boardType</a> = SC_BOARD;
00345         pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o2">demoType</a> = DMA_DEMO;
00346         pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o23">ctrlBAR</a> = 0;
00347     }
00348     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((DeviceID == 0xe250) &amp;&amp; (SubSystem == 0x3040))
00349     {
00350         ++lscdma.<a class="code" href="struct_l_s_c_d_m_a.html#o5">numECP2M_SFIF</a>;
00351         pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o5">instanceNum</a>  = lscdma.<a class="code" href="struct_l_s_c_d_m_a.html#o5">numECP2M_SFIF</a>;
00352         pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o4">boardType</a> = ECP2M_BOARD;
00353         pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o2">demoType</a> = DMA_DEMO;
00354         pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o23">ctrlBAR</a> = 0;
00355     }
00356     <span class="keywordflow">else</span>
00357     {
00358         printk(KERN_ERR <span class="stringliteral">"lscdma: init ERROR! unknown board: %x %x\n"</span>, DeviceID, SubSystem);
00359         pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o5">instanceNum</a>  = 0;
00360         pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o4">boardType</a> = 0;
00361         pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o2">demoType</a> = 0;
00362         <span class="keywordflow">return</span>(NULL);
00363     }
00364 
00365     <span class="comment">// For now, all demos use only one BAR and that BAR is for control plane and is also what will</span>
00366     <span class="comment">// be mmap'ed into user space for the driver interface to access.</span>
00367     pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o22">mmapBAR</a> = pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o23">ctrlBAR</a>;
00368 
00369 
00370     <span class="comment">//=============== Interrupt handling stuff ========================</span>
00371     <span class="keywordflow">if</span> (pci_read_config_byte(PCI_Dev_Cfg, PCI_INTERRUPT_LINE, &amp;irq))
00372         pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o15">IRQ</a> = -1;  <span class="comment">// no interrupt</span>
00373     <span class="keywordflow">else</span>
00374         pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o15">IRQ</a> = irq;
00375 
00376     <span class="keywordflow">if</span> (DrvrDebug)
00377     {
00378         printk(KERN_INFO <span class="stringliteral">"lscdma: init brdID: %x  demoID: %x\n"</span>, DeviceID, SubSystem);
00379         printk(KERN_INFO <span class="stringliteral">"lscdma: init Board[] =%d\n"</span>, lscdma.<a class="code" href="struct_l_s_c_d_m_a.html#o1">numBoards</a>);
00380         printk(KERN_INFO <span class="stringliteral">"lscdma: init IRQ=%d\n"</span>, irq);
00381     }
00382 
00383 
00384     <span class="comment">//================ DMA Common Buffer (Consistent) Allocation ====================</span>
00385     <span class="comment">// First see if platform supports 32 bit DMA address cycles (like what won't!)</span>
00386     <span class="keywordflow">if</span> (pci_set_dma_mask(PCI_Dev_Cfg, DMA_32BIT_MASK))
00387     {
00388         printk(KERN_WARNING <span class="stringliteral">"lscdma: init DMA not supported!\n"</span>);
00389         pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o28">CBDMA</a>.<a class="code" href="struct_c_b_d_m_a_operations__t.html#o0">hasDMA</a> = FALSE;
00390     }
00391     <span class="keywordflow">else</span>
00392     {   
00393         pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o28">CBDMA</a>.<a class="code" href="struct_c_b_d_m_a_operations__t.html#o0">hasDMA</a> = TRUE;
00394         pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o28">CBDMA</a>.<a class="code" href="struct_c_b_d_m_a_operations__t.html#o2">dmaBufSize</a> = DMA_BUFFER_SIZE;
00395         pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o28">CBDMA</a>.<a class="code" href="struct_c_b_d_m_a_operations__t.html#o4">dmaCPUAddr</a> = pci_alloc_consistent(PCI_Dev_Cfg, pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o28">CBDMA</a>.<a class="code" href="struct_c_b_d_m_a_operations__t.html#o2">dmaBufSize</a>, &amp;pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o28">CBDMA</a>.<a class="code" href="struct_c_b_d_m_a_operations__t.html#o3">dmaPCIBusAddr</a>);
00396         <span class="keywordflow">if</span> (pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o28">CBDMA</a>.<a class="code" href="struct_c_b_d_m_a_operations__t.html#o4">dmaCPUAddr</a> == NULL)
00397         {
00398             printk(KERN_WARNING <span class="stringliteral">"lscdma: init DMA alloc failed! No DMA buffer.\n"</span>);
00399             pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o28">CBDMA</a>.<a class="code" href="struct_c_b_d_m_a_operations__t.html#o0">hasDMA</a> = FALSE;
00400         }
00401     }
00402 
00403 
00404     <span class="comment">/* Get info on all the PCI BAR registers */</span>
00405     pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o21">numBars</a> = 0;  <span class="comment">// initialize</span>
00406     <span class="keywordflow">for</span> (i = 0; i &lt; NUM_BARS; i++)
00407     {
00408         p = &amp;(pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o20">Dev_BARs</a>[i]);
00409         p-&gt;<a class="code" href="struct_p_c_i___dev___b_a_r.html#o6">pci_start</a> = pci_resource_start(PCI_Dev_Cfg, i);
00410         p-&gt;<a class="code" href="struct_p_c_i___dev___b_a_r.html#o7">pci_end</a>   = pci_resource_end(PCI_Dev_Cfg, i);
00411         p-&gt;<a class="code" href="struct_p_c_i___dev___b_a_r.html#o5">len</a>       = pci_resource_len(PCI_Dev_Cfg, i);
00412         p-&gt;<a class="code" href="struct_p_c_i___dev___b_a_r.html#o8">pci_flags</a> = pci_resource_flags(PCI_Dev_Cfg, i);
00413 
00414         <span class="keywordflow">if</span> ((p-&gt;<a class="code" href="struct_p_c_i___dev___b_a_r.html#o6">pci_start</a> &gt; 0) &amp;&amp; (p-&gt;<a class="code" href="struct_p_c_i___dev___b_a_r.html#o7">pci_end</a> &gt; 0))
00415         {
00416             ++(pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o21">numBars</a>);
00417             p-&gt;<a class="code" href="struct_p_c_i___dev___b_a_r.html#o0">bar</a> = i;
00418             p-&gt;<a class="code" href="struct_p_c_i___dev___b_a_r.html#o1">pci_addr</a> = (<span class="keywordtype">void</span> *)p-&gt;<a class="code" href="struct_p_c_i___dev___b_a_r.html#o6">pci_start</a>;
00419             p-&gt;<a class="code" href="struct_p_c_i___dev___b_a_r.html#o3">memType</a> = p-&gt;<a class="code" href="struct_p_c_i___dev___b_a_r.html#o8">pci_flags</a>;   <span class="comment">/* IORESOURCE Definitions: (see ioport.h)</span>
00420 <span class="comment">                              * 0x0100 = IO</span>
00421 <span class="comment">                              * 0x0200 = memory</span>
00422 <span class="comment">                              * 0x0400 = IRQ</span>
00423 <span class="comment">                              * 0x0800 = DMA</span>
00424 <span class="comment">                              * 0x1000 = PREFETCHable</span>
00425 <span class="comment">                              * 0x2000 = READONLY</span>
00426 <span class="comment">                              * 0x4000 = cacheable</span>
00427 <span class="comment">                              * 0x8000 = rangelength ???</span>
00428 <span class="comment">                              */</span>
00429             <span class="comment">/*============================================================*</span>
00430 <span class="comment">            *                                                             *</span>
00431 <span class="comment">            * Windows DDK definitions CM_PARTIAL_RESOURCE_DESCRIPTOR.Type *</span>
00432 <span class="comment">            *                                                             *</span>
00433 <span class="comment">            * #define CmResourceTypeNull                0                 *</span>
00434 <span class="comment">            * #define CmResourceTypePort                1                 *</span>
00435 <span class="comment">            * #define CmResourceTypeInterrupt           2                 *</span>
00436 <span class="comment">            * #define CmResourceTypeMemory              3                 *</span>
00437 <span class="comment">            * #define CmResourceTypeDma                 4                 *</span>
00438 <span class="comment">            * #define CmResourceTypeDeviceSpecific      5                 *</span>
00439 <span class="comment">            * #define CmResourceTypeBusNumber           6                 *</span>
00440 <span class="comment">            * #define CmResourceTypeMaximum             7                 *</span>
00441 <span class="comment">            * #define CmResourceTypeNonArbitrated     128                 *</span>
00442 <span class="comment">            * #define CmResourceTypeConfigData        128                 *</span>
00443 <span class="comment">            * #define CmResourceTypeDevicePrivate     129                 *</span>
00444 <span class="comment">            * #define CmResourceTypePcCardConfig      130                 *</span>
00445 <span class="comment">            * #define CmResourceTypeMfCardConfig      131                 *</span>
00446 <span class="comment">            *============================================================*/</span>
00447             <span class="keywordflow">if</span> (DrvrDebug)
00448             {
00449                 printk(KERN_INFO <span class="stringliteral">"lscdma: init BAR=%d\n"</span>, i);
00450                 printk(KERN_INFO <span class="stringliteral">"lscdma: init start=%lx\n"</span>, p-&gt;<a class="code" href="struct_p_c_i___dev___b_a_r.html#o6">pci_start</a>);
00451                 printk(KERN_INFO <span class="stringliteral">"lscdma: init end=%lx\n"</span>, p-&gt;<a class="code" href="struct_p_c_i___dev___b_a_r.html#o7">pci_end</a>);
00452                 printk(KERN_INFO <span class="stringliteral">"lscdma: init len=0x%lx\n"</span>, p-&gt;<a class="code" href="struct_p_c_i___dev___b_a_r.html#o5">len</a>);
00453                 printk(KERN_INFO <span class="stringliteral">"lscdma: init flags=0x%lx\n"</span>, p-&gt;<a class="code" href="struct_p_c_i___dev___b_a_r.html#o8">pci_flags</a>);
00454             }
00455         }
00456     }
00457 
00458 
00459     <span class="comment">// Map the BAR into kernel space so the driver can access registers.</span>
00460     <span class="comment">// The driver can not directly read/write the PCI physical bus address returned</span>
00461     <span class="comment">// by pci_resource_start().  In our current implementation the driver really</span>
00462     <span class="comment">// doesn't access the device registers, so this is not used.  It could be used</span>
00463     <span class="comment">// if the driver took a more active role in managing the devices on the board.</span>
00464 
00465     <span class="comment">// Map the default BAR into the driver's address space for access to LED registers,</span>
00466     <span class="comment">// masking off interrupts, and any other direct hardware controlled by the driver.</span>
00467     <span class="comment">// Note that the BAR may be different per demo.  Basic uses BAR1, SFIF &amp; SGDMA use BAR0</span>
00468     pBAR = &amp;(pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o20">Dev_BARs</a>[pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o23">ctrlBAR</a>]);
00469     <span class="keywordflow">if</span> (pBAR-&gt;<a class="code" href="struct_p_c_i___dev___b_a_r.html#o6">pci_start</a>)
00470     {
00471         pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o24">ctrlBARaddr</a> = ioremap(pBAR-&gt;<a class="code" href="struct_p_c_i___dev___b_a_r.html#o6">pci_start</a>,   <span class="comment">// PCI bus start address</span>
00472                         pBAR-&gt;<a class="code" href="struct_p_c_i___dev___b_a_r.html#o5">len</a>);    <span class="comment">// BAR size</span>
00473         pBAR-&gt;<a class="code" href="struct_p_c_i___dev___b_a_r.html#o2">kvm_addr</a> = pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o24">ctrlBARaddr</a>;  <span class="comment">// for historic reasons</span>
00474 
00475         <span class="keywordflow">if</span> (pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o24">ctrlBARaddr</a>)
00476         {
00477             <a class="code" href="lscdma_8h.html#a38">wrReg32</a>(pBrd, <a class="code" href="_devices_8h.html#a20">GPIO</a>(GPIO_LED16SEG), 0x80f3); <span class="comment">// display an 'E' for error (erased if all goes well)</span>
00478         }
00479         <span class="keywordflow">else</span> 
00480         {
00481             printk(KERN_ERR <span class="stringliteral">"lscdma: init ERROR with ioremap\n"</span>);
00482             <span class="keywordflow">return</span>(NULL);
00483         }
00484 
00485     }
00486     <span class="keywordflow">else</span>
00487     {
00488         printk(KERN_ERR <span class="stringliteral">"lscdma: init ERROR ctrlBAR %d not avail!\n"</span>, pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o23">ctrlBAR</a>);
00489         <span class="keywordflow">return</span>(NULL);
00490     }
00491 
00492 
00493 
00494     <span class="comment">// Get information about the PCIe link characteristics</span>
00495     <a class="code" href="lscdma_8h.html#a40">ParsePCIeLinkCap</a>(pBrd);
00496 
00497     <span class="comment">// Initialize the burst sizes for the DMA channels on this board</span>
00498     pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o1">WriteBurstSize</a> = pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o10">PCIeMaxPayloadSize</a>; 
00499     pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o2">ReadBurstSize</a> = pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o11">PCIeMaxReadReqSize</a>; 
00500 
00501 
00502     <span class="comment">//--------------------------------------------------------------------------</span>
00503     <span class="comment">// Verify that the hardware we're accessing has the correct IP blocks and </span>
00504     <span class="comment">// versions.  If the ID registers don't match what we expect then abort</span>
00505     <span class="comment">// becasue we don't want to take the chance of enabling interrupts but not</span>
00506     <span class="comment">// being able to control them!  or trying to program SGDMA or other registers</span>
00507     <span class="comment">// and not have the right memory map!</span>
00508     <span class="comment">//--------------------------------------------------------------------------</span>
00509 
00510     <span class="keywordflow">if</span> (<a class="code" href="lscdma_8h.html#a41">GPIO_Setup</a>(pBrd) != OK)
00511          <span class="keywordflow">return</span>(NULL);
00512 
00513     <span class="keywordflow">if</span> (<a class="code" href="lscdma_8h.html#a42">IntrCtrl_Setup</a>(pBrd) != OK)
00514          <span class="keywordflow">return</span>(NULL);
00515 
00516     <span class="keywordflow">if</span> (<a class="code" href="lscdma_8h.html#a43">SGDMA_Init</a>(pBrd) != OK)
00517          <span class="keywordflow">return</span>(NULL);
00518 
00519     pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o0">DmaOk</a> = TRUE;
00520 
00521     ++lscdma.<a class="code" href="struct_l_s_c_d_m_a.html#o1">numBoards</a>;
00522 
00523     <span class="keywordflow">return</span>(pBrd);  <span class="comment">// pointer to board found and initialized</span>
00524 
00525 }
00526 
00527 
00528 
00529 <span class="comment">/*========================================================================*/</span>
00530 <span class="comment">/*========================================================================*/</span>
00531 <span class="comment">/*========================================================================*/</span>
00532 <span class="comment">/*</span>
00533 <span class="comment"> *            DRIVER FILE OPERATIONS (OPEN, CLOSE, MMAP, IOCTL)</span>
00534 <span class="comment"> */</span>
00535 <span class="comment">/*========================================================================*/</span>
00536 <span class="comment">/*========================================================================*/</span>
00537 <span class="comment">/*========================================================================*/</span>
00538 
00539 
<a name="l00564"></a><a class="code" href="_main_8c.html#a20">00564</a> <span class="keywordtype">int</span> <a class="code" href="_main_8c.html#a20">lscdma_open</a>(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)
00565 {
00566     u32 brdNum;
00567     u32 funcNum;
00568     <a class="code" href="struct_p_c_i_e___board.html">pcie_board_t</a> *pBrd; 
00569     <span class="keywordtype">int</span> result;
00570     <span class="keywordtype">int</span> status;
00571 
00572 
00573     <span class="comment">/* Extract the board number from the minor number */</span>
00574     brdNum = LSCDMA_MINOR_TO_BOARD(iminor(inode));
00575     funcNum = LSCDMA_MINOR_TO_FUNCTION(iminor(inode));
00576 
00577     <span class="keywordflow">if</span> (DrvrDebug)
00578         printk(KERN_INFO <span class="stringliteral">"lscdma: open(): board#=%d  func#=%d\n"</span>, brdNum, funcNum);
00579 
00580     <span class="comment">/*</span>
00581 <span class="comment">     * FYI: If you want to get the filename of the device node that was opened</span>
00582 <span class="comment">     * in user space to get here, use the following pointers:</span>
00583 <span class="comment">     *  filp-&gt;f_dentry-&gt;d_name.name</span>
00584 <span class="comment">     *  filp-&gt;f_dentry-&gt;d_name.len</span>
00585 <span class="comment">     */</span>
00586 
00587 
00588     <span class="comment">/* Validate (paranoid) */</span>
00589     <span class="keywordflow">if</span> (brdNum &gt;= lscdma.<a class="code" href="struct_l_s_c_d_m_a.html#o1">numBoards</a>)
00590     {
00591             printk(KERN_ERR <span class="stringliteral">"lscdma: brd# %d No such board!\n"</span>, brdNum);
00592         <span class="keywordflow">return</span>(-ENODEV);
00593     }
00594 
00595     <span class="comment">// This is what the user wants to access</span>
00596     pBrd = &amp;lscdma.<a class="code" href="struct_l_s_c_d_m_a.html#o7">Board</a>[brdNum];
00597 
00598 
00599     <span class="keywordflow">if</span> (pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o0">ID</a> == 0)
00600     {
00601             printk(KERN_ERR <span class="stringliteral">"lscdma: brd# %d note configured correctly!\n"</span>, brdNum);
00602         <span class="keywordflow">return</span>(-ENODEV);  <span class="comment">// Board[] entry not configured correctly</span>
00603     }
00604 
00605 
00606     <span class="comment">// Take the token to Open the device.</span>
00607     <span class="comment">// This decrements the counter, that starts at 1, and returns true</span>
00608     <span class="comment">// if the count is now 0, effectively taking a semaphore.</span>
00609     <span class="comment">// Anyone else will get a false, because the count will go to -1</span>
00610     <span class="comment">// in which case we know the device is already open, so put the</span>
00611     <span class="comment">// count back to 0 and exit with busy error.</span>
00612     <span class="keywordflow">if</span> (!atomic_dec_and_test(&amp;pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o6">OpenToken</a>))
00613     {
00614             printk(KERN_ERR <span class="stringliteral">"lscdma: brd# %d already open!\n"</span>, brdNum);
00615         atomic_inc(&amp;pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o6">OpenToken</a>);  <span class="comment">// restore to prev value</span>
00616         <span class="keywordflow">return</span>(-EBUSY);
00617     }
00618 
00619 
00620     <span class="comment">/* Provide direct access to the board's resources in future system calls */</span>
00621     filp-&gt;private_data = pBrd;
00622     pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o3">function</a> = funcNum;
00623 
00624 
00625     <span class="comment">// we may want to do this to "power-up" a previously "closed" board</span>
00626     <span class="keywordflow">if</span> (pci_enable_device(pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o25">pPciDev</a>) != 0)
00627     {
00628         atomic_inc(&amp;(pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o6">OpenToken</a>));   <span class="comment">// restore to prev value</span>
00629             printk(KERN_ERR <span class="stringliteral">"lscdma: brd# %d can't enable pci device!\n"</span>, brdNum);
00630         <span class="keywordflow">return</span>(-ENODEV);  <span class="comment">// can't enable it so abort, the device is dead</span>
00631     }
00632  
00633 
00634     <span class="comment">// Enable this board to write MSI and DMA into PC system memory</span>
00635     pci_set_master(pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o25">pPciDev</a>);
00636 
00637 
00638     <span class="comment">// First thing is to disable all interrupt sources so nothing can happen during</span>
00639     <span class="comment">// connecting the ISR</span>
00640     <a class="code" href="lscdma_8h.html#a26">IsrDisableInterrupts</a>(pBrd);
00641 
00642     <a class="code" href="lscdma_8h.html#a43">SGDMA_Init</a>(pBrd);   <span class="comment">// clear out any previous SGDMA setup</span>
00643     
00644         pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o17">InterruptCounter</a> = 0;  <span class="comment">// reset for new round of interrupts</span>
00645     pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o5">ReadChanOpen</a> = <span class="keyword">false</span>;   <span class="comment">// no channels are open</span>
00646     pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o6">WriteChanOpen</a> = <span class="keyword">false</span>;   <span class="comment">// no channels are open</span>
00647 
00648     pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o16">msi</a> = <span class="keyword">false</span>;  <span class="comment">// default to no MSI, if we have support then its set to true</span>
00649 
00650 
00651 
00652 <span class="preprocessor">#ifdef MSI </span>
00653 <span class="preprocessor"></span>
00654     <span class="comment">// Connect up interrupts</span>
00655     <span class="comment">// Setup the interrupt service routine for this board</span>
00656     <span class="keywordflow">if</span> (pci_enable_msi(pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o25">pPciDev</a>) == 0) 
00657     {
00658         pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o15">IRQ</a> = pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o25">pPciDev</a>-&gt;irq;
00659 
00660         <span class="keywordflow">if</span> (DrvrDebug)
00661             printk(KERN_INFO <span class="stringliteral">"lscdma: Attach MSI interrupt\n"</span>);
00662             
00663         result = request_irq(pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o25">pPciDev</a>-&gt;irq,  <span class="comment">// the IRQ assigned to us</span>
00664 
00665 #if (LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,6,23))
00666                 (irq_handler_t)<a class="code" href="_i_s_r_8c.html#a2">lscdma_ISR</a>,       <span class="comment">// the ISR routine to invoke</span>
00667 #<span class="keywordflow">else</span>
00668                         <a class="code" href="_i_s_r_8c.html#a2">lscdma_ISR</a>,       <span class="comment">// the ISR routine to invoke</span>
00669 #endif
00670                     0,                <span class="comment">// flags - none needed for MSI</span>
00671                     <span class="stringliteral">"lscdmaMSI"</span>,      <span class="comment">// a name to show in /proc/interrupts</span>
00672                     pBrd);            <span class="comment">// arg to pass to our ISR, our board that interrutps</span>
00673                                   <span class="comment">//    must pass exact same value to free_irq()</span>
00674         <span class="keywordflow">if</span> (result)
00675         {
00676             <span class="keywordflow">if</span> (DrvrDebug)
00677                 printk(KERN_INFO <span class="stringliteral">"lscdma: can't get MSI IRQ %d\n"</span>, pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o15">IRQ</a>);
00678             pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o15">IRQ</a> = -1;
00679         }
00680         <span class="keywordflow">else</span>
00681         {
00682             pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o16">msi</a> = <span class="keyword">true</span>;
00683             <span class="keywordflow">if</span> (DrvrDebug)
00684                 printk(KERN_INFO <span class="stringliteral">"lscdma: MSI IRQ=%d\n"</span>, pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o15">IRQ</a>);
00685         }
00686 
00687     }
00688 <span class="preprocessor">#else</span>
00689 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (0)
00690     {
00691        <span class="comment">// Not using MSI, force to INTx below</span>
00692     }
00693 <span class="preprocessor">#endif</span>
00694 <span class="preprocessor"></span>    <span class="keywordflow">else</span>   <span class="comment">// Use INTx legacy interrupts</span>
00695     {
00696         <span class="keywordflow">if</span> (DrvrDebug)
00697             printk(KERN_INFO <span class="stringliteral">"lscdma: Attach INTx interrupt\n"</span>);
00698 
00699         result = request_irq(pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o25">pPciDev</a>-&gt;irq,  <span class="comment">// the IRQ assigned to us</span>
00700 #if (LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,6,23))
00701                 (irq_handler_t)<a class="code" href="_i_s_r_8c.html#a2">lscdma_ISR</a>,       <span class="comment">// the ISR routine to invoke</span>
00702                 0,   <span class="comment">// FLAGS is deprecated</span>
00703 #<span class="keywordflow">else</span>
00704                     <a class="code" href="_i_s_r_8c.html#a2">lscdma_ISR</a>,       <span class="comment">// the ISR routine to invoke</span>
00705                     SA_SHIRQ,         <span class="comment">// flags - PCI INTx are shared interrupts</span>
00706 #endif
00707                     <span class="stringliteral">"lscdmaINTx"</span>,     <span class="comment">// a name to show in /proc/interrupts</span>
00708                     pBrd);            <span class="comment">// arg to pass to our ISR, our board that interrutps</span>
00709                                   <span class="comment">//    must pass exact same value to free_irq()</span>
00710         <span class="keywordflow">if</span> (result)
00711         {
00712             <span class="keywordflow">if</span> (DrvrDebug)
00713                 printk(KERN_INFO <span class="stringliteral">"lscdma: can't get INTx IRQ %d\n"</span>, pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o15">IRQ</a>);
00714             pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o15">IRQ</a> = -1;
00715         }
00716         <span class="keywordflow">else</span>
00717         {
00718             pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o15">IRQ</a> = pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o25">pPciDev</a>-&gt;irq;
00719             <span class="keywordflow">if</span> (DrvrDebug)
00720                 printk(KERN_INFO <span class="stringliteral">"lscdma: INTx IRQ=%d\n"</span>, pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o15">IRQ</a>);
00721         }
00722     }
00723 
00724     <span class="comment">// configure the Tasklet that will handle all the real interrupt processing after the</span>
00725     <span class="comment">// ISR does the intial ackowledge and dispatches the real work </span>
00726     tasklet_init(&amp;(pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o19">isrTasklet</a>),      <span class="comment">// initialize this tasklet</span>
00727             <a class="code" href="_i_s_r_8c.html#a3">lscdma_isr_tasklet</a>,     <span class="comment">// with this function to run in thread</span>
00728             (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)pBrd);   <span class="comment">// and call it with the handle to this board</span>
00729 
00730 
00731 
00732     init_waitqueue_head(&amp;pBrd-&gt;SGDMA.ReadWaitQ);
00733     init_waitqueue_head(&amp;pBrd-&gt;SGDMA.WriteWaitQ);
00734 
00735 
00736     <span class="comment">// Determine file that was opened (based on minor #)</span>
00737     <span class="comment">//  0 = just allow plain regsiter access to any BAR</span>
00738     <span class="comment">//  1 = "ColorBars" - use DMA chan0 for writes to PC only</span>
00739     <span class="comment">//  2 = "ImgMem" - use DMA chan1 for read from PC, DMA chan0 to write back to PC</span>
00740 
00741     status = OK;
00742     <span class="keywordflow">switch</span> (iminor(inode) % MINORS_PER_BOARD)
00743     {
00744         <span class="keywordflow">case</span> 0:   
00745             <span class="keywordflow">if</span> (DrvrDebug)
00746                 printk(KERN_INFO <span class="stringliteral">"lscdma: Open for Register Access\n"</span>);
00747             <span class="keywordflow">break</span>;
00748 
00749 
00750         <span class="keywordflow">case</span> 1:
00751             <span class="comment">// ColorBars = the pixel color generating FIFO.  You can only read from</span>
00752             <span class="comment">// the device and send to PC (its a FIFO) so need the write channels.</span>
00753             <span class="keywordflow">if</span> (DrvrDebug)
00754                 printk(KERN_INFO <span class="stringliteral">"lscdma: Open for ColorBars\n"</span>);
00755 
00756             <span class="keywordflow">if</span> (!pBrd-&gt;SGDMA.WriteChanOpen)
00757             {
00758                 pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o6">WriteChanOpen</a> = <span class="keyword">true</span>;
00759                 pBrd-&gt;SGDMA.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o5">ReadChanOpen</a> = <span class="keyword">false</span>;
00760 
00761                 <span class="comment">// Initialize the device memory characteristics this channel will</span>
00762                 <span class="comment">// be accessing.  Used to program actual SGDMA BDs.</span>
00763                 pBrd-&gt;SGDMA.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o7">Chan</a>[DMA_WR_CHAN].<a class="code" href="struct_d_m_a_channel__t.html#o12">DevMem</a>.<a class="code" href="struct_dev_mem_params__t.html#o2">addrMode</a> = ADDR_MODE_FIFO;
00764                 pBrd-&gt;SGDMA.Chan[DMA_WR_CHAN].DevMem.<a class="code" href="struct_dev_mem_params__t.html#o0">baseAddr</a> = <a class="code" href="_devices_8h.html#a22">IMG_FIFO</a>(0);
00765                 pBrd-&gt;SGDMA.Chan[DMA_WR_CHAN].DevMem.<a class="code" href="struct_dev_mem_params__t.html#o1">dataWidth</a> = DATA_64BIT;
00766                 pBrd-&gt;SGDMA.Chan[DMA_WR_CHAN].DevMem.<a class="code" href="struct_dev_mem_params__t.html#o3">maxAddrRange</a> = IMG_FIFO_FRAME_SIZE;
00767 
00768                 <span class="comment">// Configure the SGDMA channel(s) needed by this device</span>
00769                 pBrd-&gt;SGDMA.Chan[DMA_WR_CHAN].numBDs = <a class="code" href="_devices_8h.html#a25">IMG_FIFO_FRAME_SIZE</a> / PAGE_SIZE;
00770                 pBrd-&gt;SGDMA.Chan[DMA_WR_CHAN].startBD = 0;
00771 
00772                 sema_init(&amp;pBrd-&gt;SGDMA.Chan[DMA_WR_CHAN].dmaMutex, 1);  <span class="comment">// initialize for single access</span>
00773             }
00774             <span class="keywordflow">else</span>
00775             {
00776                 status = -EBUSY;
00777             }
00778             <span class="keywordflow">break</span>;
00779 
00780         <span class="keywordflow">case</span> 2:
00781             <span class="comment">// ImgMem = the Image Memory device (EBR + pixel filter).  You can read and write to</span>
00782             <span class="comment">// the device (its linear memory) so need both DMA channels.</span>
00783             <span class="keywordflow">if</span> (DrvrDebug)
00784                 printk(KERN_INFO <span class="stringliteral">"lscdma: Open for ImageMove\n"</span>);
00785 
00786             <span class="keywordflow">if</span> (!pBrd-&gt;SGDMA.ReadChanOpen &amp;&amp; !pBrd-&gt;SGDMA.WriteChanOpen )
00787             {
00788                 pBrd-&gt;SGDMA.WriteChanOpen = <span class="keyword">true</span>;
00789                 pBrd-&gt;SGDMA.ReadChanOpen = <span class="keyword">true</span>;
00790 
00791                 <span class="comment">// Initialize the device memory characteristics the channels will</span>
00792                 <span class="comment">// be accessing.  Used to program actual SGDMA BDs.</span>
00793                 pBrd-&gt;SGDMA.Chan[DMA_WR_CHAN].DevMem.<a class="code" href="struct_dev_mem_params__t.html#o2">addrMode</a> = ADDR_MODE_MEM;
00794                 pBrd-&gt;SGDMA.Chan[DMA_WR_CHAN].DevMem.<a class="code" href="struct_dev_mem_params__t.html#o0">baseAddr</a> = <a class="code" href="_devices_8h.html#a23">EBR_64</a>(0);
00795                 pBrd-&gt;SGDMA.Chan[DMA_WR_CHAN].DevMem.<a class="code" href="struct_dev_mem_params__t.html#o1">dataWidth</a> = DATA_64BIT;
00796                 pBrd-&gt;SGDMA.Chan[DMA_WR_CHAN].DevMem.<a class="code" href="struct_dev_mem_params__t.html#o3">maxAddrRange</a> = EBR64_SIZE;
00797                 pBrd-&gt;SGDMA.Chan[DMA_RD_CHAN].DevMem.<a class="code" href="struct_dev_mem_params__t.html#o2">addrMode</a> = ADDR_MODE_MEM;
00798                 pBrd-&gt;SGDMA.Chan[DMA_RD_CHAN].DevMem.<a class="code" href="struct_dev_mem_params__t.html#o0">baseAddr</a> = <a class="code" href="_devices_8h.html#a23">EBR_64</a>(0);
00799                 pBrd-&gt;SGDMA.Chan[DMA_RD_CHAN].DevMem.<a class="code" href="struct_dev_mem_params__t.html#o1">dataWidth</a> = DATA_64BIT;
00800                 pBrd-&gt;SGDMA.Chan[DMA_RD_CHAN].DevMem.<a class="code" href="struct_dev_mem_params__t.html#o3">maxAddrRange</a> = EBR64_SIZE;
00801 
00802 
00803                 <span class="comment">// Configure the SGDMA channel(s) needed by this device</span>
00804                 pBrd-&gt;SGDMA.Chan[DMA_WR_CHAN].numBDs = <a class="code" href="_devices_8h.html#a24">EBR64_SIZE</a> / PAGE_SIZE;
00805                 pBrd-&gt;SGDMA.Chan[DMA_WR_CHAN].startBD = 0;
00806                 pBrd-&gt;SGDMA.Chan[DMA_RD_CHAN].numBDs = <a class="code" href="_devices_8h.html#a24">EBR64_SIZE</a> / PAGE_SIZE;
00807                 pBrd-&gt;SGDMA.Chan[DMA_RD_CHAN].startBD = <a class="code" href="_devices_8h.html#a24">EBR64_SIZE</a> / PAGE_SIZE;  <span class="comment">// put after writes</span>
00808 
00809                 sema_init(&amp;pBrd-&gt;SGDMA.Chan[DMA_RD_CHAN].dmaMutex, 1);  <span class="comment">// initialize for single access</span>
00810                 sema_init(&amp;pBrd-&gt;SGDMA.Chan[DMA_WR_CHAN].dmaMutex, 1);  <span class="comment">// initialize for single access</span>
00811             }
00812             <span class="keywordflow">else</span>
00813             {
00814                 status = -EBUSY;
00815             }
00816             <span class="keywordflow">break</span>;
00817 
00818         <span class="keywordflow">default</span>:
00819             status = -ENODEV;
00820             <span class="keywordflow">break</span>;
00821 
00822     }
00823 
00824     <span class="keywordflow">if</span> (status != OK)
00825     {
00826         printk(KERN_ERR <span class="stringliteral">"lscdma: ERROR Opening = %d\n"</span>, status);
00827         atomic_inc(&amp;(pBrd-&gt;OpenToken));   <span class="comment">// restore to prev value cause we didn't open it</span>
00828     }
00829     <span class="keywordflow">else</span>
00830     {
00831         <span class="comment">// Write an 'O' to the LEDs to signal its opened</span>
00832         <a class="code" href="lscdma_8h.html#a38">wrReg32</a>(pBrd, <a class="code" href="_devices_8h.html#a20">GPIO</a>(GPIO_LED16SEG), 0x00ff);   <span class="comment">// display an 'O' </span>
00833 
00834         <span class="comment">// Enable interrupts</span>
00835         <span class="keywordflow">if</span> (pBrd-&gt;IRQ != -1)
00836             <a class="code" href="lscdma_8h.html#a25">IsrEnableInterrupts</a>(pBrd);
00837     }
00838 
00839 
00840     <span class="keywordflow">return</span>(status);
00841 }
00842 
00843 
<a name="l00848"></a><a class="code" href="_main_8c.html#a21">00848</a> <span class="keywordtype">int</span> <a class="code" href="_main_8c.html#a21">lscdma_release</a>(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)
00849 {
00850     <span class="keyword">struct </span><a class="code" href="struct_p_c_i_e___board.html">PCIE_Board</a> *pBrd = filp-&gt;private_data;
00851 
00852     u32 mnr = iminor(inode);
00853 
00854     <span class="keywordflow">if</span> (DrvrDebug)
00855         printk(KERN_INFO <span class="stringliteral">"lscdma: close() - closing board=%d  function=%x\n"</span>, 
00856                 LSCDMA_MINOR_TO_BOARD(mnr), LSCDMA_MINOR_TO_FUNCTION(mnr));
00857 
00858 
00859 
00860 <span class="comment">// TODO - Can this really happen?  Can we get here without having had the device close?</span>
00861 <span class="comment">//  Is this possible in Linux?</span>
00863 <span class="comment"></span>    <span class="comment">// I want to make sure that there is no DMA still occurring because this</span>
00864     <span class="comment">// brd is going away and catastrophe will result if the DMA is writing to</span>
00865     <span class="comment">// this user's memory pages and using the brd data structures.</span>
00867 <span class="comment"></span>    <span class="keywordflow">if</span> (pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o3">Reading</a>)
00868     {
00869         <span class="comment">// cancel the DMA</span>
00870         pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o7">Chan</a>[DMA_RD_CHAN].<a class="code" href="struct_d_m_a_channel__t.html#o2">cancelDMA</a> = TRUE;
00871 
00872         <a class="code" href="lscdma_8h.html#a46">SGDMA_DisableChan</a>(pBrd, DMA_RD_CHAN);   <span class="comment">// cancel this cause we don't want DMA writing anymore</span>
00873         udelay(10);   <span class="comment">// make sure SGDMA is done before continuing and releasing memory</span>
00874     }
00875     
00876     <span class="keywordflow">if</span> (pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o4">Writing</a>)
00877     {
00878         <span class="comment">// cancel the DMA</span>
00879         pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o7">Chan</a>[DMA_WR_CHAN].<a class="code" href="struct_d_m_a_channel__t.html#o2">cancelDMA</a> = TRUE;
00880 
00881         <a class="code" href="lscdma_8h.html#a46">SGDMA_DisableChan</a>(pBrd, DMA_WR_CHAN);   <span class="comment">// cancel this cause we don't want DMA writing anymore</span>
00882         udelay(10);   <span class="comment">// make sure SGDMA is done before continuing and releasing memory</span>
00883     }
00884 
00885 
00886 
00887     <span class="comment">// Disable and release the interrupts</span>
00888     <a class="code" href="lscdma_8h.html#a26">IsrDisableInterrupts</a>(pBrd);
00889 
00890     <span class="keywordflow">if</span> (pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o15">IRQ</a> != -1)
00891     {
00892         <span class="keywordflow">if</span> (DrvrDebug)
00893             printk(KERN_INFO <span class="stringliteral">"lscdma: close() - free_irq %d\n"</span>, pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o15">IRQ</a>);
00894         free_irq(pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o15">IRQ</a>, pBrd);  <span class="comment">// call first</span>
00895 
00896 <span class="preprocessor">#ifdef MSI </span>
00897 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o16">msi</a>)
00898             pci_disable_msi(pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o25">pPciDev</a>);  <span class="comment">// call second if MSI was used</span>
00899 <span class="preprocessor">#endif</span>
00900 <span class="preprocessor"></span>    }
00901 
00902         pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o15">IRQ</a> = -1;
00903     pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o16">msi</a> = <span class="keyword">false</span>;
00904 
00905     pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o3">Reading</a> = <span class="keyword">false</span>;
00906     pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o4">Writing</a> = <span class="keyword">false</span>;
00907     pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o5">ReadChanOpen</a> = <span class="keyword">false</span>;
00908     pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o6">WriteChanOpen</a> = <span class="keyword">false</span>;
00909 
00910     <span class="comment">// Write a 'C' to the LEDs to signal its closed</span>
00911     <a class="code" href="lscdma_8h.html#a38">wrReg32</a>(pBrd, <a class="code" href="_devices_8h.html#a20">GPIO</a>(GPIO_LED16SEG), 0x00f3);   <span class="comment">// display a 'C' </span>
00912 
00913     pci_disable_device(pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o25">pPciDev</a>);  <span class="comment">// we may want to do this to "power-down" the board</span>
00914 
00915     <span class="comment">// Give back the token and let someone else open the board</span>
00916     atomic_inc(&amp;(pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o6">OpenToken</a>));
00917 
00918     <span class="keywordflow">return</span>(0);
00919 }
00920 
00921 
00922 
<a name="l00929"></a><a class="code" href="_main_8c.html#a22">00929</a> <span class="keywordtype">int</span> <a class="code" href="_main_8c.html#a22">lscdma_ioctl</a>(<span class="keyword">struct</span> inode *inode, 
00930           <span class="keyword">struct</span> file *filp,
00931           <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cmd,
00932           <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> arg)
00933 {
00934     <span class="keywordtype">int</span> i;
00935     <span class="keywordtype">int</span> status = OK;
00936     <span class="keywordtype">int</span> mnr = iminor(inode);
00937     <a class="code" href="struct_p_c_i_e___board.html">pcie_board_t</a> *pBrd = NULL; 
00938     <a class="code" href="struct_p_c_i_resource_info__t.html">PCIResourceInfo_t</a> *pInfo;
00939     <a class="code" href="struct_d_m_a_resource_info__t.html">DMAResourceInfo_t</a> *pDmaInfo;
00940 
00941     <span class="keywordflow">if</span> (DrvrDebug)
00942         printk(KERN_INFO <span class="stringliteral">"lscdma: ioctl(minor=%d cmd=%d arg=%lx size=%d)\n"</span>, 
00943                         mnr, _IOC_NR(cmd), arg, _IOC_SIZE(cmd));
00944 
00945     <span class="keywordflow">if</span> (_IOC_TYPE(cmd) != LSCPCIE_MAGIC)
00946         <span class="keywordflow">return</span>(-EINVAL);
00947     <span class="keywordflow">if</span> (_IOC_NR(cmd) &gt; IOCTL_LSCDMA_MAX_NR)
00948         <span class="keywordflow">return</span>(-EINVAL);
00949 
00950     pBrd = filp-&gt;private_data;
00951 
00952     <span class="keywordflow">switch</span> (cmd)
00953     {
00954 
00955         <span class="keywordflow">case</span> <a class="code" href="_ioctl_8h.html#a4">IOCTL_LSCPCIE_GET_VERSION_INFO</a>:
00956             <span class="comment">// first make sure the pointer passed in arg is still valid user page</span>
00957             <span class="keywordflow">if</span> (!access_ok(VERIFY_WRITE, (<span class="keywordtype">void</span> *)arg, _IOC_SIZE(cmd)))
00958             {
00959                 status = -EFAULT;
00960                 <span class="keywordflow">break</span>;  <span class="comment">// abort</span>
00961             }
00962 
00963             pInfo = kmalloc(<span class="keyword">sizeof</span>(MAX_DRIVER_VERSION_LEN ), GFP_KERNEL);
00964             <span class="keywordflow">if</span> (pInfo == NULL)
00965             {
00966                 status = -EFAULT;
00967                 <span class="keywordflow">break</span>;  <span class="comment">// abort</span>
00968             }
00969 
00970 
00971             strncpy((<span class="keywordtype">void</span> *)arg, Version, MAX_DRIVER_VERSION_LEN - 1);
00972             kfree(pInfo);  <span class="comment">// release kernel temp buffer</span>
00973 
00974             <span class="keywordflow">break</span>;
00975 
00976         <span class="keywordflow">case</span> <a class="code" href="_ioctl_8h.html#a6">IOCTL_LSCPCIE_SET_BAR</a>:
00977             <span class="comment">// The argument passed in is the direct BAR number (0-5) to use for mmap</span>
00978             pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o22">mmapBAR</a> = arg;
00979             <span class="keywordflow">break</span>;
00980 
00981 
00982         <span class="keywordflow">case</span> <a class="code" href="_ioctl_8h.html#a5">IOCTL_LSCPCIE_GET_RESOURCES</a>:
00983             <span class="comment">// first make sure the pointer passed in arg is still valid user page</span>
00984             <span class="keywordflow">if</span> (!access_ok(VERIFY_WRITE, (<span class="keywordtype">void</span> *)arg, _IOC_SIZE(cmd)))
00985             {
00986                 status = -EFAULT;
00987                 <span class="keywordflow">break</span>;  <span class="comment">// abort</span>
00988             }
00989 
00990             pInfo = kmalloc(<span class="keyword">sizeof</span>(<a class="code" href="struct_p_c_i_resource_info__t.html">PCIResourceInfo_t</a>), GFP_KERNEL);
00991             <span class="keywordflow">if</span> (pInfo == NULL)
00992             {
00993                 status = -EFAULT;
00994                 <span class="keywordflow">break</span>;  <span class="comment">// abort</span>
00995             }
00996 
00997             <span class="keywordflow">if</span> (pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o15">IRQ</a> &gt; 0)
00998                 pInfo-&gt;<a class="code" href="struct_p_c_i_resource_info__t.html#o3">hasInterrupt</a> = TRUE;
00999             <span class="keywordflow">else</span>
01000                 pInfo-&gt;<a class="code" href="struct_p_c_i_resource_info__t.html#o3">hasInterrupt</a> = FALSE;
01001             pInfo-&gt;<a class="code" href="struct_p_c_i_resource_info__t.html#o4">intrVector</a> = pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o15">IRQ</a>;
01002             pInfo-&gt;<a class="code" href="struct_p_c_i_resource_info__t.html#o0">numBARs</a> = pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o21">numBars</a>;
01003             <span class="keywordflow">for</span> (i = 0; i &lt; MAX_PCI_BARS; i++)
01004             {
01005                 pInfo-&gt;<a class="code" href="struct_p_c_i_resource_info__t.html#o1">BAR</a>[i].<a class="code" href="struct_p_c_i___b_a_r__t.html#o0">nBAR</a> = pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o20">Dev_BARs</a>[i].<a class="code" href="struct_p_c_i___dev___b_a_r.html#o0">bar</a>;
01006                 pInfo-&gt;<a class="code" href="struct_p_c_i_resource_info__t.html#o1">BAR</a>[i].<a class="code" href="struct_p_c_i___b_a_r__t.html#o1">physStartAddr</a> = (ULONG)pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o20">Dev_BARs</a>[i].<a class="code" href="struct_p_c_i___dev___b_a_r.html#o1">pci_addr</a>;
01007                 pInfo-&gt;<a class="code" href="struct_p_c_i_resource_info__t.html#o1">BAR</a>[i].<a class="code" href="struct_p_c_i___b_a_r__t.html#o2">size</a> = pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o20">Dev_BARs</a>[i].<a class="code" href="struct_p_c_i___dev___b_a_r.html#o5">len</a>;
01008                 pInfo-&gt;<a class="code" href="struct_p_c_i_resource_info__t.html#o1">BAR</a>[i].<a class="code" href="struct_p_c_i___b_a_r__t.html#o3">memMapped</a> = (pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o20">Dev_BARs</a>[i].<a class="code" href="struct_p_c_i___dev___b_a_r.html#o2">kvm_addr</a>) ? 1 : 0;
01009                 pInfo-&gt;<a class="code" href="struct_p_c_i_resource_info__t.html#o1">BAR</a>[i].<a class="code" href="struct_p_c_i___b_a_r__t.html#o4">flags</a> = (USHORT)(pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o20">Dev_BARs</a>[i].<a class="code" href="struct_p_c_i___dev___b_a_r.html#o8">pci_flags</a>);
01010                 pInfo-&gt;<a class="code" href="struct_p_c_i_resource_info__t.html#o1">BAR</a>[i].<a class="code" href="struct_p_c_i___b_a_r__t.html#o5">type</a> = (UCHAR)((pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o20">Dev_BARs</a>[i].<a class="code" href="struct_p_c_i___dev___b_a_r.html#o3">memType</a>)&gt;&gt;8);  <span class="comment">// get the bits that show IO or mem</span>
01011             }
01012             <span class="keywordflow">for</span> (i = 0; i &lt; 0x100; ++i)
01013                 pci_read_config_byte(pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o25">pPciDev</a>, i, &amp;(pInfo-&gt;<a class="code" href="struct_p_c_i_resource_info__t.html#o2">PCICfgReg</a>[i]));
01014 
01015             <span class="keywordflow">if</span> (copy_to_user((<span class="keywordtype">void</span> *)arg, (<span class="keywordtype">void</span> *)pInfo, <span class="keyword">sizeof</span>(PCIResourceInfo_t)) != 0)
01016                 status = -EFAULT; <span class="comment">// Not all bytes were copied so this is an error</span>
01017             kfree(pInfo);  <span class="comment">// release kernel temp buffer</span>
01018 
01019             <span class="keywordflow">break</span>;
01020 
01021 
01022         <span class="keywordflow">case</span> <a class="code" href="_ioctl_8h.html#a11">IOCTL_LSCDMA_GET_DMA_INFO</a>:
01023             <span class="comment">// first make sure the pointer passed in arg is still valid user page</span>
01024             <span class="keywordflow">if</span> (!access_ok(VERIFY_WRITE, (<span class="keywordtype">void</span> *)arg, _IOC_SIZE(cmd)))
01025             {
01026                 status = -EFAULT;
01027                 <span class="keywordflow">break</span>;  <span class="comment">// abort</span>
01028             }
01029 
01030             pDmaInfo = kmalloc(<span class="keyword">sizeof</span>(<a class="code" href="struct_d_m_a_resource_info__t.html">DMAResourceInfo_t</a>), GFP_KERNEL);
01031             <span class="keywordflow">if</span> (pDmaInfo == NULL)
01032             {
01033                 status = -EFAULT;
01034                 <span class="keywordflow">break</span>;  <span class="comment">// abort</span>
01035             }
01036 
01037             pDmaInfo-&gt;<a class="code" href="struct_d_m_a_resource_info__t.html#o0">devID</a> = pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o9">minorNum</a>;     <span class="comment">// board number of specific device</span>
01038 
01039             pDmaInfo-&gt;<a class="code" href="struct_d_m_a_resource_info__t.html#o1">busNum</a> = pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o25">pPciDev</a>-&gt;bus-&gt;number;  <span class="comment">// PCI bus number board located on</span>
01040             pDmaInfo-&gt;<a class="code" href="struct_d_m_a_resource_info__t.html#o2">deviceNum</a> = PCI_SLOT(pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o25">pPciDev</a>-&gt;devfn);     <span class="comment">// PCI device number assigned to board</span>
01041             pDmaInfo-&gt;<a class="code" href="struct_d_m_a_resource_info__t.html#o3">functionNum</a> = PCI_FUNC(pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o25">pPciDev</a>-&gt;devfn);   <span class="comment">// our function number</span>
01042             pDmaInfo-&gt;<a class="code" href="struct_d_m_a_resource_info__t.html#o4">UINumber</a> = pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o9">minorNum</a>;      <span class="comment">// slot number (not implemented) </span>
01043 
01044             <span class="comment">// Device DMA Common buffer memory info</span>
01045             pDmaInfo-&gt;<a class="code" href="struct_d_m_a_resource_info__t.html#o5">hasDmaBuf</a> = pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o28">CBDMA</a>.<a class="code" href="struct_c_b_d_m_a_operations__t.html#o0">hasDMA</a>;        <span class="comment">// true if DMA buffer has been allocated by driver </span>
01046             pDmaInfo-&gt;<a class="code" href="struct_d_m_a_resource_info__t.html#o6">DmaBufSize</a> = pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o28">CBDMA</a>.<a class="code" href="struct_c_b_d_m_a_operations__t.html#o2">dmaBufSize</a>;   <span class="comment">// size in bytes of said buffer </span>
01047             pDmaInfo-&gt;<a class="code" href="struct_d_m_a_resource_info__t.html#o7">DmaAddr64</a> = 0;      <span class="comment">// driver only asks for 32 bit, SGDMA only supports 32 bit </span>
01048             pDmaInfo-&gt;<a class="code" href="struct_d_m_a_resource_info__t.html#o8">DmaPhyAddrHi</a> = 0;    <span class="comment">// not used, only 32 bit</span>
01049             pDmaInfo-&gt;<a class="code" href="struct_d_m_a_resource_info__t.html#o9">DmaPhyAddrLo</a> = pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o28">CBDMA</a>.<a class="code" href="struct_c_b_d_m_a_operations__t.html#o3">dmaPCIBusAddr</a>;    <span class="comment">// DMA bus address to be programmed into device </span>
01050 
01051             <span class="comment">// Info obtained from the PCIeCap Cfg Reg of the Link</span>
01052             pDmaInfo-&gt;<a class="code" href="struct_d_m_a_resource_info__t.html#o10">MaxPayloadSize</a> = pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o10">PCIeMaxPayloadSize</a>;
01053             pDmaInfo-&gt;<a class="code" href="struct_d_m_a_resource_info__t.html#o11">MaxReadReqSize</a> = pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o11">PCIeMaxReadReqSize</a>;
01054             pDmaInfo-&gt;<a class="code" href="struct_d_m_a_resource_info__t.html#o12">RCBSize</a> = pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o12">PCIeRCBSize</a>;
01055             pDmaInfo-&gt;<a class="code" href="struct_d_m_a_resource_info__t.html#o13">LinkWidth</a> = pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o13">PCIeLinkWidth</a>;
01056 
01057             <span class="keywordflow">if</span> (copy_to_user((<span class="keywordtype">void</span> *)arg, (<span class="keywordtype">void</span> *)pDmaInfo, <span class="keyword">sizeof</span>(DMAResourceInfo_t)) != 0)
01058                 status = -EFAULT; <span class="comment">// Not all bytes were copied so this is an error</span>
01059             kfree(pDmaInfo);  <span class="comment">// release kernel temp buffer</span>
01060 
01061             <span class="keywordflow">break</span>;
01062 
01063 
01064         <span class="keywordflow">case</span> <a class="code" href="_ioctl_8h.html#a7">IOCTL_LSCDMA_READ_SYSDMABUF</a>:
01065             <span class="keywordflow">if</span> (DrvrDebug)
01066                 printk(KERN_INFO <span class="stringliteral">"lscdma: ioctl read_sysdma\n"</span>);
01067 
01068             <span class="keywordflow">if</span> (!access_ok(VERIFY_WRITE, (<span class="keywordtype">void</span> *)arg, pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o28">CBDMA</a>.<a class="code" href="struct_c_b_d_m_a_operations__t.html#o2">dmaBufSize</a>))
01069             {
01070                 status = -EFAULT;
01071                 <span class="keywordflow">break</span>;  <span class="comment">// abort</span>
01072             }
01073 
01074             <span class="keywordflow">if</span> (!pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o28">CBDMA</a>.<a class="code" href="struct_c_b_d_m_a_operations__t.html#o0">hasDMA</a>)
01075             {
01076                 status = -EINVAL;   <span class="comment">// invalid, no DMA buffer allocated</span>
01077                 <span class="keywordflow">break</span>;
01078             }
01079 
01080             <span class="comment">// Send the whole buffer over to the DriverIF API and let user space decide if</span>
01081             <span class="comment">// they only want a small chunk of it.</span>
01082             <span class="keywordflow">if</span> (copy_to_user((<span class="keywordtype">void</span> *)arg, pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o28">CBDMA</a>.<a class="code" href="struct_c_b_d_m_a_operations__t.html#o4">dmaCPUAddr</a>, pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o28">CBDMA</a>.<a class="code" href="struct_c_b_d_m_a_operations__t.html#o2">dmaBufSize</a>) != 0)
01083                 <span class="keywordflow">return</span>(-EFAULT);
01084             <span class="keywordflow">break</span>;
01085 
01086 
01087         <span class="keywordflow">case</span> <a class="code" href="_ioctl_8h.html#a8">IOCTL_LSCDMA_WRITE_SYSDMABUF</a>:
01088             <span class="keywordflow">if</span> (DrvrDebug)
01089                 printk(KERN_INFO <span class="stringliteral">"lscdma: ioctl write_sysdma\n"</span>);
01090 
01091             <span class="keywordflow">if</span> (!access_ok(VERIFY_READ, (<span class="keywordtype">void</span> *)arg, pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o28">CBDMA</a>.<a class="code" href="struct_c_b_d_m_a_operations__t.html#o2">dmaBufSize</a>))
01092             {
01093                 status = -EFAULT;
01094                 <span class="keywordflow">break</span>;  <span class="comment">// abort</span>
01095             }
01096 
01097             <span class="keywordflow">if</span> (!pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o28">CBDMA</a>.<a class="code" href="struct_c_b_d_m_a_operations__t.html#o0">hasDMA</a>)
01098             {
01099                 status = -EINVAL;   <span class="comment">// invalid, no DMA buffer allocated</span>
01100                 <span class="keywordflow">break</span>;
01101             }
01102 
01103             <span class="comment">// Read the whole buffer from user space DriverIF API. </span>
01104             <span class="comment">// Maybe only small chunk of it is modified, but its user's call.</span>
01105             <span class="keywordflow">if</span> (copy_from_user(pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o28">CBDMA</a>.<a class="code" href="struct_c_b_d_m_a_operations__t.html#o4">dmaCPUAddr</a>, (<span class="keywordtype">void</span> *)arg,  pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o28">CBDMA</a>.<a class="code" href="struct_c_b_d_m_a_operations__t.html#o2">dmaBufSize</a>) != 0)
01106                 <span class="keywordflow">return</span>(-EFAULT);
01107             <span class="keywordflow">break</span>;
01108 
01109         <span class="keywordflow">case</span> <a class="code" href="_ioctl_8h.html#a9">IOCTL_LSCDMA_GET_DMA_TIMERS</a>:
01110             printk(KERN_ERR <span class="stringliteral">"lscdma: ioctl unsupported IOCTL_LSCDMA_GET_DMA_TIMERS\n"</span>);
01111             status = -EINVAL;
01112             <span class="keywordflow">break</span>;
01113 
01114         <span class="keywordflow">case</span> <a class="code" href="_ioctl_8h.html#a10">IOCTL_LSCDMA_SET_BURST_SIZES</a>:
01115             printk(KERN_ERR <span class="stringliteral">"lscdma: ioctl unsupported IOCTL_LSCDMA_SET_BURST_SIZES\n"</span>);
01116             status = -EINVAL;
01117             <span class="keywordflow">break</span>;
01118 
01119         <span class="keywordflow">default</span>:
01120             status = -EINVAL;   <span class="comment">// invalid IOCTL argument</span>
01121     }
01122 
01123     <span class="keywordflow">return</span>(status);
01124 }
01125 
01126 
<a name="l01133"></a><a class="code" href="_main_8c.html#a23">01133</a> <span class="keywordtype">int</span> <a class="code" href="_main_8c.html#a23">lscdma_mmap</a>(<span class="keyword">struct</span> file *filp,
01134                  <span class="keyword">struct</span> vm_area_struct *vma)
01135 {
01136     <span class="keywordtype">int</span> num;
01137     <span class="keywordtype">int</span> sysErr;
01138     <a class="code" href="struct_p_c_i_e___board.html">pcie_board_t</a> *pBrd = filp-&gt;private_data;
01139     <a class="code" href="struct_p_c_i___dev___b_a_r.html">pci_dev_bar_t</a> *pBAR;
01140     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> phys_start;    <span class="comment">/* starting address to map */</span>
01141     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> mapSize;          <span class="comment">/* requested size to map */</span>
01142     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> offset;        <span class="comment">/* how far into window to start map */</span>
01143 
01144     <span class="comment">// Map the BAR of the board, specified by mmapBAR (normally the default one that the</span>
01145     <span class="comment">// demo supports - normally only one valid BAR in our demos)</span>
01146     pBAR = &amp;(pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o20">Dev_BARs</a>[pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o22">mmapBAR</a>]);
01147 
01148     mapSize = vma-&gt;vm_end - vma-&gt;vm_start;
01149     offset = vma-&gt;vm_pgoff &lt;&lt; PAGE_SHIFT;
01150 
01151     num = pBAR-&gt;<a class="code" href="struct_p_c_i___dev___b_a_r.html#o0">bar</a>;  <span class="comment">// this is a check to make sure we really initialized the BAR and structures</span>
01152 
01153     <span class="keywordflow">if</span> (DrvrDebug)
01154         printk(KERN_INFO <span class="stringliteral">"lscdma: mmap Board=%d  BAR=%d\n"</span>, pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o9">minorNum</a>, num);
01155 
01156     <span class="keywordflow">if</span> (num == -1)
01157         <span class="keywordflow">return</span>(-ENOMEM);   <span class="comment">/* BAR not activated, no memory */</span>
01158 
01159     <span class="keywordflow">if</span> (mapSize &gt; pBAR-&gt;<a class="code" href="struct_p_c_i___dev___b_a_r.html#o5">len</a>)
01160         <span class="keywordflow">return</span>(-EINVAL);  <span class="comment">/* asked for too much memory. */</span>
01161 
01162     <span class="comment">/* Calculate the starting address, based on the offset passed by user */</span>
01163     phys_start = (<span class="keywordtype">unsigned</span> long)(pBAR-&gt;<a class="code" href="struct_p_c_i___dev___b_a_r.html#o1">pci_addr</a>) + offset;
01164 
01165     <span class="keywordflow">if</span> (DrvrDebug)
01166     {
01167         printk(KERN_INFO <span class="stringliteral">"lscdma: remap_page_range(0x%lx, 0x%x, %d, ...)\n"</span>,
01168            vma-&gt;vm_start, (uint32_t)phys_start, (uint32_t)mapSize);
01169     }
01170 
01171     <span class="comment">/* Make sure the memory is treated as uncached, non-swap device memory */</span>
01172     vma-&gt;vm_flags = vma-&gt;vm_flags | VM_LOCKED | VM_IO | VM_RESERVED;
01173 
01174 <span class="preprocessor">#if (LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,6,10))</span>
01175 <span class="preprocessor"></span>    <span class="comment">/* Do the page mapping the new 2.6.10+ way */</span>
01176     sysErr = remap_pfn_range(vma,
01177                   (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)vma-&gt;vm_start,
01178                   (phys_start&gt;&gt;PAGE_SHIFT),
01179                   mapSize,
01180                   vma-&gt;vm_page_prot);
01181 
01182 <span class="preprocessor">#elif (LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,6,8))</span>
01183 <span class="preprocessor"></span>    <span class="comment">/* Do the page mapping the intermediate way */</span>
01184     sysErr = remap_page_range(vma,
01185                   (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)vma-&gt;vm_start,
01186                   phys_start,
01187                   mapSize,
01188                   vma-&gt;vm_page_prot);
01189 <span class="preprocessor">#else</span>
01190 <span class="preprocessor"></span><span class="preprocessor">    #error Unsupported kernel version!!!!</span>
01191 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
01192 <span class="preprocessor"></span>
01193 
01194     <span class="keywordflow">if</span> (sysErr &lt; 0)
01195     {
01196         printk(KERN_ERR <span class="stringliteral">"lscdma: remap_page_range() failed!\n"</span>);
01197         <span class="keywordflow">return</span>(-EAGAIN);
01198     }
01199 
01200     <span class="keywordflow">return</span>(0);
01201 }
01202 
01203 
01204 
01205 
<a name="l01211"></a><a class="code" href="_main_8c.html#a24">01211</a> ssize_t <a class="code" href="_main_8c.html#a24">lscdma_read</a>(<span class="keyword">struct</span> file *filp,
01212             <span class="keywordtype">char</span> __user *userBuf,
01213             size_t len,
01214             loff_t *offp)
01215 {
01216     <span class="keywordtype">int</span> ret;
01217     <a class="code" href="struct_p_c_i_e___board.html">pcie_board_t</a> *pBrd = filp-&gt;private_data;
01218     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> irqFlag;
01219 
01220     ret = -1;
01221 
01222     <span class="keywordflow">if</span> (DrvrDebug)
01223         printk(KERN_INFO <span class="stringliteral">"lscdma: read len=%d  userAddr=%p\n"</span>, (u32)len, userBuf);
01224 
01225     <span class="keywordflow">if</span> (pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o3">function</a> == MEM_ACCESS_NUM)
01226         <span class="keywordflow">return</span>(-ENODEV);  <span class="comment">// read only allowed for DMA channels</span>
01227 
01228 
01229     <span class="comment">// Try to take the Mutex Semaphore</span>
01230     <span class="comment">// Only one DMA operation can proceed at a time so this blocks the caller if there</span>
01231     <span class="comment">// is something already transferring.</span>
01232     <span class="keywordflow">if</span> (down_interruptible(&amp;pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o7">Chan</a>[DMA_WR_CHAN].<a class="code" href="struct_d_m_a_channel__t.html#o0">dmaMutex</a>))
01233         <span class="keywordflow">return</span>(-ERESTARTSYS);
01234 
01235 
01236     <span class="comment">// This only operates on the Write channel and no one else can be using it now</span>
01237     <span class="comment">// (locked by semaphore) so no need to grab spin_lock</span>
01238     ret = <a class="code" href="lscdma_8h.html#a31">initDMAChan</a>(pBrd,
01239             &amp;pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o7">Chan</a>[DMA_WR_CHAN],  <span class="comment">// write channel</span>
01240             (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)userBuf,
01241             len,
01242             PCI_DMA_FROMDEVICE);
01243 
01244     <span class="keywordflow">if</span> (ret != OK)
01245     {
01246         up(&amp;pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o7">Chan</a>[DMA_WR_CHAN].<a class="code" href="struct_d_m_a_channel__t.html#o0">dmaMutex</a>);
01247         <span class="keywordflow">return</span>(ret);   <span class="comment">// error occurred setting up the DMA operation into user space</span>
01248     }
01249 
01250     <span class="comment">// Initialize DMA transfer state variables</span>
01251     pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o3">Reading</a> = TRUE;
01252     pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o7">Chan</a>[DMA_WR_CHAN].<a class="code" href="struct_d_m_a_channel__t.html#o1">doneDMA</a> = FALSE;
01253     pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o7">Chan</a>[DMA_WR_CHAN].<a class="code" href="struct_d_m_a_channel__t.html#o2">cancelDMA</a> = FALSE;
01254     pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o7">Chan</a>[DMA_WR_CHAN].<a class="code" href="struct_d_m_a_channel__t.html#o3">xferStatus</a> = WAITING;
01255 
01256     <span class="comment">// Start the SGDMA</span>
01257     spin_lock_irqsave(&amp;pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o7">hdwAccess</a>, irqFlag);
01258     {
01259         <a class="code" href="lscdma_8h.html#a29">StartDmaWrite</a>(pBrd, &amp;pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o7">Chan</a>[DMA_WR_CHAN]);
01260     }
01261     spin_unlock_irqrestore(&amp;pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o7">hdwAccess</a>, irqFlag);
01262 
01263     <span class="comment">// Go to sleep waiting for it to complete (or get a signal)</span>
01264 
01265     ret = wait_event_interruptible(pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o8">ReadWaitQ</a>, pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o7">Chan</a>[DMA_WR_CHAN].<a class="code" href="struct_d_m_a_channel__t.html#o1">doneDMA</a>);
01266     
01267     <span class="keywordflow">if</span> ((ret != OK) || (pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o7">Chan</a>[DMA_WR_CHAN].<a class="code" href="struct_d_m_a_channel__t.html#o1">doneDMA</a> != TRUE))
01268     {
01269         <span class="comment">// cancel the DMA</span>
01270         pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o7">Chan</a>[DMA_WR_CHAN].<a class="code" href="struct_d_m_a_channel__t.html#o2">cancelDMA</a> = TRUE;
01271 
01272         <a class="code" href="lscdma_8h.html#a46">SGDMA_DisableChan</a>(pBrd, DMA_WR_CHAN);   <span class="comment">// cancel this cause we don't want DMA writing anymore</span>
01273         udelay(10);   <span class="comment">// wait for SGDMA done before continuing and releasing memory</span>
01274 
01275         ret = -ERESTARTSYS;   <span class="comment">// user process exited or Ctrl-C, or crash or something</span>
01276     }
01277 
01278 
01279     <span class="comment">// Free all resources used for the transfer</span>
01280     <a class="code" href="lscdma_8h.html#a32">releaseDMAChan</a>(pBrd, &amp;pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o7">Chan</a>[DMA_WR_CHAN]);
01281 
01282     pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o3">Reading</a> = FALSE;
01283 
01284     up(&amp;pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o7">Chan</a>[DMA_WR_CHAN].<a class="code" href="struct_d_m_a_channel__t.html#o0">dmaMutex</a>);
01285 
01286     <span class="keywordflow">if</span> (DrvrDebug)
01287         printk(KERN_INFO <span class="stringliteral">"lscdma: read completed.  ret=%d  status=%d  done=%d cancel=%d\n"</span>, 
01288                             ret, 
01289                             pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o7">Chan</a>[DMA_WR_CHAN].<a class="code" href="struct_d_m_a_channel__t.html#o3">xferStatus</a>,
01290                             pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o7">Chan</a>[DMA_WR_CHAN].<a class="code" href="struct_d_m_a_channel__t.html#o1">doneDMA</a>,
01291                             pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o7">Chan</a>[DMA_WR_CHAN].<a class="code" href="struct_d_m_a_channel__t.html#o2">cancelDMA</a>);
01292 
01293     <span class="keywordflow">if</span> (ret == OK)
01294         <span class="keywordflow">return</span>(len);   <span class="comment">// this much was transfered</span>
01295     <span class="keywordflow">else</span>
01296         <span class="keywordflow">return</span>(ret);   <span class="comment">// an error occurred</span>
01297 }
01298 
01299 
<a name="l01305"></a><a class="code" href="_main_8c.html#a25">01305</a> ssize_t <a class="code" href="_main_8c.html#a25">lscdma_write</a>(<span class="keyword">struct</span> file *filp,
01306             <span class="keyword">const</span> <span class="keywordtype">char</span> __user *userBuf,
01307             size_t len,
01308             loff_t *offp)
01309 {
01310     <span class="keywordtype">int</span> ret;
01311     <a class="code" href="struct_p_c_i_e___board.html">pcie_board_t</a> *pBrd = filp-&gt;private_data;
01312     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> irqFlag;
01313 
01314     ret = -1;
01315 
01316     <span class="keywordflow">if</span> (DrvrDebug)
01317         printk(KERN_INFO <span class="stringliteral">"lscdma: write len=%d  userAddr=%p\n"</span>, (u32)len, userBuf);
01318 
01319     <span class="keywordflow">if</span> (pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o3">function</a> !=  IMAGE_MOVE_NUM)
01320         <span class="keywordflow">return</span>(-ENODEV);  <span class="comment">// user write only allowed to ImageMove device channel</span>
01321 
01322     <span class="comment">// Try to take the Mutex Semaphore</span>
01323     <span class="comment">// Only one DMA operation can proceed at a time so this blocks the caller if there</span>
01324     <span class="comment">// is something already transferring.</span>
01325     <span class="keywordflow">if</span> (down_interruptible(&amp;pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o7">Chan</a>[DMA_RD_CHAN].<a class="code" href="struct_d_m_a_channel__t.html#o0">dmaMutex</a>))
01326         <span class="keywordflow">return</span>(-ERESTARTSYS);
01327 
01328 
01329     ret = <a class="code" href="lscdma_8h.html#a31">initDMAChan</a>(pBrd,
01330             &amp;pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o7">Chan</a>[DMA_RD_CHAN],  <span class="comment">// read channel in the SGDMA</span>
01331             (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)userBuf,
01332             len,
01333             PCI_DMA_TODEVICE);
01334 
01335     <span class="keywordflow">if</span> (ret != OK)
01336     {
01337         up(&amp;pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o7">Chan</a>[DMA_RD_CHAN].<a class="code" href="struct_d_m_a_channel__t.html#o0">dmaMutex</a>);
01338         <span class="keywordflow">return</span>(ret);   <span class="comment">// error occurred setting up the DMA operation into user space</span>
01339     }
01340 
01341     pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o4">Writing</a> = TRUE;
01342     pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o7">Chan</a>[DMA_RD_CHAN].<a class="code" href="struct_d_m_a_channel__t.html#o1">doneDMA</a> = FALSE;
01343     pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o7">Chan</a>[DMA_RD_CHAN].<a class="code" href="struct_d_m_a_channel__t.html#o2">cancelDMA</a> = FALSE;
01344     pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o7">Chan</a>[DMA_RD_CHAN].<a class="code" href="struct_d_m_a_channel__t.html#o3">xferStatus</a> = WAITING;
01345 
01346     <span class="comment">// Start the SGDMA</span>
01347     spin_lock_irqsave(&amp;pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o7">hdwAccess</a>, irqFlag);
01348     {
01349         <a class="code" href="lscdma_8h.html#a30">StartDmaRead</a>(pBrd, &amp;pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o7">Chan</a>[DMA_RD_CHAN]);
01350     }
01351     spin_unlock_irqrestore(&amp;pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o7">hdwAccess</a>, irqFlag);
01352 
01353     <span class="comment">// Go to sleep waiting for it to complete (or get a signal)</span>
01354 
01355     ret = wait_event_interruptible(pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o9">WriteWaitQ</a>, pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o7">Chan</a>[DMA_RD_CHAN].<a class="code" href="struct_d_m_a_channel__t.html#o1">doneDMA</a>);
01356     
01357     <span class="keywordflow">if</span> ((ret != OK) || (pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o7">Chan</a>[DMA_RD_CHAN].<a class="code" href="struct_d_m_a_channel__t.html#o1">doneDMA</a> != TRUE))
01358     {
01359         printk(KERN_WARNING <span class="stringliteral">"Errored out of wait_event ret=%d  done=%d\n"</span>, 
01360                         ret, pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o7">Chan</a>[DMA_RD_CHAN].<a class="code" href="struct_d_m_a_channel__t.html#o1">doneDMA</a>);
01361         <span class="comment">// cancel the DMA</span>
01362         pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o7">Chan</a>[DMA_RD_CHAN].<a class="code" href="struct_d_m_a_channel__t.html#o2">cancelDMA</a> = TRUE;
01363 
01364         <a class="code" href="lscdma_8h.html#a46">SGDMA_DisableChan</a>(pBrd, DMA_RD_CHAN);   <span class="comment">// cancel this cause we don't want DMA writing anymore</span>
01365         udelay(10);   <span class="comment">// make sure SGDMA is done before continuing and releasing memory</span>
01366 
01367         ret = -ERESTARTSYS;   <span class="comment">// user process exited or Ctrl-C, or crash or something</span>
01368     }
01369 
01370 
01371     <span class="comment">// Free all resources used for the transfer</span>
01372     <a class="code" href="lscdma_8h.html#a32">releaseDMAChan</a>(pBrd, &amp;pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o7">Chan</a>[DMA_RD_CHAN]);
01373 
01374     pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o4">Writing</a> = FALSE;
01375 
01376     up(&amp;pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o7">Chan</a>[DMA_RD_CHAN].<a class="code" href="struct_d_m_a_channel__t.html#o0">dmaMutex</a>);
01377 
01378     <span class="keywordflow">if</span> (DrvrDebug)
01379         printk(KERN_INFO <span class="stringliteral">"lscdma: write completed.  ret=%d  status=%d  done=%d cancel=%d\n"</span>, 
01380                             ret, 
01381                             pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o7">Chan</a>[DMA_RD_CHAN].<a class="code" href="struct_d_m_a_channel__t.html#o3">xferStatus</a>,
01382                             pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o7">Chan</a>[DMA_RD_CHAN].<a class="code" href="struct_d_m_a_channel__t.html#o1">doneDMA</a>,
01383                             pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o7">Chan</a>[DMA_RD_CHAN].<a class="code" href="struct_d_m_a_channel__t.html#o2">cancelDMA</a>);
01384     <span class="keywordflow">if</span> (ret == OK)
01385         <span class="keywordflow">return</span>(len);   <span class="comment">// this much was transfered</span>
01386     <span class="keywordflow">else</span>
01387         <span class="keywordflow">return</span>(ret);   <span class="comment">// an error occurred</span>
01388 
01389 }
01390 
01391 
01392 
01393 
01394 
01395 
01396 <span class="comment">/*==================================================================*/</span>
01397 <span class="comment">/*==================================================================*/</span>
01398 <span class="comment">/*==================================================================*/</span>
01399 <span class="comment">/*</span>
01400 <span class="comment"> *              M O D U L E   F U N C T I O N S</span>
01401 <span class="comment"> */</span>
01402 <span class="comment">/*==================================================================*/</span>
01403 <span class="comment">/*==================================================================*/</span>
01404 <span class="comment">/*==================================================================*/</span>
01405 
01406 <span class="comment">/*</span>
01407 <span class="comment"> * The file operations table for the device.</span>
01408 <span class="comment"> * read/write/seek, etc. are not implemented because device access</span>
01409 <span class="comment"> * is memory mapped based.</span>
01410 <span class="comment"> */</span>
01411 <span class="keyword">static</span> <span class="keyword">struct </span>file_operations drvr_fops =
01412 {
01413     owner:   THIS_MODULE,
01414     open:    lscdma_open,
01415     release: lscdma_release,
01416     ioctl:   lscdma_ioctl,
01417     mmap:    lscdma_mmap,
01418     read:    lscdma_read,
01419     write:   lscdma_write,
01420 };
01421 
01422 
01423 <span class="comment">/*------------------------------------------------------------------*/</span>
01424 
01425 
01426 
01435 <span class="keyword">static</span> <span class="keywordtype">int</span> __devinit lscdma_probe(<span class="keyword">struct</span> pci_dev *pdev,
01436                  <span class="keyword">const</span> <span class="keyword">struct</span> pci_device_id *ent)
01437 {
01438     <span class="keyword">static</span> <span class="keywordtype">char</span> devNameStr[12] = <span class="stringliteral">"lscdma__"</span>;
01439     <a class="code" href="struct_p_c_i_e___board.html">pcie_board_t</a> *brd;
01440     <span class="keywordtype">int</span> err;
01441 
01442     devNameStr[7] = <span class="charliteral">'0'</span> + lscdma.<a class="code" href="struct_l_s_c_d_m_a.html#o1">numBoards</a>;
01443 
01444     <span class="keywordflow">if</span> (DrvrDebug)
01445         printk(KERN_INFO <span class="stringliteral">"lscdma: pci probe for: %s  pdev=%p  ent=%p\n"</span>, 
01446                     devNameStr, pdev, ent);
01447 
01448     <span class="comment">/*</span>
01449 <span class="comment">     * Enable the bus-master bit values.</span>
01450 <span class="comment">     * Some PCI BIOSes fail to set the master-enable bit.</span>
01451 <span class="comment">     * Some demos support being an initiator, so need bus master ability.</span>
01452 <span class="comment">     */</span>
01453     err = pci_request_regions(pdev, devNameStr);
01454     <span class="keywordflow">if</span> (err)
01455         <span class="keywordflow">return</span> err;
01456 
01457     pci_set_master(pdev);
01458 
01459     err = pci_enable_device(pdev);
01460     <span class="keywordflow">if</span> (err)
01461         <span class="keywordflow">return</span> err;
01462 
01463     <span class="comment">/*</span>
01464 <span class="comment">     * Call to perform board specific initialization and figure out</span>
01465 <span class="comment">     * which BARs are active, interrupt vectors, register ISR, what board</span>
01466 <span class="comment">     * it is (SC or ECP2M), what demo (Basic or SFIF) and what instance</span>
01467 <span class="comment">     * number (is it the 2nd time we've seen a SC Basic?)</span>
01468 <span class="comment">     * Returns pointer to the Board structure after all info filled in.</span>
01469 <span class="comment">     */</span>
01470     brd = initBoard(pdev, (<span class="keywordtype">void</span> *)ent);
01471 
01472     <span class="keywordflow">if</span> (brd == NULL)
01473     {
01474         printk(KERN_ERR <span class="stringliteral">"lscdma: Error initializing Eval Board\n"</span>);
01475         <span class="comment">// Clean up any resources we acquired along the way</span>
01476         pci_release_regions(pdev);
01477         pci_disable_device(pdev);
01478         
01479         <span class="keywordflow">return</span>(-1);
01480     }
01481         
01482 
01483 
01484     <span class="comment">// Initialize the CharDev entry for this new found eval board device</span>
01485     brd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o26">charDev</a>.owner = THIS_MODULE;
01486     kobject_set_name(&amp;(brd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o26">charDev</a>.kobj), <span class="stringliteral">"lscdma"</span>);
01487 
01488     cdev_init(&amp;(brd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o26">charDev</a>), &amp;drvr_fops);
01489 
01490 <span class="comment">//?????</span>
01491 <span class="comment">// Does cdev_add initialize reference count in the kobj?</span>
01492 <span class="comment">//?????</span>
01493 
01494     <span class="comment">/* Create the minor numbers here and register the device as a character device.</span>
01495 <span class="comment">     * A number of minor devices can be associated with this particular board.</span>
01496 <span class="comment">     * The hope/idea is that we give the starting minor number and the number of them</span>
01497 <span class="comment">     * and all those devices will be associated to this one particular device.</span>
01498 <span class="comment">     */</span>
01499     <span class="keywordflow">if</span> (cdev_add(&amp;(brd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o26">charDev</a>), MKDEV(brd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o8">majorNum</a>,brd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o9">minorNum</a>), MINORS_PER_BOARD))
01500     {
01501         printk(KERN_ERR <span class="stringliteral">"lscdma: Error adding char device\n"</span>);
01502         kobject_put(&amp;(brd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o26">charDev</a>.kobj));
01503         <span class="keywordflow">return</span>(-1); 
01504     }
01505 
01506 
01507     <span class="comment">/* This creates a new entry in the /sys/class/lscdma/ tree that represents this</span>
01508 <span class="comment">     * new device in user space.  An entry in /dev will be created based on the name</span>
01509 <span class="comment">     * given in the last argument.  udev is responsible for mapping sysfs Classes to</span>
01510 <span class="comment">     * device nodes, and is done outside this kernel driver.</span>
01511 <span class="comment">     *</span>
01512 <span class="comment">     * The name is constructed from the board type, demo type and board instance.</span>
01513 <span class="comment">     * Examples: "sc_dma_1", "ecp2m_dma_2"</span>
01514 <span class="comment">     */</span>
01515 <span class="preprocessor">#if (LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,6,12))</span>
01516 <span class="preprocessor"></span>    class_device_create(lscdma.<a class="code" href="struct_l_s_c_d_m_a.html#o6">sysClass</a>,
01517                 NULL,
01518                 MKDEV(brd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o8">majorNum</a>,brd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o9">minorNum</a>),
01519                  &amp;(pdev-&gt;dev),   <span class="comment">// this is of type struct device, the PCI device?</span>
01520                 <span class="stringliteral">"%s_%s_%d"</span>, BoardName[brd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o4">boardType</a>], DemoName[brd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o2">demoType</a>], brd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o5">instanceNum</a>);
01521     printk(KERN_INFO <span class="stringliteral">"lscdma: added device: %s_%s_%d\n"</span>, BoardName[brd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o4">boardType</a>], 
01522 
01523                                 DemoName[brd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o2">demoType</a>], 
01524                                 brd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o5">instanceNum</a>);
01525     class_device_create(lscdma.<a class="code" href="struct_l_s_c_d_m_a.html#o6">sysClass</a>,
01526                 NULL,
01527                 MKDEV(brd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o8">majorNum</a>,brd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o9">minorNum</a> + COLOR_BARS_NUM),
01528                  &amp;(pdev-&gt;dev),   <span class="comment">// this is of type struct device, the PCI device?</span>
01529                 <span class="stringliteral">"%s_%s_%d_CB"</span>, BoardName[brd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o4">boardType</a>], DemoName[brd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o2">demoType</a>], brd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o5">instanceNum</a>);
01530     printk(KERN_INFO <span class="stringliteral">"lscdma: added device: %s_%s_%d_CB\n"</span>, BoardName[brd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o4">boardType</a>], 
01531 
01532                                 DemoName[brd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o2">demoType</a>], 
01533                                 brd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o5">instanceNum</a>);
01534     class_device_create(lscdma.<a class="code" href="struct_l_s_c_d_m_a.html#o6">sysClass</a>,
01535                 NULL,
01536                 MKDEV(brd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o8">majorNum</a>,brd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o9">minorNum</a> + IMAGE_MOVE_NUM),
01537                  &amp;(pdev-&gt;dev),   <span class="comment">// this is of type struct device, the PCI device?</span>
01538                 <span class="stringliteral">"%s_%s_%d_CB"</span>, BoardName[brd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o4">boardType</a>], DemoName[brd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o2">demoType</a>], brd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o5">instanceNum</a>);
01539     printk(KERN_INFO <span class="stringliteral">"lscdma: added device: %s_%s_%d_IM\n"</span>, BoardName[brd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o4">boardType</a>], 
01540 
01541                                 DemoName[brd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o2">demoType</a>], 
01542                                 brd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o5">instanceNum</a>);
01543 
01544 <span class="preprocessor">#else  // earlier 2.6 kernel using class_simple_</span>
01545 <span class="preprocessor"></span>
01546 
01547     class_simple_device_add(lscdma.<a class="code" href="struct_l_s_c_d_m_a.html#o6">sysClass</a>,
01548                 MKDEV(brd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o8">majorNum</a>,brd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o9">minorNum</a>),
01549                 NULL,   <span class="comment">// this is of type struct device, but who?????</span>
01550                 <span class="stringliteral">"%s_%s_%d"</span>, BoardName[brd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o4">boardType</a>], DemoName[brd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o2">demoType</a>], brd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o5">instanceNum</a>);
01551 
01552     printk(KERN_INFO <span class="stringliteral">"lscdma: added device: %s_%s_%d\n"</span>, BoardName[brd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o4">boardType</a>], 
01553                                 DemoName[brd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o2">demoType</a>], 
01554                                 brd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o5">instanceNum</a>);
01555 
01556     
01557     class_simple_device_add(lscdma.<a class="code" href="struct_l_s_c_d_m_a.html#o6">sysClass</a>,
01558                 MKDEV(brd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o8">majorNum</a>, brd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o9">minorNum</a> + COLOR_BARS_NUM),
01559                 NULL,   <span class="comment">// this is of type struct device, but who?????</span>
01560                 <span class="stringliteral">"%s_%s_%d_CB"</span>, BoardName[brd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o4">boardType</a>], DemoName[brd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o2">demoType</a>], brd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o5">instanceNum</a>);
01561     printk(KERN_INFO <span class="stringliteral">"lscdma: added device: %s_%s_%d_CB\n"</span>, BoardName[brd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o4">boardType</a>], 
01562                                 DemoName[brd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o2">demoType</a>], 
01563                                 brd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o5">instanceNum</a>);
01564 
01565     class_simple_device_add(lscdma.<a class="code" href="struct_l_s_c_d_m_a.html#o6">sysClass</a>,
01566                 MKDEV(brd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o8">majorNum</a>, brd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o9">minorNum</a> + IMAGE_MOVE_NUM),
01567                 NULL,   <span class="comment">// this is of type struct device, but who?????</span>
01568                 <span class="stringliteral">"%s_%s_%d_IM"</span>, BoardName[brd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o4">boardType</a>], DemoName[brd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o2">demoType</a>], brd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o5">instanceNum</a>);
01569     printk(KERN_INFO <span class="stringliteral">"lscdma: added device: %s_%s_%d_IM\n"</span>, BoardName[brd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o4">boardType</a>], 
01570                                 DemoName[brd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o2">demoType</a>], 
01571                                 brd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o5">instanceNum</a>);
01572 <span class="preprocessor">#endif</span>
01573 <span class="preprocessor"></span>
01574     <span class="comment">/* Store a pointer to the Board structure with this PCI device instance for easy access</span>
01575 <span class="comment">     * to board info later on.</span>
01576 <span class="comment">     */</span>
01577     pci_set_drvdata(pdev, brd);
01578 
01579 
01580 
01581     <span class="comment">// Write an 'I' to the LEDs at end of initialization</span>
01582     <a class="code" href="lscdma_8h.html#a38">wrReg32</a>(brd, <a class="code" href="_devices_8h.html#a20">GPIO</a>(GPIO_LED16SEG), 0x2233);   <span class="comment">// display an 'I' </span>
01583 
01584     <span class="keywordflow">return</span> 0;
01585 }
01586 
01587 
01588 
01597 <span class="keyword">static</span> <span class="keywordtype">void</span> __devexit lscdma_remove(<span class="keyword">struct</span> pci_dev *pdev)
01598 {
01599     <a class="code" href="struct_p_c_i_e___board.html">pcie_board_t</a> *pBrd = pci_get_drvdata(pdev);
01600 
01601     <span class="keywordflow">if</span> (DrvrDebug)
01602         printk(KERN_INFO <span class="stringliteral">"lscdma: pci remove for device: pdev=%p board=%p\n"</span>, pdev, pBrd);
01603 
01604 
01605     <span class="comment">// Write an 'R' to the LEDs when device is removed</span>
01606     <span class="keywordflow">if</span> (pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o24">ctrlBARaddr</a>)
01607         <a class="code" href="lscdma_8h.html#a38">wrReg32</a>(pBrd, <a class="code" href="_devices_8h.html#a20">GPIO</a>(GPIO_LED16SEG), 0x98c7);   <span class="comment">// display an 'R' </span>
01608 
01609     <span class="comment">// Release Common Buffer DMA Buffer</span>
01610     <span class="keywordflow">if</span> (pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o28">CBDMA</a>.<a class="code" href="struct_c_b_d_m_a_operations__t.html#o0">hasDMA</a>)
01611     {
01612         pci_free_consistent(pdev, pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o28">CBDMA</a>.<a class="code" href="struct_c_b_d_m_a_operations__t.html#o2">dmaBufSize</a>, pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o28">CBDMA</a>.<a class="code" href="struct_c_b_d_m_a_operations__t.html#o4">dmaCPUAddr</a>, pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o28">CBDMA</a>.<a class="code" href="struct_c_b_d_m_a_operations__t.html#o3">dmaPCIBusAddr</a>);
01613     }
01614 
01615 
01616 
01617     <span class="comment">// Shut off interrupt sources - not implemented in Basic or SFIF</span>
01618     <a class="code" href="lscdma_8h.html#a44">SGDMA_Disable</a>(pBrd);
01619     <a class="code" href="lscdma_8h.html#a26">IsrDisableInterrupts</a>(pBrd);
01620 
01621     <span class="comment">// Free our internal access to the control BAR address space</span>
01622     <span class="keywordflow">if</span> (pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o24">ctrlBARaddr</a>)
01623         iounmap(pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o24">ctrlBARaddr</a>);
01624 
01625     <span class="comment">// No more access after this call</span>
01626     pci_release_regions(pdev);
01627 
01628     <span class="comment">// Unbind the minor numbers of this device</span>
01629     <span class="comment">// using the MAJOR_NUM + board_num + Minor Range of this board</span>
01630     cdev_del(&amp;(pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o26">charDev</a>));
01631 
01632     unregister_chrdev_region(MKDEV(pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o8">majorNum</a>, pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o9">minorNum</a>), MINORS_PER_BOARD);
01633 
01634 
01635     <span class="comment">// Remove the device entry in the /sys/class/lscdma/ tree</span>
01636 <span class="preprocessor">#if  (LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,6,12))</span>
01637 <span class="preprocessor"></span>    class_device_destroy(lscdma.<a class="code" href="struct_l_s_c_d_m_a.html#o6">sysClass</a>, MKDEV(pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o8">majorNum</a>, pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o9">minorNum</a>));
01638     class_device_destroy(lscdma.<a class="code" href="struct_l_s_c_d_m_a.html#o6">sysClass</a>, MKDEV(pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o8">majorNum</a>, pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o9">minorNum</a> + COLOR_BARS_NUM));
01639     class_device_destroy(lscdma.<a class="code" href="struct_l_s_c_d_m_a.html#o6">sysClass</a>, MKDEV(pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o8">majorNum</a>, pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o9">minorNum</a> + IMAGE_MOVE_NUM));
01640 
01641 <span class="preprocessor">#else</span>
01642 <span class="preprocessor"></span>    class_simple_device_remove(MKDEV(pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o8">majorNum</a>, pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o9">minorNum</a>));
01643     class_simple_device_remove(MKDEV(pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o8">majorNum</a>, pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o9">minorNum</a> + COLOR_BARS_NUM));
01644     class_simple_device_remove(MKDEV(pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o8">majorNum</a>, pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o9">minorNum</a> + IMAGE_MOVE_NUM));
01645 <span class="preprocessor">#endif</span>
01646 <span class="preprocessor"></span>
01647 }
01648 
01649 
01650 <span class="comment">/*-------------------------------------------------------------------------*/</span>
01651 <span class="comment">/*             DRIVER INSTALL/REMOVE POINTS                                */</span>
01652 <span class="comment">/*-------------------------------------------------------------------------*/</span>
01653 
01654 <span class="comment">/*</span>
01655 <span class="comment"> *  Variables that can be overriden from module command line</span>
01656 <span class="comment"> */</span>
01657 <span class="keyword">static</span> <span class="keywordtype">int</span>  debug = 0;
01658 module_param(debug, <span class="keywordtype">int</span>, 0);
01659 MODULE_PARM_DESC(debug, <span class="stringliteral">"lscdma enable debugging (0-1)"</span>);
01660 
01661 
01671 <span class="keyword">static</span> <span class="keyword">struct </span>pci_driver lscdma_driver = {
01672     .name = <span class="stringliteral">"lscdma"</span>,
01673     .id_table = lscdma_pci_id_tbl,
01674     .probe = lscdma_probe,
01675     .remove = __devexit_p(lscdma_remove),
01676 
01677 <span class="comment">/*</span>
01678 <span class="comment">    .save_state - Save a device's state before its suspended</span>
01679 <span class="comment">    .suspend - put device into low power state</span>
01680 <span class="comment">    .resume - wake device from low power state</span>
01681 <span class="comment">    .enable_wake - enable device to generate wake events from low power state</span>
01682 <span class="comment">*/</span>
01683 };
01684 
01685 
01686 <span class="comment">/*-------------------------------------------------------------------------*/</span>
01687 
01692 <span class="keyword">static</span> <span class="keywordtype">int</span> __init lscdma_init(<span class="keywordtype">void</span>)
01693 {
01694     <span class="keywordtype">int</span> result;
01695     <span class="keywordtype">int</span> i, n;
01696     <span class="keywordtype">int</span> err;
01697     <span class="comment">//pci_dev_bar_t *p;</span>
01698     <span class="comment">//pcie_board_t *pB;</span>
01699 
01700     printk(KERN_INFO <span class="stringliteral">"lscdma: _init()   debug=%d\n"</span>, debug);
01701     printk(KERN_INFO <span class="stringliteral">"lscdma: Version=%s\n"</span>, Version);
01702     DrvrDebug = debug;
01703 
01704     <span class="comment">/* Initialize the driver database to nothing found, no BARs, no devices */</span>
01705     memset(&amp;lscdma, 0, <span class="keyword">sizeof</span>(lscdma));
01706     <span class="keywordflow">for</span> (n = 0; n &lt; NUM_BOARDS; n++)
01707         <span class="keywordflow">for</span> (i = 0; i &lt; NUM_BARS; i++)
01708             lscdma.<a class="code" href="struct_l_s_c_d_m_a.html#o7">Board</a>[n].<a class="code" href="struct_p_c_i_e___board.html#o20">Dev_BARs</a>[i].<a class="code" href="struct_p_c_i___dev___b_a_r.html#o0">bar</a> = -1;
01709 
01710     <span class="comment">/*</span>
01711 <span class="comment">     * Register device driver as a character device and get a dynamic Major number</span>
01712 <span class="comment">         * and reserve enough minor numbers for the maximum amount of boards * BARs</span>
01713 <span class="comment">         * we'd expect to find in a system.</span>
01714 <span class="comment">     */</span>
01715     result = alloc_chrdev_region(&amp;lscdma.<a class="code" href="struct_l_s_c_d_m_a.html#o0">drvrDevNum</a>,   <span class="comment">// return allocated Device Num here</span>
01716                       0,        <span class="comment">// first minor number</span>
01717                       MAX_MINORS,   
01718                                       <span class="stringliteral">"lscdma"</span>);
01719 
01720     <span class="keywordflow">if</span> (result &lt; 0)
01721     {
01722         printk(KERN_WARNING <span class="stringliteral">"lscdma: can't get major/minor numbers!\n"</span>);
01723         <span class="keywordflow">return</span>(result);
01724     }
01725 
01726 
01727     <span class="keywordflow">if</span> (DrvrDebug)
01728         printk(KERN_INFO <span class="stringliteral">"lscdma: Major=%d  num boards=%d\n"</span>, MAJOR(lscdma.<a class="code" href="struct_l_s_c_d_m_a.html#o0">drvrDevNum</a>), lscdma.<a class="code" href="struct_l_s_c_d_m_a.html#o1">numBoards</a> );
01729 
01730     
01731     <span class="keywordflow">if</span> (DrvrDebug)
01732         printk(KERN_INFO <span class="stringliteral">"lscdma: cdev_init()\n"</span>);
01733 
01734 
01735 
01736     <span class="comment">/* Create the new sysfs Class entry that will hold the tree of detected Lattice PCIe Eval</span>
01737 <span class="comment">     * board devices.</span>
01738 <span class="comment">     */</span>
01739 <span class="preprocessor">#if (LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,6,12))</span>
01740 <span class="preprocessor"></span>    lscdma.<a class="code" href="struct_l_s_c_d_m_a.html#o6">sysClass</a> = class_create(THIS_MODULE, <span class="stringliteral">"lscdma"</span>);
01741 <span class="preprocessor">#else</span>
01742 <span class="preprocessor"></span>    lscdma.<a class="code" href="struct_l_s_c_d_m_a.html#o6">sysClass</a> = class_simple_create(THIS_MODULE, <span class="stringliteral">"lscdma"</span>);
01743 <span class="preprocessor">#endif</span>
01744 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (IS_ERR(lscdma.<a class="code" href="struct_l_s_c_d_m_a.html#o6">sysClass</a>))
01745     {
01746         printk(KERN_ERR <span class="stringliteral">"lscdma: Error creating simple class interface\n"</span>);
01747         <span class="keywordflow">return</span>(-1); 
01748     }
01749 
01750 
01751 
01752     <span class="keywordflow">if</span> (DrvrDebug)
01753         printk(KERN_INFO <span class="stringliteral">"lscdma: registering driver with PCI\n"</span>);
01754 
01755 
01756     <span class="comment">/* Register our PCI components and functions with the Kernel PCI core.</span>
01757 <span class="comment">     * Returns negative number for error, and 0 if success.  It does not always</span>
01758 <span class="comment">     * return the number of devices found and bound to the driver because of hot</span>
01759 <span class="comment">     * plug - they could be bound later.</span>
01760 <span class="comment">     */</span>
01761     err = pci_register_driver(&amp;lscdma_driver);
01762 
01763     <span class="keywordflow">if</span> (DrvrDebug)
01764         printk(KERN_INFO <span class="stringliteral">"lscdma: pci_register_driver()=%d\n"</span>, err);
01765 
01766     <span class="keywordflow">if</span> (err &lt; 0)
01767         <span class="keywordflow">return</span>(err);
01768 
01769 
01770 <span class="preprocessor">#ifdef USE_PROC </span><span class="comment">/* only when available */</span>
01771     create_proc_read_entry(<span class="stringliteral">"driver/lscdma"</span>, 0, 0, lscdma_read_procmem, NULL);
01772 <span class="preprocessor">#endif</span>
01773 <span class="preprocessor"></span>
01774 
01775     <span class="keywordflow">return</span>(0); <span class="comment">/* succeed */</span>
01776 
01777 }
01778 
01779 
01784 <span class="keyword">static</span> <span class="keywordtype">void</span> __exit lscdma_exit(<span class="keywordtype">void</span>)
01785 {
01786     <span class="keywordtype">int</span> i;
01787 
01788     printk(KERN_INFO <span class="stringliteral">"lscdma: _exit()\n"</span>);
01789 
01790 
01791     pci_unregister_driver(&amp;lscdma_driver);
01792 
01793     <span class="keywordflow">for</span> (i = 0; i &lt; NUM_BOARDS; i++)
01794     {
01795         <span class="keywordflow">if</span> (lscdma.<a class="code" href="struct_l_s_c_d_m_a.html#o7">Board</a>[i].<a class="code" href="struct_p_c_i_e___board.html#o0">ID</a> != 0)
01796         {
01797             <span class="comment">/* Do the cleanup for each active board */</span>
01798             printk(KERN_INFO <span class="stringliteral">"lscdma: Cleaning up board: %d\n"</span>, i);
01799 
01800             <span class="comment">// Disable and release IRQ if still active</span>
01801         }
01802     }
01803 
01804 
01805 <span class="preprocessor">#if (LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,6,12))</span>
01806 <span class="preprocessor"></span>    class_destroy(lscdma.<a class="code" href="struct_l_s_c_d_m_a.html#o6">sysClass</a>);
01807 <span class="preprocessor">#else</span>
01808 <span class="preprocessor"></span>    class_simple_destroy(lscdma.<a class="code" href="struct_l_s_c_d_m_a.html#o6">sysClass</a>);
01809 <span class="preprocessor">#endif</span>
01810 <span class="preprocessor"></span>
01811 
01812     <span class="comment">// Free every minor number and major number we reserved in init</span>
01813     unregister_chrdev_region(lscdma.<a class="code" href="struct_l_s_c_d_m_a.html#o0">drvrDevNum</a>, MAX_MINORS);
01814 
01815 
01816 <span class="preprocessor">#ifdef USE_PROC</span>
01817 <span class="preprocessor"></span>    remove_proc_entry(<span class="stringliteral">"driver/lscdma"</span>, NULL);
01818 <span class="preprocessor">#endif</span>
01819 <span class="preprocessor"></span>
01820     <span class="keywordflow">return</span>;
01821 }
01822 
01823 
01824 <span class="comment">/*</span>
01825 <span class="comment"> * Kernel Dynamic Loadable Module Interface APIs</span>
01826 <span class="comment"> */</span>
01827 
01828 module_init(lscdma_init);
01829 module_exit(lscdma_exit);
01830 
01831 
01832 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Jul 16 12:05:24 2008 for Lattice PCIeDMA Device Driver  by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
