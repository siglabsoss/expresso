<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Lattice PCIeDMA Device Driver : Introduction</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
</head>
<body>
    <H2>Why the lscdma Driver?</H2>
    All modern operating systems (Windows, Linux, Solaris, etc.) prevent user
    space code (regular applications) from having direct access to hardware
    registers, bus memory spaces and interrupts.  These system resources are claimed
    by the operating system and managed by trusted drivers in the kernel to
    ensure system stability and security.
    <p>
    In order to demonstrate the operation of the Lattice PCI Express evaluation
    board, a driver needs to be loaded to allow the demo application access to
    the board hardware and IP to setup and execute the demo.
    <p>
    This driver is associated with a Lattice PCIe Evaluation Board containing the PCIe
    SGDMA Demo bitstream, and is invoked by the Linux kernel during PCI
    bus enumeration.  The driver provides the following services:
    <ul>
	<li>Accesses IP hardware registers
	<li>Handles interrupts
	<li>Maps a user space memory buffer into a DMA SG-List
	<li>Returns PCIe link specific info
    </ul>
    
    By using the service access points (standard file operations such as open,
    close, read, write and ioctl) the application code can access the eval board
    hardware and perform the demo operations.


    <br>
    <img align=center src="./DriverDiagram.gif" alt="Demo/Driver/Hardware Relationship">
    <br>
    The above figure shows the relationship between the application demo,
    the driver and the evaluation board hardware.  The Application must use
    the OS system calls to gain access to the driver.  The driver in turn
    uses Kernel functions to map hardware memory into kernel and user space.
    <p>
    In this figure, the <b>/sysfs</b> represents the /sys, /dev and /proc file systems
    found in Linux that allow the driver and user space to exchange information.
    The driver actually creates entries in the /sys/class and /proc areas.
    This is done when the driver is installed and initialized.  When the driver
    detects and initializes an eval board, it creates an entry in the /sys/class.
    It also registers a major and minor device number with the kernel.  The udev
    service then creates a file entry in the /dev device tree.  This device node
    will have the character device major and minor number associated with the driver
    and board.
    <p>
    When the user opens the device, via an open("filename"), the kernel knows which
    driver handles that file (via the major/minor) and invokes the driver's entry
    points.  The driver uses the minor number to understand which board the user
    wants to access (if more than one in system).  The /dev filename and the 
    major/minor numbers are the translations between user space and kernel space.
    
    

    <H3>Defining Features</H3>
    The lscdma driver extends the lscpcie2 driver by providing SGDMA support directly
    in the kernel driver.  This driver manages the hardware directly - SGDMA setup, buffer
    descriptor configuration, channel allocation, interrupt handling, user space buffer
    mapping, etc.  Previous Lattice PCIe drivers meerly provided access to hardware
    registers.  All control and functionality was in the user space device class methods.
    This driver puts all such control in the kernel space for fast and efficient operation
    of buffer management and interrupts.  user space code simply opens a file (channel) and
    reads and writes which perform the SGDMA operations completely in the kernel.


    <H2>Linux Kernel Module Drivers</H2>
    This driver is a Linux 2.6.x Kernel Module Driver.
    A driver module is loaded into the kernel at run-time and registers which devices
    it will service.  The kernel then calls back the driver when new hardware is discovered,
    or when user operations are directed towards the devices the driver services.
    The driver has various satandard interfaces that the kernel can call.

    <H3>Life Cycle of a Driver</H3>
	The driver transistions through the following states:
	<ul>
	<li> Installation - driver is installed into the kernel and registers itself to handle specific boards
	<li> Initialization - the kernel and PCI subsystem call the driver's
	board initialization routines when devices are found on the PCI/PCIe bus.  The driver initializes
	the boards and makes them known to the system and user.  They will now appear in /dev/lscdma/.
	<li> Open - user opens a device by opening the file in /dev/lscdma/.  The user can now access
	the hardware through the file (and thus the driver)
	<li> Operation - read(), write(), mmap() and ioctl() calls can now be made to access the driver
	and board hardware.
	<li> Close - when finished the user closes the file handle and the driver cleans up any resources
	it allocated in open.
	<li> Removal - the driver can be removed from the kernel with a rmdrvr script.  This removes
	all device and driver entry points from the system.  There will no longer be any file names 
	corresponding to hardware devices.  This is done when the system shuts down, or during development
	to replace the current driver with a new version.
	</ul>


    <H2>Linux Device Driver Resources</H2>
    The Linux Kernel Header Files (kernel-devel-  RPM) are required for building the driver source.
    <p>
    The following Web sites contain additional information for Linux Device Driver Development:

    <ul>
	<li><a href="http://lwn.net/Kernel/LDD3/">Linux Device Drivers, Third Edition - <i>Read this if you are new to driver programming!</i></a>
	<li><a href="http://www.redhat.com/magazine/002dec04/features/udev/">Writing Custom udev Rules</a>
	<li><b>DMA-mapping.txt</b> - Linux Documentation
	<li><b>MSI-HOWTO.txt</b> - Linux Documentation

    </ul>


</body>
</html>
 <hr size="1"><address style="align: right;"><small>Generated on Wed Jul 16 12:05:24 2008 for Lattice PCIeDMA Device Driver  by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
