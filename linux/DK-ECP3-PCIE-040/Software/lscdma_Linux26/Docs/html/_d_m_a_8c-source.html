<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Lattice PCIeDMA Device Driver : DMA.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>DMA.c</h1><a href="_d_m_a_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 
00003 <span class="comment">/*========================================================================*/</span>
00004 <span class="comment">/*========================================================================*/</span>
00005 <span class="comment">/*</span>
00006 <span class="comment"> *           LINUX MEMORY PAGES AND DMA SETUP ROUTINES</span>
00007 <span class="comment"> */</span>
00008 <span class="comment">/*========================================================================*/</span>
00009 <span class="comment">/*========================================================================*/</span>
00010 <span class="comment">/*========================================================================*/</span>
00011 
00012 <span class="preprocessor">#include "<a class="code" href="lscdma_8h.html">lscdma.h</a>"</span>
00013 
<a name="l00024"></a><a class="code" href="lscdma_8h.html#a29">00024</a> <span class="keywordtype">void</span> <a class="code" href="lscdma_8h.html#a29">StartDmaWrite</a>(<a class="code" href="struct_p_c_i_e___board.html">pcie_board_t</a> *pBrd,
00025            <a class="code" href="struct_d_m_a_channel__t.html">DMAChannel_t</a> *pChan)
00026 {
00027 
00028     <span class="keywordflow">if</span> (pChan-&gt;<a class="code" href="struct_d_m_a_channel__t.html#o15">sgList</a> == NULL)
00029     {
00030         printk(KERN_WARNING <span class="stringliteral">"lscdma: StartDmaWrite NULL sgList!  Can't proceed.\n"</span>);
00031         <span class="keywordflow">return</span>;
00032     }
00033     
00034 
00035     <a class="code" href="lscdma_8h.html#a45">SGDMA_EnableChan</a>(pBrd, DMA_WR_CHAN, pChan-&gt;<a class="code" href="struct_d_m_a_channel__t.html#o11">startBD</a>);
00036 
00037     <a class="code" href="lscdma_8h.html#a47">SGDMA_ConfigWrite</a>(pBrd, 
00038               DMA_WR_CHAN, 
00039               pChan-&gt;<a class="code" href="struct_d_m_a_channel__t.html#o16">sgLen</a>,
00040               pChan-&gt;<a class="code" href="struct_d_m_a_channel__t.html#o15">sgList</a>, 
00041               pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o1">WriteBurstSize</a>);
00042 
00043 
00044 
00045     <span class="comment">// The ISR is locked-out by the spin lock to ensure we can</span>
00046     <span class="comment">// enable and modify interrupt controller registers and start</span>
00047     <span class="comment">// the SGDMA IP.</span>
00048 
00049     
00050     <a class="code" href="lscdma_8h.html#a49">SGDMA_StartWriteChan</a>(pBrd); 
00051 
00052 }
00053 
00054 
<a name="l00065"></a><a class="code" href="lscdma_8h.html#a30">00065</a> <span class="keywordtype">void</span> <a class="code" href="lscdma_8h.html#a30">StartDmaRead</a>(<a class="code" href="struct_p_c_i_e___board.html">pcie_board_t</a> *pBrd,
00066            <a class="code" href="struct_d_m_a_channel__t.html">DMAChannel_t</a> *pChan)
00067 {
00068 
00069     <span class="keywordflow">if</span> (pChan-&gt;<a class="code" href="struct_d_m_a_channel__t.html#o15">sgList</a> == NULL)
00070     {
00071         printk(KERN_WARNING <span class="stringliteral">"lscdma: StartDmaRead NULL sgList!  Can't proceed.\n"</span>);
00072         <span class="keywordflow">return</span>;
00073     }
00074     
00075 
00076     <a class="code" href="lscdma_8h.html#a45">SGDMA_EnableChan</a>(pBrd, DMA_RD_CHAN, pChan-&gt;<a class="code" href="struct_d_m_a_channel__t.html#o11">startBD</a>);
00077 
00078 
00079     <a class="code" href="lscdma_8h.html#a48">SGDMA_ConfigRead</a>(pBrd, 
00080               DMA_RD_CHAN, 
00081               pChan-&gt;<a class="code" href="struct_d_m_a_channel__t.html#o16">sgLen</a>,
00082               pChan-&gt;<a class="code" href="struct_d_m_a_channel__t.html#o15">sgList</a>, 
00083               pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o2">ReadBurstSize</a>);
00084 
00085     <span class="comment">// The ISR is locked-out by the spin lock to ensure we can</span>
00086     <span class="comment">// enable and modify interrupt controller registers and start</span>
00087     <span class="comment">// the SGDMA IP.</span>
00088 
00089     <a class="code" href="lscdma_8h.html#a50">SGDMA_StartReadChan</a>(pBrd); 
00090 
00091 }
00092 
00093 
00094 
<a name="l00114"></a><a class="code" href="lscdma_8h.html#a31">00114</a> <span class="keywordtype">int</span> <a class="code" href="lscdma_8h.html#a31">initDMAChan</a>(<a class="code" href="struct_p_c_i_e___board.html">pcie_board_t</a> *pBrd,
00115         <a class="code" href="struct_d_m_a_channel__t.html">DMAChannel_t</a> *pChan,
00116         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> userAddr,
00117         size_t len,
00118         <span class="keywordtype">int</span> direction)
00119 {
00120     <span class="keywordtype">int</span> i, ret, dir;
00121 
00122     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> firstPg, lastPg;
00123     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> firstPgOffset;
00124 
00125     <span class="keywordflow">if</span> (DrvrDebug)
00126         printk(KERN_INFO <span class="stringliteral">"lscdma: initDMA  userAddr=%lx len=%d\n"</span>, userAddr, (u32)len);
00127 
00128 
00129     <span class="keywordflow">if</span> (!pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o0">DmaOk</a>)
00130         <span class="keywordflow">return</span>(-EINVAL);   <span class="comment">// invalid, SGDMA not supported or broken, See initboard</span>
00131 
00132     <span class="keywordflow">if</span> (pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o15">IRQ</a> == -1)
00133         <span class="keywordflow">return</span>(-EINVAL);   <span class="comment">// no ISR setup so don't go any further or we'll get stuck!</span>
00134 
00135 
00136     <span class="keywordflow">if</span> (direction == PCI_DMA_FROMDEVICE)
00137         dir = 1;  <span class="comment">// a user read</span>
00138     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (direction == PCI_DMA_TODEVICE)
00139         dir = 0;  <span class="comment">// a user write</span>
00140     <span class="keywordflow">else</span>
00141         <span class="keywordflow">return</span>(-EINVAL);   <span class="comment">// invalid direction parameter</span>
00142     
00143 
00144     <span class="comment">//-------------------------------------------------------------------------</span>
00145     <span class="comment">// STEP 1</span>
00146     <span class="comment">// Get information about the user's buffer in virtual memory space</span>
00147     <span class="comment">//-------------------------------------------------------------------------</span>
00148     <span class="keywordflow">if</span> (DrvrDebug)
00149         printk(KERN_INFO <span class="stringliteral">"lscdma: Create SGlist from user buffer\n"</span>);
00150 
00151     firstPg = (userAddr &amp; PAGE_MASK) &gt;&gt; PAGE_SHIFT;
00152     lastPg = ((userAddr + len - 1) &amp; PAGE_MASK) &gt;&gt; PAGE_SHIFT;
00153     firstPgOffset = userAddr &amp; ~PAGE_MASK;
00154     pChan-&gt;<a class="code" href="struct_d_m_a_channel__t.html#o14">numPages</a> = lastPg - firstPg + 1;
00155 
00156     <span class="comment">// Initialize channel control parameters</span>
00157     pChan-&gt;<a class="code" href="struct_d_m_a_channel__t.html#o5">totalXferSize</a> = len;   <span class="comment">// Want to move this much</span>
00158     pChan-&gt;<a class="code" href="struct_d_m_a_channel__t.html#o7">thisXferSize</a> = len;    <span class="comment">// we do all of it at once</span>
00159     pChan-&gt;<a class="code" href="struct_d_m_a_channel__t.html#o6">xferedSoFar</a> = 0;
00160     pChan-&gt;<a class="code" href="struct_d_m_a_channel__t.html#o4">elapsedTime</a> = 0;
00161     pChan-&gt;<a class="code" href="struct_d_m_a_channel__t.html#o8">bufBaseVirtualAddr</a> = (<span class="keywordtype">void</span> *)userAddr;
00162     pChan-&gt;<a class="code" href="struct_d_m_a_channel__t.html#o9">isDmaAddr64</a> = FALSE;   <span class="comment">// don't support 64 bit right now</span>
00163     pChan-&gt;<a class="code" href="struct_d_m_a_channel__t.html#o17">direction</a> = direction;  <span class="comment">// PCI_DMA_TODEVICE or PCI_DMA_FROMDEVICE</span>
00164 
00165     <span class="comment">// signal waiting for DMA to complete, will be set to true by ISR</span>
00166     pChan-&gt;<a class="code" href="struct_d_m_a_channel__t.html#o1">doneDMA</a> = FALSE;
00167     pChan-&gt;<a class="code" href="struct_d_m_a_channel__t.html#o2">cancelDMA</a> = FALSE;
00168 
00169     <span class="keywordflow">if</span> (firstPgOffset != 0)
00170         printk(KERN_WARNING <span class="stringliteral">"lscdma: WARNING! buffer not page aligned! SGDMA may not cope well"</span>
00171                 <span class="stringliteral">"with partial page transfers!\n"</span>);  
00172     
00173     <span class="keywordflow">if</span> (DrvrDebug)
00174         printk(KERN_INFO <span class="stringliteral">"FirstPg=%lx offset=%lx LastPg=%lx nPgs=%d\n"</span>, firstPg,
00175                                     firstPgOffset,
00176                                      lastPg,
00177                                     pChan-&gt;<a class="code" href="struct_d_m_a_channel__t.html#o14">numPages</a>);
00178 
00179         <span class="comment">//-------------------------------------------------------------------------</span>
00180     <span class="comment">// STEP 2: Get mapping of user's pages that represent their buffer</span>
00181     <span class="comment">// This will be used to generate the scatter list.</span>
00182     <span class="comment">//-------------------------------------------------------------------------</span>
00183 
00184     <span class="comment">// Allocate memory to hold the page mapping of the User's pages</span>
00185     <span class="comment">// Need an array of NumPages, and each entry will point to a page in the process's MM</span>
00186     pChan-&gt;<a class="code" href="struct_d_m_a_channel__t.html#o13">pageList</a> = kmalloc(pChan-&gt;<a class="code" href="struct_d_m_a_channel__t.html#o14">numPages</a> * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> page *), GFP_KERNEL);
00187     <span class="keywordflow">if</span> (pChan-&gt;<a class="code" href="struct_d_m_a_channel__t.html#o13">pageList</a> == NULL) 
00188     {
00189         printk(KERN_ERR <span class="stringliteral">"lscdma: Can't allocate page list!\n"</span>);
00190         <span class="keywordflow">return</span>(-ENOMEM);
00191     }
00192         
00193     <span class="comment">// Get the list of the pages that make up the user's complete buffer in virtual</span>
00194     <span class="comment">// address space world.</span>
00195     down_read(&amp;current-&gt;mm-&gt;mmap_sem);
00196     ret = get_user_pages(current,  <span class="comment">// this process is the one to map</span>
00197                 current-&gt;mm,
00198                 userAddr,   <span class="comment">// starting at this address</span>
00199                 pChan-&gt;<a class="code" href="struct_d_m_a_channel__t.html#o14">numPages</a>,   <span class="comment">// for this many pages</span>
00200                 dir, <span class="comment">// 0 = user write, 1 = user read</span>
00201                 1, <span class="comment">// force access to user space</span>
00202                 pChan-&gt;<a class="code" href="struct_d_m_a_channel__t.html#o13">pageList</a>,  <span class="comment">// fill this list with reference to user's pages</span>
00203                 NULL);     <span class="comment">// don't care about VMA information</span>
00204     up_read(&amp;current-&gt;mm-&gt;mmap_sem);
00205     
00206     
00207     <span class="keywordflow">if</span> (ret != pChan-&gt;<a class="code" href="struct_d_m_a_channel__t.html#o14">numPages</a>)
00208     {
00209         printk(KERN_ERR <span class="stringliteral">"lscdma: Did not get mapping to all user pages!  Aborting!\n"</span>);
00210         ret = -ENOMEM;
00211         <span class="keywordflow">goto</span> FREE_MEM;
00212 
00213     }
00214  
00215 <span class="comment">// TODO remove this debugging stuff later</span>
00216     <span class="keywordflow">if</span> (DrvrDebug)
00217     {
00218         printk(KERN_INFO <span class="stringliteral">"lscdma: get_user_pages = %d\n"</span>, ret);
00219         <span class="keywordflow">for</span> (i = 0; i &lt; pChan-&gt;<a class="code" href="struct_d_m_a_channel__t.html#o14">numPages</a>; i++)
00220         {
00221             printk(KERN_INFO <span class="stringliteral">"\tpage[%d]: index=%lx\n"</span>, i, pChan-&gt;<a class="code" href="struct_d_m_a_channel__t.html#o13">pageList</a>[i]-&gt;index);
00222         }
00223     }   
00224 
00225 
00226     <span class="comment">//-------------------------------------------------------------------------</span>
00227     <span class="comment">// STEP 3: Create the PCI Scatter/Gather List</span>
00228     <span class="comment">//-------------------------------------------------------------------------</span>
00229     
00230     <span class="comment">// Allocate storage for the scatter list</span>
00231     pChan-&gt;<a class="code" href="struct_d_m_a_channel__t.html#o15">sgList</a> = kmalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> scatterlist) * pChan-&gt;<a class="code" href="struct_d_m_a_channel__t.html#o14">numPages</a>, GFP_KERNEL);
00232     <span class="keywordflow">if</span> (pChan-&gt;<a class="code" href="struct_d_m_a_channel__t.html#o15">sgList</a> == NULL)
00233     {
00234         printk(KERN_ERR <span class="stringliteral">"lscdma: can't get memory for Scatter/Gather list!\n"</span>);
00235         ret = -ENOMEM;
00236         <span class="keywordflow">goto</span> FREE_PAGES;
00237     }
00238 
00239     memset(pChan-&gt;<a class="code" href="struct_d_m_a_channel__t.html#o15">sgList</a>, 0, pChan-&gt;<a class="code" href="struct_d_m_a_channel__t.html#o14">numPages</a> * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> scatterlist));
00240 
00241 
00242     <span class="comment">// fill in the information from the pages data</span>
00243     pChan-&gt;<a class="code" href="struct_d_m_a_channel__t.html#o15">sgList</a>[0].page = pChan-&gt;<a class="code" href="struct_d_m_a_channel__t.html#o13">pageList</a>[0];
00244     pChan-&gt;<a class="code" href="struct_d_m_a_channel__t.html#o15">sgList</a>[0].offset = firstPgOffset;
00245     pChan-&gt;<a class="code" href="struct_d_m_a_channel__t.html#o15">sgList</a>[0].length = PAGE_SIZE - firstPgOffset;
00246     <span class="keywordflow">for</span> (i = 1; i &lt; pChan-&gt;<a class="code" href="struct_d_m_a_channel__t.html#o14">numPages</a>; i++)
00247     {
00248         <span class="keywordflow">if</span> (pChan-&gt;<a class="code" href="struct_d_m_a_channel__t.html#o13">pageList</a>[i] == NULL)
00249             <span class="keywordflow">goto</span> FREE_SGMEM;
00250         pChan-&gt;<a class="code" href="struct_d_m_a_channel__t.html#o15">sgList</a>[i].page = pChan-&gt;<a class="code" href="struct_d_m_a_channel__t.html#o13">pageList</a>[i];
00251         pChan-&gt;<a class="code" href="struct_d_m_a_channel__t.html#o15">sgList</a>[i].offset = 0;
00252         pChan-&gt;<a class="code" href="struct_d_m_a_channel__t.html#o15">sgList</a>[i].length = PAGE_SIZE;
00253     }
00254 
00255     <span class="comment">// Call API to create the Scatter/Gather List</span>
00256     pChan-&gt;<a class="code" href="struct_d_m_a_channel__t.html#o16">sgLen</a> = pci_map_sg(pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o25">pPciDev</a>,    <span class="comment">// the PCI device (for bus addr info)</span>
00257                 pChan-&gt;<a class="code" href="struct_d_m_a_channel__t.html#o15">sgList</a>,      <span class="comment">// the place to store the list</span>
00258                 pChan-&gt;<a class="code" href="struct_d_m_a_channel__t.html#o14">numPages</a>,    <span class="comment">// how many initial pages are in it</span>
00259                 pChan-&gt;<a class="code" href="struct_d_m_a_channel__t.html#o17">direction</a>);  <span class="comment">// data flow direction</span>
00260 
00261     <span class="keywordflow">if</span> (pChan-&gt;<a class="code" href="struct_d_m_a_channel__t.html#o16">sgLen</a> == 0)
00262     {
00263         printk(KERN_ERR <span class="stringliteral">"pci_dma_sg failed!\n"</span>);
00264         ret = -ENOMEM;
00265         <span class="keywordflow">goto</span> FREE_SGMEM;
00266     }
00267     
00268 
00269 
00270 <span class="comment">// TODO remove this debugging stuff later</span>
00271     <span class="keywordflow">if</span> (DrvrDebug)
00272     {
00273         <span class="keyword">struct </span>scatterlist *sg = pChan-&gt;<a class="code" href="struct_d_m_a_channel__t.html#o15">sgList</a>;
00274         printk(KERN_INFO <span class="stringliteral">"sgLen = %d\n"</span>, pChan-&gt;<a class="code" href="struct_d_m_a_channel__t.html#o16">sgLen</a>);
00275         <span class="keywordflow">for</span> (i = 0; i &lt; pChan-&gt;<a class="code" href="struct_d_m_a_channel__t.html#o16">sgLen</a>; i++, sg++)
00276         {
00277             printk(KERN_INFO <span class="stringliteral">"sg[%d]: busAddr=%x  len=%d\n"</span>, i, 
00278                             (u32)sg_dma_address(sg),
00279                             sg_dma_len(sg));
00280         }
00281     }
00282 
00283     <span class="keywordflow">return</span>(0);   <span class="comment">// Normal flow. Everthing went OK</span>
00284 
00285 
00286 
00287     <span class="comment">//-------------------------------------------------------------------------</span>
00288     <span class="comment">// The following clean-up after an error condition</span>
00289     <span class="comment">//-------------------------------------------------------------------------</span>
00290 
00291 FREE_SGMEM:
00292     <span class="keywordflow">if</span> (pChan-&gt;<a class="code" href="struct_d_m_a_channel__t.html#o15">sgList</a> != NULL)
00293         kfree(pChan-&gt;<a class="code" href="struct_d_m_a_channel__t.html#o15">sgList</a>);
00294     
00295 
00296     <span class="comment">//-------------------------------------------------------------------------</span>
00297     <span class="comment">// Free the locked-down pages</span>
00298     <span class="comment">//-------------------------------------------------------------------------</span>
00299 FREE_PAGES:
00300     <span class="keywordflow">if</span> (DrvrDebug)
00301         printk(KERN_INFO <span class="stringliteral">"Free pages\n"</span>);
00302     <span class="comment">// Mark pages as dirty, since they've been written to by DMA</span>
00303     <span class="keywordflow">for</span> (i = 0; i &lt; pChan-&gt;<a class="code" href="struct_d_m_a_channel__t.html#o14">numPages</a>; i++)
00304     {
00305         <span class="keywordflow">if</span> (!PageReserved(pChan-&gt;<a class="code" href="struct_d_m_a_channel__t.html#o13">pageList</a>[i]))
00306             SetPageDirty(pChan-&gt;<a class="code" href="struct_d_m_a_channel__t.html#o13">pageList</a>[i]);
00307     }
00308 
00309 
00310     <span class="comment">// Now free up pages from being locked down in memory</span>
00311     <span class="keywordflow">for</span> (i = 0; i &lt; pChan-&gt;<a class="code" href="struct_d_m_a_channel__t.html#o14">numPages</a>; i++)
00312     {
00313         page_cache_release(pChan-&gt;<a class="code" href="struct_d_m_a_channel__t.html#o13">pageList</a>[i]);
00314     }
00315 
00316 FREE_MEM:
00317     <span class="comment">//-------------------------------------------------------------------------</span>
00318     <span class="comment">// Free the array used to hold the list of pages</span>
00319     <span class="comment">//-------------------------------------------------------------------------</span>
00320 
00321     <span class="keywordflow">if</span> (pChan-&gt;<a class="code" href="struct_d_m_a_channel__t.html#o13">pageList</a> != NULL)
00322         kfree(pChan-&gt;<a class="code" href="struct_d_m_a_channel__t.html#o13">pageList</a>);
00323 
00324     <span class="keywordflow">return</span>(ret);
00325 }
00326 
00327 
00328 
00329 
00330 
<a name="l00338"></a><a class="code" href="lscdma_8h.html#a32">00338</a> <span class="keywordtype">int</span> <a class="code" href="lscdma_8h.html#a32">releaseDMAChan</a>(<a class="code" href="struct_p_c_i_e___board.html">pcie_board_t</a> *pBrd,
00339         <a class="code" href="struct_d_m_a_channel__t.html">DMAChannel_t</a> *pChan)
00340 {
00341     <span class="keywordtype">int</span> i;
00342     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> userAddr;
00343     userAddr = (<span class="keywordtype">unsigned</span> long)pChan-&gt;<a class="code" href="struct_d_m_a_channel__t.html#o8">bufBaseVirtualAddr</a>;
00344 
00345 
00346     <span class="keywordflow">if</span> (DrvrDebug)
00347         printk(KERN_INFO <span class="stringliteral">"lscdma: releaseDMAChan  userAddr=%lx\n"</span>, userAddr);
00348 
00349     <span class="comment">//-------------------------------------------------------------------------</span>
00350     <span class="comment">// Free the Scatter/Gather list and invalidate caches affected by</span>
00351     <span class="comment">// the transfer</span>
00352     <span class="comment">//-------------------------------------------------------------------------</span>
00353 
00354     <span class="keywordflow">if</span> (DrvrDebug)
00355         printk(KERN_INFO <span class="stringliteral">"unmap and free SG List\n"</span>);
00356 
00357     pci_unmap_sg(pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o25">pPciDev</a>, 
00358             pChan-&gt;<a class="code" href="struct_d_m_a_channel__t.html#o15">sgList</a>,
00359             pChan-&gt;<a class="code" href="struct_d_m_a_channel__t.html#o16">sgLen</a>,
00360             pChan-&gt;<a class="code" href="struct_d_m_a_channel__t.html#o17">direction</a>);
00361 
00362 
00363     <span class="keywordflow">if</span> (pChan-&gt;<a class="code" href="struct_d_m_a_channel__t.html#o15">sgList</a> != NULL)
00364         kfree(pChan-&gt;<a class="code" href="struct_d_m_a_channel__t.html#o15">sgList</a>);
00365     
00366 
00367     <span class="comment">//-------------------------------------------------------------------------</span>
00368     <span class="comment">// Free the locked-down pages</span>
00369     <span class="comment">//-------------------------------------------------------------------------</span>
00370     <span class="keywordflow">if</span> (DrvrDebug)
00371         printk(KERN_INFO <span class="stringliteral">"Free pages\n"</span>);
00372 
00373     <span class="keywordflow">if</span> (pChan-&gt;<a class="code" href="struct_d_m_a_channel__t.html#o17">direction</a> == PCI_DMA_FROMDEVICE)
00374     {
00375         <span class="comment">// Mark pages as dirty, since they've been written to by DMA</span>
00376         <span class="keywordflow">for</span> (i = 0; i &lt; pChan-&gt;<a class="code" href="struct_d_m_a_channel__t.html#o14">numPages</a>; i++)
00377         {
00378             <span class="keywordflow">if</span> (!PageReserved(pChan-&gt;<a class="code" href="struct_d_m_a_channel__t.html#o13">pageList</a>[i]))
00379                 SetPageDirty(pChan-&gt;<a class="code" href="struct_d_m_a_channel__t.html#o13">pageList</a>[i]);
00380         }
00381     }
00382 
00383 
00384     <span class="comment">// Now free up pages from being locked down in memory</span>
00385     <span class="keywordflow">for</span> (i = 0; i &lt; pChan-&gt;<a class="code" href="struct_d_m_a_channel__t.html#o14">numPages</a>; i++)
00386     {
00387         page_cache_release(pChan-&gt;<a class="code" href="struct_d_m_a_channel__t.html#o13">pageList</a>[i]);
00388     }
00389 
00390 
00391     <span class="comment">//-------------------------------------------------------------------------</span>
00392     <span class="comment">// Free the array used to hold the list of pages</span>
00393     <span class="comment">//-------------------------------------------------------------------------</span>
00394 
00395     <span class="keywordflow">if</span> (pChan-&gt;<a class="code" href="struct_d_m_a_channel__t.html#o13">pageList</a> != NULL)
00396         kfree(pChan-&gt;<a class="code" href="struct_d_m_a_channel__t.html#o13">pageList</a>);
00397 
00398     
00399     <span class="keywordflow">return</span>(OK);
00400 }
00401 
00402 
00403 
00404 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Jul 16 12:05:24 2008 for Lattice PCIeDMA Device Driver  by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
