<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Lattice PCIeDMA Device Driver : Devices.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>Devices.c</h1><a href="_devices_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 
00003 <span class="comment">/*====================================================================================*/</span>
00004 <span class="comment">/*====================================================================================*/</span>
00005 <span class="comment">/*====================================================================================*/</span>
00006 <span class="comment">/*</span>
00007 <span class="comment"> *     HARDWARE REGISTER ACCESS ROUTINES</span>
00008 <span class="comment"> */</span>
00009 <span class="comment">/*====================================================================================*/</span>
00010 <span class="comment">/*====================================================================================*/</span>
00011 <span class="comment">/*====================================================================================*/</span>
00012 
00013 <span class="preprocessor">#include "<a class="code" href="lscdma_8h.html">lscdma.h</a>"</span>
00014 
<a name="l00026"></a><a class="code" href="lscdma_8h.html#a33">00026</a> <span class="keyword">inline</span> UCHAR <a class="code" href="lscdma_8h.html#a33">rdReg8</a>(<a class="code" href="struct_p_c_i_e___board.html">pcie_board_t</a> *pBrd, ULONG offset)
00027 {
00028     <span class="keywordflow">return</span>(readb(pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o24">ctrlBARaddr</a> + offset));
00029 }
00030 
00031 
00032 
00033 
<a name="l00045"></a><a class="code" href="lscdma_8h.html#a34">00045</a> <span class="keyword">inline</span> USHORT <a class="code" href="lscdma_8h.html#a34">rdReg16</a>(<a class="code" href="struct_p_c_i_e___board.html">pcie_board_t</a> *pBrd, ULONG offset)
00046 {
00047     <span class="keywordflow">return</span>(readw(pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o24">ctrlBARaddr</a> + offset));
00048 }
00049 
00050 
00051 
00052 
<a name="l00064"></a><a class="code" href="lscdma_8h.html#a35">00064</a> <span class="keyword">inline</span> ULONG <a class="code" href="lscdma_8h.html#a35">rdReg32</a>(<a class="code" href="struct_p_c_i_e___board.html">pcie_board_t</a> *pBrd, ULONG offset)
00065 {
00066     <span class="keywordflow">return</span>(readl(pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o24">ctrlBARaddr</a> + offset));
00067 }
00068 
00069 
00070 
00071 
<a name="l00082"></a><a class="code" href="lscdma_8h.html#a36">00082</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="lscdma_8h.html#a36">wrReg8</a>(<a class="code" href="struct_p_c_i_e___board.html">pcie_board_t</a> *pBrd, ULONG offset, UCHAR val)
00083 {
00084     writeb(val, pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o24">ctrlBARaddr</a> + offset);
00085 }
00086 
00087 
00088 
<a name="l00099"></a><a class="code" href="lscdma_8h.html#a37">00099</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="lscdma_8h.html#a37">wrReg16</a>(<a class="code" href="struct_p_c_i_e___board.html">pcie_board_t</a> *pBrd, ULONG offset, USHORT val)
00100 {
00101     writew(val, pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o24">ctrlBARaddr</a> + offset);
00102 }
00103 
<a name="l00114"></a><a class="code" href="lscdma_8h.html#a38">00114</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="lscdma_8h.html#a38">wrReg32</a>(<a class="code" href="struct_p_c_i_e___board.html">pcie_board_t</a> *pBrd, ULONG offset, ULONG val)
00115 {
00116     writel(val, pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o24">ctrlBARaddr</a> + offset);
00117 }
00118 
00119 
00120 
00121 
00122 <span class="comment">/*========================================================================*/</span>
00123 <span class="comment">/*========================================================================*/</span>
00124 <span class="comment">/*========================================================================*/</span>
00125 <span class="comment">/*</span>
00126 <span class="comment"> *           Utilities</span>
00127 <span class="comment"> */</span>
00128 <span class="comment">/*========================================================================*/</span>
00129 <span class="comment">/*========================================================================*/</span>
00130 <span class="comment">/*========================================================================*/</span>
00131 
<a name="l00137"></a><a class="code" href="lscdma_8h.html#a39">00137</a> <span class="keywordtype">int</span> <a class="code" href="lscdma_8h.html#a39">ReadPCIConfigRegs</a>(<a class="code" href="struct_p_c_i_e___board.html">pcie_board_t</a> *pBrd)
00138 {
00139     <span class="keywordtype">int</span> status;
00140     <span class="keywordtype">int</span> i;
00141 
00142     <span class="keywordflow">for</span> (i = 0; i &lt; 0x100;  i = i + 4)
00143     {
00144         status = pci_read_config_dword(pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o25">pPciDev</a>, i, &amp;(pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o14">PCICfgRegs</a>[i/4]));
00145         <span class="keywordflow">if</span> (status)
00146         {
00147             printk(KERN_ERR <span class="stringliteral">"lscdma: calling pci_read_config_dword(%d)\n"</span>, i);
00148             <span class="keywordflow">return</span>(status);
00149         }
00150     }
00151     
00152 
00153     <span class="keywordflow">if</span> (DrvrDebug)
00154     {
00155         printk(<span class="stringliteral">"PCICfgRegs 00: %x %x %x %x\n"</span>, pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o14">PCICfgRegs</a>[0], pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o14">PCICfgRegs</a>[1], 
00156                             pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o14">PCICfgRegs</a>[2], pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o14">PCICfgRegs</a>[3]);
00157         printk(<span class="stringliteral">"PCICfgRegs 10: %x %x %x %x\n"</span>, pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o14">PCICfgRegs</a>[4], pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o14">PCICfgRegs</a>[5], 
00158                             pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o14">PCICfgRegs</a>[6], pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o14">PCICfgRegs</a>[7]);
00159         printk(<span class="stringliteral">"PCICfgRegs 20: %x %x %x %x\n"</span>, pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o14">PCICfgRegs</a>[8], pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o14">PCICfgRegs</a>[9], 
00160                             pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o14">PCICfgRegs</a>[10], pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o14">PCICfgRegs</a>[11]);
00161         printk(<span class="stringliteral">"PCICfgRegs 30: %x %x %x %x\n"</span>, pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o14">PCICfgRegs</a>[12], pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o14">PCICfgRegs</a>[13], 
00162                             pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o14">PCICfgRegs</a>[14], pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o14">PCICfgRegs</a>[15]);
00163 
00164     }
00165 
00166     <span class="keywordflow">return</span>(status);
00167 }
00168 
00169 
00170 
<a name="l00182"></a><a class="code" href="lscdma_8h.html#a40">00182</a> <span class="keywordtype">int</span> <a class="code" href="lscdma_8h.html#a40">ParsePCIeLinkCap</a>(<a class="code" href="struct_p_c_i_e___board.html">pcie_board_t</a> *pBrd)
00183 {
00184 
00185     <span class="keywordtype">int</span> i, id, next, index;
00186     u8 *buf;
00187     u32 *pPCI;
00188     u8 *p8;
00189     u16 *p16;
00190     u32 *p32;
00191     <span class="keywordtype">bool</span> found = <span class="keyword">false</span>;
00192 
00193 
00194     pPCI = pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o14">PCICfgRegs</a>;
00195     buf = (u8 *)pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o14">PCICfgRegs</a>;
00196 
00197     <span class="keywordflow">if</span> (<a class="code" href="lscdma_8h.html#a39">ReadPCIConfigRegs</a>(pBrd) != 0)
00198     {
00199         printk(KERN_ERR <span class="stringliteral">"lscdma: Error Reading Config Regs!\n"</span>);
00200         <span class="keywordflow">return</span>(-1);
00201     }
00202         
00203 
00204     <span class="comment">// Now parse the capabilities structures.  The first structure in the list</span>
00205     <span class="comment">// is pointed to by the Capabilities Ptr at location 0x34.  If this is 0</span>
00206     <span class="comment">// or the capabilities bit in the status is 0 then there are none.</span>
00207     <span class="keywordflow">if</span> (((pPCI[STAT_CMD_REG] &amp; 0x00100000) == 0) || (pPCI[CAP_PTR_REG] == 0))
00208     {
00209         printk(KERN_ERR <span class="stringliteral">"lscdma: No PCIE Capabilities Structure!\n"</span>);
00210         <span class="keywordflow">return</span>(-1);
00211     }
00212 
00213     i = 0;
00214     next = (int)pPCI[CAP_PTR_REG] &amp; 0x000000ff;
00215     <span class="keywordflow">while</span> ((next &gt;= 0x40) &amp;&amp; (i &lt; 16))
00216     {
00217         ++i;  <span class="comment">// loop counter to prevent circular loop</span>
00218         index = next;
00219         <span class="keywordtype">id</span> = buf[next];
00220         p8 = (u8 *)&amp;buf[next];
00221         p16 = (u16 *)&amp;buf[next];
00222         p32 = (u32 *)&amp;buf[next];
00223         next = (int)buf[next + 1];
00224         <span class="keywordflow">switch</span>(id)
00225         {
00226             <span class="keywordflow">case</span> 1:  <span class="comment">// Power Management</span>
00227                 printk(<span class="stringliteral">"lscdma: Power Management Capability Structure @ %x\n"</span>, index);
00228                 <span class="keywordflow">break</span>;
00229 
00230             <span class="keywordflow">case</span> 2:  <span class="comment">// AGP Capability</span>
00231                 printk(<span class="stringliteral">"lscdma: AGP Capability Structure @ %x\n"</span>, index);
00232                 <span class="keywordflow">break</span>;
00233 
00234             <span class="keywordflow">case</span> 3:  <span class="comment">// VPD (Vital Product Data) Capability</span>
00235                 printk(<span class="stringliteral">"lscdma: VPD Capability Structure @ %x\n"</span>, index);
00236                 <span class="keywordflow">break</span>;
00237 
00238             <span class="keywordflow">case</span> 4:  <span class="comment">// Slot ID Capability</span>
00239                 printk(<span class="stringliteral">"lscdma: Slot ID Capability Structure @ %x\n"</span>, index);
00240                 <span class="keywordflow">break</span>;
00241 
00242             <span class="keywordflow">case</span> 5:  <span class="comment">// MSI</span>
00243                 printk(<span class="stringliteral">"lscdma: MSI Capability Structure @ %x\n"</span>, index);
00244                 <span class="keywordflow">break</span>;
00245 
00246             <span class="keywordflow">case</span> 6:  <span class="comment">// CompactPCI Hot Swap</span>
00247                 printk(<span class="stringliteral">"lscdma: CompactPCI Capability Structure @ %x\n"</span>, index);
00248                 <span class="keywordflow">break</span>;
00249 
00250             <span class="keywordflow">case</span> 7:  <span class="comment">// PCI-X</span>
00251                 printk(<span class="stringliteral">"lscdma: PCI-X Capability Structure @ %x\n"</span>, index);
00252                 <span class="keywordflow">break</span>;
00253 
00254             <span class="keywordflow">case</span> 8:  <span class="comment">// AMD</span>
00255                 printk(<span class="stringliteral">"lscdma: AMD Capability Structure @ %x\n"</span>, index);
00256                 <span class="keywordflow">break</span>;
00257 
00258             <span class="keywordflow">case</span> 9:  <span class="comment">// Vendor Specific</span>
00259                 printk(<span class="stringliteral">"lscdma: Vendor Specific Capability Structure @ %x\n"</span>, index);
00260                 <span class="keywordflow">break</span>;
00261 
00262             <span class="keywordflow">case</span> 0x0a:  <span class="comment">// Debug Port</span>
00263                 printk(<span class="stringliteral">"lscdma: Debug Port Capability Structure @ %x\n"</span>, index);
00264                 <span class="keywordflow">break</span>;
00265 
00266             <span class="keywordflow">case</span> 0x0b:  <span class="comment">// CompactPCI central resource control</span>
00267                 printk(<span class="stringliteral">"lscdma: CompactPCI resource Capability Structure @ %x\n"</span>, index);
00268                 <span class="keywordflow">break</span>;
00269 
00270             <span class="keywordflow">case</span> 0x0c:  <span class="comment">// PCI Hot Plug</span>
00271                 printk(<span class="stringliteral">"lscdma: PCI Hot Plug Capability Structure @ %x\n"</span>, index);
00272                 <span class="keywordflow">break</span>;
00273 
00274             <span class="keywordflow">case</span> 0x10: <span class="comment">// PCI Express</span>
00275                 printk(<span class="stringliteral">"lscdma: PCI Express Capability Structure @ %x\n"</span>, index);
00276                 pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o11">PCIeMaxReadReqSize</a> = (128&lt;&lt;((p16[4] &amp; 0x7000)&gt;&gt;12));
00277                 pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o10">PCIeMaxPayloadSize</a> = (128&lt;&lt;((p16[4] &amp; 0x0e)&gt;&gt;5));
00278 
00279                 <span class="keywordflow">if</span> (p16[8] &amp; 0x0008)
00280                     pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o12">PCIeRCBSize</a> = 128;
00281                 <span class="keywordflow">else</span>
00282                     pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o12">PCIeRCBSize</a> = 64;
00283 
00284                  pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o13">PCIeLinkWidth</a> = ((p16[9] &amp; 0x03f0)&gt;&gt;4);
00285 
00286                  printk(<span class="stringliteral">"lscdma: MaxPayloadSize = %d\n"</span>, pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o10">PCIeMaxPayloadSize</a>);
00287                  printk(<span class="stringliteral">"lscdma: MaxReadReqSize = %d\n"</span>, pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o11">PCIeMaxReadReqSize</a>);
00288                  printk(<span class="stringliteral">"lscdma: RCBSize = %d\n"</span>, pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o12">PCIeRCBSize</a>);
00289                  printk(<span class="stringliteral">"lscdma: LinkWidth = x%d\n"</span>, pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o13">PCIeLinkWidth</a>);
00290 
00291                 <span class="comment">// Slot Registers and Root Registers not implemented by our EndPoint core</span>
00292                 found = <span class="keyword">true</span>;
00293 
00294                 <span class="keywordflow">break</span>;
00295 
00296 
00297             <span class="keywordflow">default</span>:
00298                 <span class="keywordflow">return</span>( -1);
00299                 <span class="keywordflow">break</span>;
00300 
00301         }
00302 
00303     }
00304 
00305 
00306     <span class="keywordflow">if</span> (found)
00307         <span class="keywordflow">return</span>(0);
00308     <span class="keywordflow">else</span>
00309         <span class="keywordflow">return</span>( -1);
00310 
00311 }
00312 
00313 
00314 
00315 <span class="comment">/*====================================================================================*/</span>
00316 <span class="comment">/*====================================================================================*/</span>
00317 <span class="comment">/*====================================================================================*/</span>
00318 <span class="comment">/*</span>
00319 <span class="comment"> *     GPIO IP BLOCK ROUTINES</span>
00320 <span class="comment"> *</span>
00321 <span class="comment"> * GPIO block has a down counter that can interrupt, so make sure its off.</span>
00322 <span class="comment"> * The interrupt controller is also in the GPIO block so disable all interrupt sources</span>
00323 <span class="comment"> * during initialization.  The individual devices unmask their interrupt during</span>
00324 <span class="comment"> * normal operation, so default state is masked during startup.</span>
00325 <span class="comment"> */</span>
00326 <span class="comment">/*====================================================================================*/</span>
00327 <span class="comment">/*====================================================================================*/</span>
00328 <span class="comment">/*====================================================================================*/</span>
00329 
<a name="l00335"></a><a class="code" href="lscdma_8h.html#a41">00335</a> <span class="keywordtype">int</span> <a class="code" href="lscdma_8h.html#a41">GPIO_Setup</a>(<a class="code" href="struct_p_c_i_e___board.html">pcie_board_t</a> *pBrd)
00336 {
00337     <span class="comment">//--------------------------------------------------------------------------</span>
00338     <span class="comment">// Verify that the hardware we're accessing has the correct IP blocks and </span>
00339     <span class="comment">// versions.  If the ID registers don't match what we expect then abort</span>
00340     <span class="comment">// becasue we don't want to take the chance of enabling interrupts but not</span>
00341     <span class="comment">// being able to control them!  or trying to program SGDMA or other registers</span>
00342     <span class="comment">// and not have the right memory map!</span>
00343     <span class="comment">//--------------------------------------------------------------------------</span>
00344     <span class="keywordflow">if</span> (<a class="code" href="lscdma_8h.html#a35">rdReg32</a>(pBrd, <a class="code" href="_devices_8h.html#a20">GPIO</a>(GPIO_ID_REG)) != GPIO_ID_VALID)
00345      {
00346          printk(KERN_ERR <span class="stringliteral">"ERROR! GPIO IP not found!\n"</span>);
00347          <span class="keywordflow">return</span> (-ENODEV);
00348      }
00349 
00350 
00351     <a class="code" href="lscdma_8h.html#a38">wrReg32</a>(pBrd, <a class="code" href="_devices_8h.html#a20">GPIO</a>(GPIO_CNTRCTRL), 0);   <span class="comment">// disable and reset counter</span>
00352     <a class="code" href="lscdma_8h.html#a38">wrReg32</a>(pBrd, <a class="code" href="_devices_8h.html#a20">GPIO</a>(GPIO_DMAREQ), 0x00000000);    <span class="comment">// Disable till SGDMA ready</span>
00353     <span class="comment">//wrReg16(pBrd, GPIO(GPIO_LED16SEG), (USHORT)0xff00);    // show * on LEDs during init</span>
00354 
00355     <span class="keywordflow">return</span>(OK);
00356 }
00357 
00358 
<a name="l00364"></a><a class="code" href="lscdma_8h.html#a42">00364</a> <span class="keywordtype">int</span> <a class="code" href="lscdma_8h.html#a42">IntrCtrl_Setup</a>(<a class="code" href="struct_p_c_i_e___board.html">pcie_board_t</a> *pBrd)
00365 {
00366     <span class="comment">//--------------------------------------------------------------------------</span>
00367     <span class="comment">// Verify that the hardware we're accessing has the correct IP blocks and </span>
00368     <span class="comment">// versions.  If the ID registers don't match what we expect then abort</span>
00369     <span class="comment">// becasue we don't want to take the chance of enabling interrupts but not</span>
00370     <span class="comment">// being able to control them!  or trying to program SGDMA or other registers</span>
00371     <span class="comment">// and not have the right memory map!</span>
00372     <span class="comment">//--------------------------------------------------------------------------</span>
00373     <span class="keywordflow">if</span> (<a class="code" href="lscdma_8h.html#a35">rdReg32</a>(pBrd, <a class="code" href="_devices_8h.html#a20">GPIO</a>(INTRCTL_ID_REG)) != INTRCTL_ID_VALID)
00374     {
00375         printk(KERN_ERR <span class="stringliteral">"ERROR! INTRCTRL IP not found!\n"</span>);
00376         <span class="keywordflow">return</span> (-ENODEV);
00377     }
00378 
00379     <a class="code" href="lscdma_8h.html#a38">wrReg32</a>(pBrd, <a class="code" href="_devices_8h.html#a20">GPIO</a>(INTRCTL_ENABLE), 0);  <span class="comment">// mask all device interrupts</span>
00380     <a class="code" href="lscdma_8h.html#a38">wrReg32</a>(pBrd, <a class="code" href="_devices_8h.html#a20">GPIO</a>(INTRCTL_CTRL), 0);    <span class="comment">// disable output pin</span>
00381 
00382     <span class="keywordflow">return</span>(OK);
00383 }
00384 
00385 
00386 
00387 <span class="comment">/*====================================================================================*/</span>
00388 <span class="comment">/*====================================================================================*/</span>
00389 <span class="comment">/*====================================================================================*/</span>
00390 <span class="comment">/*</span>
00391 <span class="comment"> *     SCATTER GATHER DMA IP ROUTINES</span>
00392 <span class="comment"> *</span>
00393 <span class="comment"> * For the demo hardware this driver uses, SGDMA channel 0 is wired for writing to</span>
00394 <span class="comment"> * the PCIe core.  Channels 1-4 are wired for sending read requests and then reading</span>
00395 <span class="comment"> * from the PCIe core.  These are the only channels supported by the hardware and </span>
00396 <span class="comment"> * their directions are fixed.</span>
00397 <span class="comment"> */</span>
00398 <span class="comment">/*====================================================================================*/</span>
00399 <span class="comment">/*====================================================================================*/</span>
00400 <span class="comment">/*====================================================================================*/</span>
00401 
<a name="l00408"></a><a class="code" href="lscdma_8h.html#a43">00408</a> <span class="keywordtype">int</span> <a class="code" href="lscdma_8h.html#a43">SGDMA_Init</a>(<a class="code" href="struct_p_c_i_e___board.html">pcie_board_t</a> *pBrd)
00409 {
00410     <span class="comment">// Verify ID</span>
00411 
00412     <span class="comment">// Maybe check number of BDs and Channels</span>
00413 
00414 
00415     <a class="code" href="lscdma_8h.html#a38">wrReg32</a>(pBrd, <a class="code" href="_devices_8h.html#a21">SGDMA</a>(SGDMA_GCONTROL_REG), 0xffff0000);    <span class="comment">// disable and reset all channels and mask REQs</span>
00416     <a class="code" href="lscdma_8h.html#a38">wrReg32</a>(pBrd, <a class="code" href="_devices_8h.html#a21">SGDMA</a>(SGDMA_GSTATUS_REG), 0x00000000);     <span class="comment">// Disable SGDMA till ready</span>
00417 
00418 
00419 
00420     <a class="code" href="lscdma_8h.html#a38">wrReg32</a>(pBrd, <a class="code" href="_devices_8h.html#a21">SGDMA</a>(CHAN_CTRL(0)), 0x00000040);   <span class="comment">// Grp 1, BD base 0, no err mask</span>
00421     <a class="code" href="lscdma_8h.html#a38">wrReg32</a>(pBrd, <a class="code" href="_devices_8h.html#a21">SGDMA</a>(CHAN_PBOFF(0)), 0x00000000);      <span class="comment">//  Pkt Buf offset = 0 (1st block)</span>
00422 
00423     <a class="code" href="lscdma_8h.html#a38">wrReg32</a>(pBrd, <a class="code" href="_devices_8h.html#a21">SGDMA</a>(CHAN_CTRL(1)), 0x00000000);   <span class="comment">// Grp 0, BD base 0, no err mask</span>
00424     <a class="code" href="lscdma_8h.html#a38">wrReg32</a>(pBrd, <a class="code" href="_devices_8h.html#a21">SGDMA</a>(CHAN_PBOFF(1)), 0x00000000);      <span class="comment">//  Pkt Buf offset = 0 (1st block)</span>
00425 
00426 
00427 
00428     <a class="code" href="lscdma_8h.html#a38">wrReg32</a>(pBrd, <a class="code" href="_devices_8h.html#a21">SGDMA</a>(SGDMA_GARBITER_REG), 0xfffc148f);  <span class="comment">// Global Arbiter Control - enable 0 &amp; 1</span>
00429     <a class="code" href="lscdma_8h.html#a38">wrReg32</a>(pBrd, <a class="code" href="_devices_8h.html#a21">SGDMA</a>(SGDMA_GEVENT_REG), 0xfffc0000);   <span class="comment">// Global Event - enable ch0 &amp; 1</span>
00430     <a class="code" href="lscdma_8h.html#a38">wrReg32</a>(pBrd, <a class="code" href="_devices_8h.html#a21">SGDMA</a>(SGDMA_GSTATUS_REG), 0xe0000000);      <span class="comment">// enable buses and DMA engine</span>
00431 
00432     <span class="keywordflow">return</span>(OK);
00433 }
00434 
<a name="l00439"></a><a class="code" href="lscdma_8h.html#a44">00439</a> <span class="keywordtype">void</span> <a class="code" href="lscdma_8h.html#a44">SGDMA_Disable</a>(<a class="code" href="struct_p_c_i_e___board.html">pcie_board_t</a> *pBrd)
00440 {
00441 
00442 
00443     <a class="code" href="lscdma_8h.html#a38">wrReg32</a>(pBrd, <a class="code" href="_devices_8h.html#a21">SGDMA</a>(SGDMA_GCONTROL_REG), 0xffff0000); <span class="comment">// disable and reset all channels and mask REQs</span>
00444     <a class="code" href="lscdma_8h.html#a38">wrReg32</a>(pBrd, <a class="code" href="_devices_8h.html#a21">SGDMA</a>(SGDMA_GSTATUS_REG), 0x00000000);     <span class="comment">// Disable SGDMA and bus accesses</span>
00445 }
00446 
00447 
00448 
<a name="l00457"></a><a class="code" href="lscdma_8h.html#a45">00457</a> <span class="keywordtype">void</span> <a class="code" href="lscdma_8h.html#a45">SGDMA_EnableChan</a>(<a class="code" href="struct_p_c_i_e___board.html">pcie_board_t</a> *pBrd, ULONG chan, ULONG startBD)
00458 {
00459     ULONG x;
00460 
00461     x = <a class="code" href="lscdma_8h.html#a35">rdReg32</a>(pBrd, <a class="code" href="_devices_8h.html#a21">SGDMA</a>(CHAN_CTRL(chan)));
00462     x = x | (startBD&lt;&lt;8);
00463     <a class="code" href="lscdma_8h.html#a38">wrReg32</a>(pBrd, <a class="code" href="_devices_8h.html#a21">SGDMA</a>(CHAN_CTRL(chan)), x);     <span class="comment">// set the BD base (preserve other bits)</span>
00464     <a class="code" href="lscdma_8h.html#a38">wrReg32</a>(pBrd, <a class="code" href="_devices_8h.html#a21">SGDMA</a>(CHAN_PBOFF(chan)), 0x00000000);   <span class="comment">//  Pkt Buf not used</span>
00465 
00466     x = <a class="code" href="lscdma_8h.html#a35">rdReg32</a>(pBrd, <a class="code" href="_devices_8h.html#a21">SGDMA</a>(SGDMA_GARBITER_REG));         <span class="comment">// Enable channel in arbiter (if used)</span>
00467     x = (x &amp; (~(0x00010000&lt;&lt;chan))) | 0x0000148f;  <span class="comment">// unmask channel and set default weights</span>
00468     <a class="code" href="lscdma_8h.html#a38">wrReg32</a>(pBrd, <a class="code" href="_devices_8h.html#a21">SGDMA</a>(SGDMA_GARBITER_REG), x);  <span class="comment">// set Global Arbiter Control</span>
00469 
00470     x = <a class="code" href="lscdma_8h.html#a35">rdReg32</a>(pBrd, <a class="code" href="_devices_8h.html#a21">SGDMA</a>(SGDMA_GEVENT_REG));    
00471     x = (x &amp; (~(0x00010000&lt;&lt;chan)));  <span class="comment">// Unmask events from this channel</span>
00472     <a class="code" href="lscdma_8h.html#a38">wrReg32</a>(pBrd, <a class="code" href="_devices_8h.html#a21">SGDMA</a>(SGDMA_GEVENT_REG), x);  <span class="comment">// set Event register</span>
00473 
00474     x = <a class="code" href="lscdma_8h.html#a35">rdReg32</a>(pBrd, <a class="code" href="_devices_8h.html#a21">SGDMA</a>(SGDMA_GCONTROL_REG));
00475     x = (x &amp; (~(0x00010000&lt;&lt;chan))) | (1&lt;&lt;chan);
00476     <a class="code" href="lscdma_8h.html#a38">wrReg32</a>(pBrd, <a class="code" href="_devices_8h.html#a21">SGDMA</a>(SGDMA_GCONTROL_REG), x);      <span class="comment">// enable and unmask the channel</span>
00477 
00478     <span class="comment">// Make sure the SGDMA is enabled (sometimes diagnostic programs doing peeks and pokes</span>
00479     <span class="comment">// turn of the SGDMA global registers on exit, which could "hang" the driver)</span>
00480     <a class="code" href="lscdma_8h.html#a38">wrReg32</a>(pBrd, <a class="code" href="_devices_8h.html#a21">SGDMA</a>(SGDMA_GSTATUS_REG), 0xe0000000);      <span class="comment">// enable buses and DMA engine</span>
00481 }
00482 
<a name="l00490"></a><a class="code" href="lscdma_8h.html#a46">00490</a> <span class="keywordtype">void</span> <a class="code" href="lscdma_8h.html#a46">SGDMA_DisableChan</a>(<a class="code" href="struct_p_c_i_e___board.html">pcie_board_t</a> *pBrd, ULONG chan)
00491 {
00492     ULONG x;
00493 
00494     x = <a class="code" href="lscdma_8h.html#a35">rdReg32</a>(pBrd, <a class="code" href="_devices_8h.html#a21">SGDMA</a>(SGDMA_GCONTROL_REG));
00495     x = (x | (0x00010000&lt;&lt;chan) ) &amp; ~(1&lt;&lt;chan);      <span class="comment">// mask and disable</span>
00496     <a class="code" href="lscdma_8h.html#a38">wrReg32</a>(pBrd, <a class="code" href="_devices_8h.html#a21">SGDMA</a>(SGDMA_GCONTROL_REG), x);      <span class="comment">//  the channel</span>
00497 
00498     x = <a class="code" href="lscdma_8h.html#a35">rdReg32</a>(pBrd, <a class="code" href="_devices_8h.html#a21">SGDMA</a>(SGDMA_GEVENT_REG));    
00499     x = (x | (0x00010000&lt;&lt;chan));                  <span class="comment">// Mask events from this channel</span>
00500     <a class="code" href="lscdma_8h.html#a38">wrReg32</a>(pBrd, <a class="code" href="_devices_8h.html#a21">SGDMA</a>(SGDMA_GEVENT_REG), x);  <span class="comment">// set Event register</span>
00501 
00502     x = <a class="code" href="lscdma_8h.html#a35">rdReg32</a>(pBrd, <a class="code" href="_devices_8h.html#a21">SGDMA</a>(SGDMA_GARBITER_REG));  
00503     x = (x | (0x00010000&lt;&lt;chan));                    <span class="comment">// Mask channel from being scheduled</span>
00504     <a class="code" href="lscdma_8h.html#a38">wrReg32</a>(pBrd, <a class="code" href="_devices_8h.html#a21">SGDMA</a>(SGDMA_GARBITER_REG), x);  <span class="comment">// set Global Arbiter Control</span>
00505 }
00506 
00507 
<a name="l00524"></a><a class="code" href="lscdma_8h.html#a47">00524</a> <span class="keywordtype">void</span> <a class="code" href="lscdma_8h.html#a47">SGDMA_ConfigWrite</a>(<a class="code" href="struct_p_c_i_e___board.html">pcie_board_t</a> *pBrd,
00525             ULONG chan,
00526             ULONG nBDs,
00527             <span class="keyword">struct</span> scatterlist *pSGlist,
00528             ULONG burstSize)
00529 {
00530     ULONG i;
00531     ULONG dstAddr;
00532     ULONG srcAddr;
00533     ULONG bd;
00534     ULONG len;
00535     ULONG srcAddrMode;
00536     ULONG srcDataSize;
00537     <span class="keyword">struct </span>scatterlist *sg;
00538 
00539 
00540     sg = pSGlist;
00541 
00542     <span class="comment">// Get channels base buffer descriptor</span>
00543     bd = <a class="code" href="lscdma_8h.html#a35">rdReg32</a>(pBrd, <a class="code" href="_devices_8h.html#a21">SGDMA</a>(CHAN_CTRL(chan)));
00544     bd = ((bd&gt;&gt;8) &amp; 0xff);  <span class="comment">// get base BD number</span>
00545 
00546 
00547     srcAddr = pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o7">Chan</a>[chan].<a class="code" href="struct_d_m_a_channel__t.html#o12">DevMem</a>.<a class="code" href="struct_dev_mem_params__t.html#o0">baseAddr</a>;
00548     srcAddrMode = pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o7">Chan</a>[chan].<a class="code" href="struct_d_m_a_channel__t.html#o12">DevMem</a>.<a class="code" href="struct_dev_mem_params__t.html#o2">addrMode</a>;
00549     srcDataSize = pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o7">Chan</a>[chan].<a class="code" href="struct_d_m_a_channel__t.html#o12">DevMem</a>.<a class="code" href="struct_dev_mem_params__t.html#o1">dataWidth</a>;
00550 
00551     <span class="keywordflow">for</span> (i = 0; i &lt; nBDs; i++)
00552     {
00553         <span class="comment">// assumption that length &lt;= PAGE_SIZE &lt;= 4096</span>
00554         len = sg_dma_len(sg);
00555         dstAddr = (u32)sg_dma_address(sg);
00556 
00557         <span class="keywordflow">if</span> (i == (nBDs - 1))
00558             <a class="code" href="lscdma_8h.html#a38">wrReg32</a>(pBrd, <a class="code" href="_devices_8h.html#a21">SGDMA</a>(BD_CFG0(bd)), (DST_MEM | DST_SIZE(DATA_64BIT) | DST_BUS(BUS_B) |  \
00559                               SRC_ADDR_MODE(srcAddrMode) | SRC_SIZE(srcDataSize) | SRC_BUS(BUS_A) | EOL));
00560         <span class="keywordflow">else</span>
00561             <a class="code" href="lscdma_8h.html#a38">wrReg32</a>(pBrd, <a class="code" href="_devices_8h.html#a21">SGDMA</a>(BD_CFG0(bd)), (DST_MEM | DST_SIZE(DATA_64BIT) | DST_BUS(BUS_B) |  \
00562                               SRC_ADDR_MODE(srcAddrMode) | SRC_SIZE(srcDataSize) | SRC_BUS(BUS_A)));
00563         <span class="keywordflow">if</span> (len &lt; burstSize)
00564             <a class="code" href="lscdma_8h.html#a38">wrReg32</a>(pBrd, <a class="code" href="_devices_8h.html#a21">SGDMA</a>(BD_CFG1(bd)), BURST_SIZE(len) | XFER_SIZE(len));
00565         <span class="keywordflow">else</span>
00566             <a class="code" href="lscdma_8h.html#a38">wrReg32</a>(pBrd, <a class="code" href="_devices_8h.html#a21">SGDMA</a>(BD_CFG1(bd)), BURST_SIZE(burstSize) | XFER_SIZE(len));
00567         
00568         <a class="code" href="lscdma_8h.html#a38">wrReg32</a>(pBrd, <a class="code" href="_devices_8h.html#a21">SGDMA</a>(BD_SRC(bd)), <a class="code" href="_devices_8h.html#a26">WB</a>(srcAddr));   <span class="comment">//  source = EBR_64 address</span>
00569         <a class="code" href="lscdma_8h.html#a38">wrReg32</a>(pBrd, <a class="code" href="_devices_8h.html#a21">SGDMA</a>(BD_DST(bd)), dstAddr);  <span class="comment">//  destination = PC page address</span>
00570 
00571         <span class="keywordflow">if</span> (srcAddrMode != ADDR_MODE_FIFO)
00572             srcAddr = srcAddr + len;  <span class="comment">// where to start from next time</span>
00573 
00574         ++bd;    <span class="comment">// next BD</span>
00575         ++sg;    <span class="comment">// next entry in ScatterGather list</span>
00576     }
00577 
00578 }
00579 
00580 
00581 
<a name="l00598"></a><a class="code" href="lscdma_8h.html#a48">00598</a> <span class="keywordtype">void</span> <a class="code" href="lscdma_8h.html#a48">SGDMA_ConfigRead</a>(<a class="code" href="struct_p_c_i_e___board.html">pcie_board_t</a> *pBrd,
00599             ULONG chan,
00600             ULONG nBDs,
00601             <span class="keyword">struct</span> scatterlist *pSGlist,
00602             ULONG burstSize)
00603 {
00604     ULONG i;
00605     ULONG dstAddr;
00606     ULONG srcAddr;
00607     ULONG bd;
00608     ULONG len;
00609     ULONG dstAddrMode;
00610     ULONG dstDataSize;
00611     <span class="keyword">struct </span>scatterlist *sg;
00612 
00613     sg = pSGlist;
00614 
00615     <span class="comment">// Get channels base buffer descriptor</span>
00616     bd = <a class="code" href="lscdma_8h.html#a35">rdReg32</a>(pBrd, <a class="code" href="_devices_8h.html#a21">SGDMA</a>(CHAN_CTRL(chan)));
00617     bd = ((bd&gt;&gt;8) &amp; 0xff);  <span class="comment">// get base BD number</span>
00618 
00619 
00620     dstAddr = pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o7">Chan</a>[chan].<a class="code" href="struct_d_m_a_channel__t.html#o12">DevMem</a>.<a class="code" href="struct_dev_mem_params__t.html#o0">baseAddr</a>;
00621     dstAddrMode = pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o7">Chan</a>[chan].<a class="code" href="struct_d_m_a_channel__t.html#o12">DevMem</a>.<a class="code" href="struct_dev_mem_params__t.html#o2">addrMode</a>;
00622     dstDataSize = pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o7">Chan</a>[chan].<a class="code" href="struct_d_m_a_channel__t.html#o12">DevMem</a>.<a class="code" href="struct_dev_mem_params__t.html#o1">dataWidth</a>;
00623 
00624     <span class="keywordflow">for</span> (i = 0; i &lt; nBDs; i++)
00625     {
00626         <span class="comment">// assumption that length &lt;= PAGE_SIZE &lt;= 4096</span>
00627         len = sg_dma_len(sg);
00628         srcAddr = (u32)sg_dma_address(sg);
00629 
00630         <span class="keywordflow">if</span> (i == (nBDs - 1))
00631             <a class="code" href="lscdma_8h.html#a38">wrReg32</a>(pBrd, <a class="code" href="_devices_8h.html#a21">SGDMA</a>(BD_CFG0(bd)), (DST_ADDR_MODE(dstAddrMode) | DST_SIZE(dstDataSize) | DST_BUS(BUS_A) |  \
00632                           SRC_MEM | SRC_SIZE(DATA_64BIT) | SRC_BUS(BUS_B) | 0xf0 | EOL));
00633         <span class="keywordflow">else</span>
00634             <a class="code" href="lscdma_8h.html#a38">wrReg32</a>(pBrd, <a class="code" href="_devices_8h.html#a21">SGDMA</a>(BD_CFG0(bd)), (DST_ADDR_MODE(dstAddrMode) | DST_SIZE(dstDataSize) | DST_BUS(BUS_A) |  \
00635                           SRC_MEM | SRC_SIZE(DATA_64BIT) | SRC_BUS(BUS_B) | 0xf0));
00636 
00637         <span class="keywordflow">if</span> (len &lt; burstSize)
00638             <a class="code" href="lscdma_8h.html#a38">wrReg32</a>(pBrd, <a class="code" href="_devices_8h.html#a21">SGDMA</a>(BD_CFG1(bd)), BURST_SIZE(len) | XFER_SIZE(len));
00639         <span class="keywordflow">else</span>
00640             <a class="code" href="lscdma_8h.html#a38">wrReg32</a>(pBrd, <a class="code" href="_devices_8h.html#a21">SGDMA</a>(BD_CFG1(bd)), BURST_SIZE(burstSize) | XFER_SIZE(len));
00641         
00642         <a class="code" href="lscdma_8h.html#a38">wrReg32</a>(pBrd, <a class="code" href="_devices_8h.html#a21">SGDMA</a>(BD_SRC(bd)), srcAddr);  <span class="comment">//  source = PC page address</span>
00643         <a class="code" href="lscdma_8h.html#a38">wrReg32</a>(pBrd, <a class="code" href="_devices_8h.html#a21">SGDMA</a>(BD_DST(bd)), <a class="code" href="_devices_8h.html#a26">WB</a>(dstAddr));   <span class="comment">//  destination = EBR_64 address</span>
00644 
00645         <span class="keywordflow">if</span> (dstAddrMode != ADDR_MODE_FIFO)
00646             dstAddr = dstAddr + len;  <span class="comment">// where to start from next time</span>
00647 
00648         ++bd;    <span class="comment">// next BD</span>
00649         ++sg;    <span class="comment">// next Scatter Gather entry</span>
00650     }
00651 
00652 }
00653 
00654 
00655 
00656 
<a name="l00663"></a><a class="code" href="lscdma_8h.html#a49">00663</a> <span class="keywordtype">bool</span> <a class="code" href="lscdma_8h.html#a49">SGDMA_StartWriteChan</a>(<a class="code" href="struct_p_c_i_e___board.html">pcie_board_t</a> *pBrd)
00664 {
00665      ULONG reg;
00666 
00667     reg = <a class="code" href="lscdma_8h.html#a35">rdReg32</a>(pBrd, <a class="code" href="_devices_8h.html#a20">GPIO</a>(INTRCTL_ENABLE));
00668     <span class="comment">// Enable the interrupt bit in the GPIO Interrupt Controller</span>
00669     <a class="code" href="lscdma_8h.html#a38">wrReg32</a>(pBrd,  <a class="code" href="_devices_8h.html#a20">GPIO</a>(INTRCTL_ENABLE),  (reg | INTRCTL_INTR_WR_CHAN));
00670 
00671     <a class="code" href="lscdma_8h.html#a38">wrReg32</a>(pBrd, <a class="code" href="_devices_8h.html#a20">GPIO</a>(GPIO_DMAREQ), 0x0001);   <span class="comment">// trigger DMA chan0</span>
00672 
00673     <span class="keywordflow">return</span>(TRUE);
00674 }
00675 
00676 
<a name="l00683"></a><a class="code" href="lscdma_8h.html#a50">00683</a> <span class="keywordtype">bool</span> <a class="code" href="lscdma_8h.html#a50">SGDMA_StartReadChan</a>(<a class="code" href="struct_p_c_i_e___board.html">pcie_board_t</a> *pBrd)
00684 {
00685      ULONG reg = <a class="code" href="lscdma_8h.html#a35">rdReg32</a>(pBrd, <a class="code" href="_devices_8h.html#a20">GPIO</a>(INTRCTL_ENABLE));
00686 
00687      <span class="comment">// Enable the interrupt bit in the GPIO Interrupt Controller</span>
00688     <a class="code" href="lscdma_8h.html#a38">wrReg32</a>(pBrd, <a class="code" href="_devices_8h.html#a20">GPIO</a>(INTRCTL_ENABLE),  (reg | INTRCTL_INTR_RD_CHAN));
00689     <a class="code" href="lscdma_8h.html#a38">wrReg32</a>(pBrd, <a class="code" href="_devices_8h.html#a20">GPIO</a>(GPIO_DMAREQ), 0x0002);   <span class="comment">// trigger DMA chan1</span>
00690 
00691     <span class="keywordflow">return</span>(TRUE);
00692 }
00693 
00694 
00695 
00696 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Jul 16 12:05:24 2008 for Lattice PCIeDMA Device Driver  by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
