<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Lattice PCIeDMA Device Driver : Main.c File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>Main.c File Reference</h1><code>#include "<a class="el" href="lscdma_8h-source.html">lscdma.h</a>"</code><br>

<p>
<a href="_main_8c-source.html">Go to the source code of this file.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a11" doxytag="Main.c::MODULE_AUTHOR"></a>
&nbsp;</td><td class="memItemRight" valign="bottom"><b>MODULE_AUTHOR</b> ("Lattice Semiconductor")</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a12" doxytag="Main.c::MODULE_DESCRIPTION"></a>
&nbsp;</td><td class="memItemRight" valign="bottom"><b>MODULE_DESCRIPTION</b> ("LSC_PCIe DMA Device Driver")</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a13" doxytag="Main.c::MODULE_LICENSE"></a>
&nbsp;</td><td class="memItemRight" valign="bottom"><b>MODULE_LICENSE</b> ("Dual BSD/GPL")</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a14" doxytag="Main.c::MODULE_ALIAS"></a>
&nbsp;</td><td class="memItemRight" valign="bottom"><b>MODULE_ALIAS</b> ("lscdma")</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a15" doxytag="Main.c::MODULE_DEVICE_TABLE"></a>
&nbsp;</td><td class="memItemRight" valign="bottom"><b>MODULE_DEVICE_TABLE</b> (pci, lscdma_pci_id_tbl)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a16" doxytag="Main.c::DECLARE_WAIT_QUEUE_HEAD"></a>
&nbsp;</td><td class="memItemRight" valign="bottom"><b>DECLARE_WAIT_QUEUE_HEAD</b> (lscdma_ReadQ)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a17" doxytag="Main.c::DECLARE_WAIT_QUEUE_HEAD"></a>
&nbsp;</td><td class="memItemRight" valign="bottom"><b>DECLARE_WAIT_QUEUE_HEAD</b> (lscdma_WriteQ)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_main_8c.html#a18">lscdma_read_procmem</a> (char *buf, char **start, off_t offset, int count, int *eof, void *data)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_main_8c.html#a20">lscdma_open</a> (struct inode *inode, struct file *filp)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_main_8c.html#a21">lscdma_release</a> (struct inode *inode, struct file *filp)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_main_8c.html#a22">lscdma_ioctl</a> (struct inode *inode, struct file *filp, unsigned int cmd, unsigned long arg)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_main_8c.html#a23">lscdma_mmap</a> (struct file *filp, struct vm_area_struct *vma)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">ssize_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_main_8c.html#a24">lscdma_read</a> (struct file *filp, char __user *userBuf, size_t len, loff_t *offp)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">ssize_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_main_8c.html#a25">lscdma_write</a> (struct file *filp, const char __user *userBuf, size_t len, loff_t *offp)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a28" doxytag="Main.c::module_param"></a>
&nbsp;</td><td class="memItemRight" valign="bottom"><b>module_param</b> (debug, int, 0)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a29" doxytag="Main.c::MODULE_PARM_DESC"></a>
&nbsp;</td><td class="memItemRight" valign="bottom"><b>MODULE_PARM_DESC</b> (debug,"lscdma enable debugging (0-1)")</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a32" doxytag="Main.c::module_init"></a>
&nbsp;</td><td class="memItemRight" valign="bottom"><b>module_init</b> (lscdma_init)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a33" doxytag="Main.c::module_exit"></a>
&nbsp;</td><td class="memItemRight" valign="bottom"><b>module_exit</b> (lscdma_exit)</td></tr>

<tr><td colspan="2"><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a3" doxytag="Main.c::DrvrDebug"></a>
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>DrvrDebug</b> = 0</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Generic PCI/PCI-Express Device Driver for Lattice Eval Boards.<p>
NOTE: code has been targeted for RedHat WorkStation 4.0 update 4 kernel 2.6.9-42.ELsmp #1 SMP Wed Jul 12 23:27:17 EDT 2006 i686 i686 i386 GNU/Linux<p>
A Linux kernel device driver, for Lattice PCIe Eval boards on the PCIe bus, that maps the device's PCI address windows (its BAR0-n) into shared memory that is accessible by a user-space driver that implements the real control of the device.<p>
The intent is to map each active BAR to a corresponding minor device so that the user space driver can open that minor device and mmap it to get access to the registers.<p>
The BAR register definitions are Demo/application specific. The driver does not make any assumptions about the number of BARs that exist or their size or use. These are policies of the demo. The driver just makes them available to user space.<p>
The driver places no policies on the use of the device. It simply allows direct access to the PCI memory space occupied by the device. Any number of processes can open the device. It is up to the higher level application space driver to coordinate multiple accesses. The policy is basically the same as a flat memory space embedded system.<p>
The ioctl system call can be used to control interrupts or other global settings of the device.<p>
BUILDING:<p>
Compile as regular user (no need to be root) The product is a kernel module: lscdma.ko<p>
INSTALLING:<p>
Need to be root to install a module.<p>
Use the shell scripts insdrvr and rmdrvr to install and remove the driver. The scripts may perform udev operations to make the devices known to the /dev file system.<p>
Manual: install with system call: /sbin/insmod lscpice.ko remove with system call: /sbin/rmmod lscdma.ko check status of module: cat /proc/modules cat /proc/devices<p>
The printk() messages can be seen by running the command dmesg.<p>
The Major device number is dynamically assigned. This info can be found in /proc/devices.<p>
Diagnostic information can be seen with: cat /proc/driver/lscdma<p>
The minor number refers to the specific device. Previous incarnations used the minor number to encode the board and BAR to access. This has been abandoned, and the minor now referes to the specific device controlled by this driver (i.e. the eval board). Once open() the user has access to all BARs and board resources through the same file descriptor. The user space code knows how many BARs are active via ioctl calls to return the PCI resource info.<p>
Diagnostic information can be seen with: cat /proc/driver/lscdma<p>
The standard read/write system operations are not implemented because the user has direct access to the device registers via a standard pointer.<p>
This driver implements the 2.6 kernel method of sysfs and probing to register the driver, discover devices and make them available to user space programs. A major player is creating a specific Class lscdma which<p>
register it with the PCI subsystem to probe for the eval board(s) register it as a character device (cdev) so it can get a major number and minor numbers create a special sysfs Class and add each discovered device under the class udev processes the /sys/class/ tree to populate<p>
BASED ON: Original lscpcie Linux driver which did things the 2.4 kernel way
<p>
Definition in file <a class="el" href="_main_8c-source.html">Main.c</a>.<hr><h2>Function Documentation</h2>
<a class="anchor" name="a22" doxytag="Main.c::lscdma_ioctl"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int lscdma_ioctl           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct inode *&nbsp;</td>
          <td class="mdname" nowrap> <em>inode</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>struct file *&nbsp;</td>
          <td class="mdname" nowrap> <em>filp</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>unsigned long&nbsp;</td>
          <td class="mdname" nowrap> <em>arg</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
ioctl. Allow simple access to generic PCI control type things like enabling device interrupts and such. IOCTL works on a board object as a whole, not a BAR. 
<p>
Definition at line <a class="el" href="_main_8c-source.html#l00929">929</a> of file <a class="el" href="_main_8c-source.html">Main.c</a>.
<p>
References <a class="el" href="lscdma_8h-source.html#l00211">PCI_Dev_BAR::bar</a>, <a class="el" href="_ioctl_8h-source.html#l00070">PCIResourceInfo_t::BAR</a>, <a class="el" href="_ioctl_8h-source.html#l00092">DMAResourceInfo_t::busNum</a>, <a class="el" href="lscdma_8h-source.html#l00281">PCIE_Board::CBDMA</a>, <a class="el" href="lscdma_8h-source.html#l00263">PCIE_Board::Dev_BARs</a>, <a class="el" href="_ioctl_8h-source.html#l00093">DMAResourceInfo_t::deviceNum</a>, <a class="el" href="_ioctl_8h-source.html#l00090">DMAResourceInfo_t::devID</a>, <a class="el" href="_ioctl_8h-source.html#l00100">DMAResourceInfo_t::DmaAddr64</a>, <a class="el" href="lscdma_8h-source.html#l00196">CBDMAOperations_t::dmaBufSize</a>, <a class="el" href="_ioctl_8h-source.html#l00099">DMAResourceInfo_t::DmaBufSize</a>, <a class="el" href="lscdma_8h-source.html#l00198">CBDMAOperations_t::dmaCPUAddr</a>, <a class="el" href="lscdma_8h-source.html#l00197">CBDMAOperations_t::dmaPCIBusAddr</a>, <a class="el" href="_ioctl_8h-source.html#l00101">DMAResourceInfo_t::DmaPhyAddrHi</a>, <a class="el" href="_ioctl_8h-source.html#l00102">DMAResourceInfo_t::DmaPhyAddrLo</a>, <a class="el" href="_ioctl_8h-source.html#l00050">PCI_BAR_t::flags</a>, <a class="el" href="_ioctl_8h-source.html#l00094">DMAResourceInfo_t::functionNum</a>, <a class="el" href="lscdma_8h-source.html#l00194">CBDMAOperations_t::hasDMA</a>, <a class="el" href="_ioctl_8h-source.html#l00098">DMAResourceInfo_t::hasDmaBuf</a>, <a class="el" href="_ioctl_8h-source.html#l00074">PCIResourceInfo_t::hasInterrupt</a>, <a class="el" href="_ioctl_8h-source.html#l00075">PCIResourceInfo_t::intrVector</a>, <a class="el" href="_ioctl_8h-source.html#l00203">IOCTL_LSCDMA_GET_DMA_INFO</a>, <a class="el" href="_ioctl_8h-source.html#l00187">IOCTL_LSCDMA_GET_DMA_TIMERS</a>, <a class="el" href="_ioctl_8h-source.html#l00172">IOCTL_LSCDMA_READ_SYSDMABUF</a>, <a class="el" href="_ioctl_8h-source.html#l00194">IOCTL_LSCDMA_SET_BURST_SIZES</a>, <a class="el" href="_ioctl_8h-source.html#l00180">IOCTL_LSCDMA_WRITE_SYSDMABUF</a>, <a class="el" href="_ioctl_8h-source.html#l00154">IOCTL_LSCPCIE_GET_RESOURCES</a>, <a class="el" href="_ioctl_8h-source.html#l00148">IOCTL_LSCPCIE_GET_VERSION_INFO</a>, <a class="el" href="_ioctl_8h-source.html#l00159">IOCTL_LSCPCIE_SET_BAR</a>, <a class="el" href="lscdma_8h-source.html#l00254">PCIE_Board::IRQ</a>, <a class="el" href="lscdma_8h-source.html#l00213">PCI_Dev_BAR::kvm_addr</a>, <a class="el" href="lscdma_8h-source.html#l00216">PCI_Dev_BAR::len</a>, <a class="el" href="_ioctl_8h-source.html#l00108">DMAResourceInfo_t::LinkWidth</a>, <a class="el" href="_ioctl_8h-source.html#l00105">DMAResourceInfo_t::MaxPayloadSize</a>, <a class="el" href="_ioctl_8h-source.html#l00106">DMAResourceInfo_t::MaxReadReqSize</a>, <a class="el" href="_ioctl_8h-source.html#l00049">PCI_BAR_t::memMapped</a>, <a class="el" href="lscdma_8h-source.html#l00214">PCI_Dev_BAR::memType</a>, <a class="el" href="lscdma_8h-source.html#l00244">PCIE_Board::minorNum</a>, <a class="el" href="lscdma_8h-source.html#l00265">PCIE_Board::mmapBAR</a>, <a class="el" href="_ioctl_8h-source.html#l00046">PCI_BAR_t::nBAR</a>, <a class="el" href="lscdma_8h-source.html#l00264">PCIE_Board::numBars</a>, <a class="el" href="_ioctl_8h-source.html#l00069">PCIResourceInfo_t::numBARs</a>, <a class="el" href="lscdma_8h-source.html#l00212">PCI_Dev_BAR::pci_addr</a>, <a class="el" href="lscdma_8h-source.html#l00219">PCI_Dev_BAR::pci_flags</a>, <a class="el" href="_ioctl_8h-source.html#l00071">PCIResourceInfo_t::PCICfgReg</a>, <a class="el" href="lscdma_8h.html#a23">pcie_board_t</a>, <a class="el" href="lscdma_8h-source.html#l00248">PCIE_Board::PCIeLinkWidth</a>, <a class="el" href="lscdma_8h-source.html#l00245">PCIE_Board::PCIeMaxPayloadSize</a>, <a class="el" href="lscdma_8h-source.html#l00246">PCIE_Board::PCIeMaxReadReqSize</a>, <a class="el" href="lscdma_8h-source.html#l00247">PCIE_Board::PCIeRCBSize</a>, <a class="el" href="_ioctl_8h-source.html#l00047">PCI_BAR_t::physStartAddr</a>, <a class="el" href="lscdma_8h-source.html#l00272">PCIE_Board::pPciDev</a>, <a class="el" href="_ioctl_8h-source.html#l00107">DMAResourceInfo_t::RCBSize</a>, <a class="el" href="_ioctl_8h-source.html#l00048">PCI_BAR_t::size</a>, <a class="el" href="_ioctl_8h-source.html#l00051">PCI_BAR_t::type</a>, and <a class="el" href="_ioctl_8h-source.html#l00095">DMAResourceInfo_t::UINumber</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a23" doxytag="Main.c::lscdma_mmap"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int lscdma_mmap           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct file *&nbsp;</td>
          <td class="mdname" nowrap> <em>filp</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>struct vm_area_struct *&nbsp;</td>
          <td class="mdname" nowrap> <em>vma</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
mmap. This is the most important driver method. This maps the device's PCI address space (based on the select mmap BAR number) into the user's address space, allowing direct memory access with standard pointers. 
<p>
Definition at line <a class="el" href="_main_8c-source.html#l01133">1133</a> of file <a class="el" href="_main_8c-source.html">Main.c</a>.
<p>
References <a class="el" href="lscdma_8h-source.html#l00211">PCI_Dev_BAR::bar</a>, <a class="el" href="lscdma_8h-source.html#l00263">PCIE_Board::Dev_BARs</a>, <a class="el" href="lscdma_8h-source.html#l00216">PCI_Dev_BAR::len</a>, <a class="el" href="lscdma_8h-source.html#l00244">PCIE_Board::minorNum</a>, <a class="el" href="lscdma_8h-source.html#l00265">PCIE_Board::mmapBAR</a>, <a class="el" href="lscdma_8h-source.html#l00212">PCI_Dev_BAR::pci_addr</a>, <a class="el" href="lscdma_8h.html#a22">pci_dev_bar_t</a>, and <a class="el" href="lscdma_8h.html#a23">pcie_board_t</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a20" doxytag="Main.c::lscdma_open"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int lscdma_open           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct inode *&nbsp;</td>
          <td class="mdname" nowrap> <em>inode</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>struct file *&nbsp;</td>
          <td class="mdname" nowrap> <em>filp</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Open a device. A device (Lattice PCIe Eval Board) can only be open by one user at a time. The main reason is to simplify the control logic. If multiple programs could open the same device, there would be contention for resources (there is only one SGDMA IP core with only 1 read channel and 1 write channel). Multiple users would have to wait, for their turn to use the IP by placing the requests into a Q, and processing them serialy. But why even bother. The usage model here is to only run 1 demo at a time anyway, so only one application will ever need to open the device at a time.<p>
The minor number is the index into the Board[] list. It specifies exactly what board and is correlated to the device node filename. Only valid board devices that have been enumerated by probe() and initialized are in the list, are in /sys/class/lscdma/ and should appear in /dev/lscdma/<p>
The interrupts are connected in this routine. This follows the recommended flow for modules, where interrupt resources aren't claimed until a user actually opens and needs them, and are released when the device is closed, so they can be available for some other device.<p>
Note that the PCI device has already been enabled in probe() and init() so it doesn't need to be done again. 
<p>
Definition at line <a class="el" href="_main_8c-source.html#l00564">564</a> of file <a class="el" href="_main_8c-source.html">Main.c</a>.
<p>
References <a class="el" href="lscdma_8h-source.html#l00122">DevMemParams_t::addrMode</a>, <a class="el" href="lscdma_8h-source.html#l00120">DevMemParams_t::baseAddr</a>, <a class="el" href="lscdma_8h-source.html#l00313">LSCDMA::Board</a>, <a class="el" href="lscdma_8h-source.html#l00177">SGDMAOperations_t::Chan</a>, <a class="el" href="lscdma_8h-source.html#l00121">DevMemParams_t::dataWidth</a>, <a class="el" href="lscdma_8h-source.html#l00148">DMAChannel_t::DevMem</a>, <a class="el" href="_devices_8h-source.html#l00096">EBR64_SIZE</a>, <a class="el" href="_devices_8h-source.html#l00095">EBR_64</a>, <a class="el" href="lscdma_8h-source.html#l00233">PCIE_Board::function</a>, <a class="el" href="_devices_8h-source.html#l00092">GPIO</a>, <a class="el" href="lscdma_8h-source.html#l00230">PCIE_Board::ID</a>, <a class="el" href="_devices_8h-source.html#l00094">IMG_FIFO</a>, <a class="el" href="_devices_8h-source.html#l00097">IMG_FIFO_FRAME_SIZE</a>, <a class="el" href="lscdma_8h-source.html#l00256">PCIE_Board::InterruptCounter</a>, <a class="el" href="lscdma_8h-source.html#l00254">PCIE_Board::IRQ</a>, <a class="el" href="_i_s_r_8c-source.html#l00059">IsrDisableInterrupts()</a>, <a class="el" href="_i_s_r_8c-source.html#l00076">IsrEnableInterrupts()</a>, <a class="el" href="lscdma_8h-source.html#l00258">PCIE_Board::isrTasklet</a>, <a class="el" href="_i_s_r_8c-source.html#l00094">lscdma_ISR()</a>, <a class="el" href="_i_s_r_8c-source.html#l00139">lscdma_isr_tasklet()</a>, <a class="el" href="lscdma_8h-source.html#l00123">DevMemParams_t::maxAddrRange</a>, <a class="el" href="lscdma_8h-source.html#l00255">PCIE_Board::msi</a>, <a class="el" href="lscdma_8h-source.html#l00298">LSCDMA::numBoards</a>, <a class="el" href="lscdma_8h-source.html#l00238">PCIE_Board::OpenToken</a>, <a class="el" href="lscdma_8h.html#a23">pcie_board_t</a>, <a class="el" href="lscdma_8h-source.html#l00272">PCIE_Board::pPciDev</a>, <a class="el" href="lscdma_8h-source.html#l00174">SGDMAOperations_t::ReadChanOpen</a>, <a class="el" href="lscdma_8h-source.html#l00278">PCIE_Board::SGDMA</a>, <a class="el" href="_devices_8c-source.html#l00408">SGDMA_Init()</a>, <a class="el" href="lscdma_8h-source.html#l00175">SGDMAOperations_t::WriteChanOpen</a>, and <a class="el" href="_devices_8c-source.html#l00114">wrReg32()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a24" doxytag="Main.c::lscdma_read"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">ssize_t lscdma_read           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct file *&nbsp;</td>
          <td class="mdname" nowrap> <em>filp</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>char __user *&nbsp;</td>
          <td class="mdname" nowrap> <em>userBuf</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>size_t&nbsp;</td>
          <td class="mdname" nowrap> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>loff_t *&nbsp;</td>
          <td class="mdname" nowrap> <em>offp</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
read. Read from system CommonBuffer DMA memory into users buffer. User passes length (in bytes) like reading from a file. 
<p>
Definition at line <a class="el" href="_main_8c-source.html#l01211">1211</a> of file <a class="el" href="_main_8c-source.html">Main.c</a>.
<p>
References <a class="el" href="lscdma_8h-source.html#l00134">DMAChannel_t::cancelDMA</a>, <a class="el" href="lscdma_8h-source.html#l00177">SGDMAOperations_t::Chan</a>, <a class="el" href="lscdma_8h-source.html#l00131">DMAChannel_t::dmaMutex</a>, <a class="el" href="lscdma_8h-source.html#l00133">DMAChannel_t::doneDMA</a>, <a class="el" href="lscdma_8h-source.html#l00233">PCIE_Board::function</a>, <a class="el" href="lscdma_8h-source.html#l00239">PCIE_Board::hdwAccess</a>, <a class="el" href="_d_m_a_8c-source.html#l00114">initDMAChan()</a>, <a class="el" href="lscdma_8h.html#a23">pcie_board_t</a>, <a class="el" href="lscdma_8h-source.html#l00172">SGDMAOperations_t::Reading</a>, <a class="el" href="lscdma_8h-source.html#l00179">SGDMAOperations_t::ReadWaitQ</a>, <a class="el" href="_d_m_a_8c-source.html#l00338">releaseDMAChan()</a>, <a class="el" href="lscdma_8h-source.html#l00278">PCIE_Board::SGDMA</a>, <a class="el" href="_devices_8c-source.html#l00490">SGDMA_DisableChan()</a>, <a class="el" href="_d_m_a_8c-source.html#l00024">StartDmaWrite()</a>, and <a class="el" href="lscdma_8h-source.html#l00135">DMAChannel_t::xferStatus</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a18" doxytag="Main.c::lscdma_read_procmem"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int lscdma_read_procmem           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">char *&nbsp;</td>
          <td class="mdname" nowrap> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>char **&nbsp;</td>
          <td class="mdname" nowrap> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>off_t&nbsp;</td>
          <td class="mdname" nowrap> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>count</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>eof</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>data</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Procedure to format and display data into the /proc filesystem when a user cats the /proc/driver/lscpie2 file. 
<p>
Definition at line <a class="el" href="_main_8c-source.html#l00186">186</a> of file <a class="el" href="_main_8c-source.html">Main.c</a>.
<p>
References <a class="el" href="lscdma_8h-source.html#l00313">LSCDMA::Board</a>, <a class="el" href="lscdma_8h-source.html#l00215">PCI_Dev_BAR::dataSize</a>, <a class="el" href="lscdma_8h-source.html#l00231">PCIE_Board::demoID</a>, <a class="el" href="lscdma_8h-source.html#l00263">PCIE_Board::Dev_BARs</a>, <a class="el" href="lscdma_8h-source.html#l00297">LSCDMA::drvrDevNum</a>, <a class="el" href="lscdma_8h-source.html#l00230">PCIE_Board::ID</a>, <a class="el" href="lscdma_8h-source.html#l00235">PCIE_Board::instanceNum</a>, <a class="el" href="lscdma_8h-source.html#l00254">PCIE_Board::IRQ</a>, <a class="el" href="lscdma_8h-source.html#l00213">PCI_Dev_BAR::kvm_addr</a>, <a class="el" href="lscdma_8h-source.html#l00216">PCI_Dev_BAR::len</a>, <a class="el" href="lscdma_8h-source.html#l00214">PCI_Dev_BAR::memType</a>, <a class="el" href="lscdma_8h-source.html#l00298">LSCDMA::numBoards</a>, <a class="el" href="lscdma_8h-source.html#l00212">PCI_Dev_BAR::pci_addr</a>, <a class="el" href="lscdma_8h.html#a22">pci_dev_bar_t</a>, <a class="el" href="lscdma_8h-source.html#l00218">PCI_Dev_BAR::pci_end</a>, <a class="el" href="lscdma_8h-source.html#l00219">PCI_Dev_BAR::pci_flags</a>, and <a class="el" href="lscdma_8h-source.html#l00217">PCI_Dev_BAR::pci_start</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a21" doxytag="Main.c::lscdma_release"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int lscdma_release           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct inode *&nbsp;</td>
          <td class="mdname" nowrap> <em>inode</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>struct file *&nbsp;</td>
          <td class="mdname" nowrap> <em>filp</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Close. The complement to open().<p>
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!<p>
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 
<p>
Definition at line <a class="el" href="_main_8c-source.html#l00848">848</a> of file <a class="el" href="_main_8c-source.html">Main.c</a>.
<p>
References <a class="el" href="lscdma_8h-source.html#l00134">DMAChannel_t::cancelDMA</a>, <a class="el" href="lscdma_8h-source.html#l00177">SGDMAOperations_t::Chan</a>, <a class="el" href="_devices_8h-source.html#l00092">GPIO</a>, <a class="el" href="lscdma_8h-source.html#l00254">PCIE_Board::IRQ</a>, <a class="el" href="_i_s_r_8c-source.html#l00059">IsrDisableInterrupts()</a>, <a class="el" href="lscdma_8h-source.html#l00255">PCIE_Board::msi</a>, <a class="el" href="lscdma_8h-source.html#l00238">PCIE_Board::OpenToken</a>, <a class="el" href="lscdma_8h-source.html#l00272">PCIE_Board::pPciDev</a>, <a class="el" href="lscdma_8h-source.html#l00174">SGDMAOperations_t::ReadChanOpen</a>, <a class="el" href="lscdma_8h-source.html#l00172">SGDMAOperations_t::Reading</a>, <a class="el" href="lscdma_8h-source.html#l00278">PCIE_Board::SGDMA</a>, <a class="el" href="_devices_8c-source.html#l00490">SGDMA_DisableChan()</a>, <a class="el" href="lscdma_8h-source.html#l00175">SGDMAOperations_t::WriteChanOpen</a>, <a class="el" href="lscdma_8h-source.html#l00173">SGDMAOperations_t::Writing</a>, and <a class="el" href="_devices_8c-source.html#l00114">wrReg32()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a25" doxytag="Main.c::lscdma_write"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">ssize_t lscdma_write           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">struct file *&nbsp;</td>
          <td class="mdname" nowrap> <em>filp</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const char __user *&nbsp;</td>
          <td class="mdname" nowrap> <em>userBuf</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>size_t&nbsp;</td>
          <td class="mdname" nowrap> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>loff_t *&nbsp;</td>
          <td class="mdname" nowrap> <em>offp</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
write. Write from users buffer into system CommonBuffer DMA memory. User passes length (in bytes) like writing to a file. 
<p>
Definition at line <a class="el" href="_main_8c-source.html#l01305">1305</a> of file <a class="el" href="_main_8c-source.html">Main.c</a>.
<p>
References <a class="el" href="lscdma_8h-source.html#l00134">DMAChannel_t::cancelDMA</a>, <a class="el" href="lscdma_8h-source.html#l00177">SGDMAOperations_t::Chan</a>, <a class="el" href="lscdma_8h-source.html#l00131">DMAChannel_t::dmaMutex</a>, <a class="el" href="lscdma_8h-source.html#l00133">DMAChannel_t::doneDMA</a>, <a class="el" href="lscdma_8h-source.html#l00233">PCIE_Board::function</a>, <a class="el" href="lscdma_8h-source.html#l00239">PCIE_Board::hdwAccess</a>, <a class="el" href="_d_m_a_8c-source.html#l00114">initDMAChan()</a>, <a class="el" href="lscdma_8h.html#a23">pcie_board_t</a>, <a class="el" href="_d_m_a_8c-source.html#l00338">releaseDMAChan()</a>, <a class="el" href="lscdma_8h-source.html#l00278">PCIE_Board::SGDMA</a>, <a class="el" href="_devices_8c-source.html#l00490">SGDMA_DisableChan()</a>, <a class="el" href="_d_m_a_8c-source.html#l00065">StartDmaRead()</a>, <a class="el" href="lscdma_8h-source.html#l00180">SGDMAOperations_t::WriteWaitQ</a>, <a class="el" href="lscdma_8h-source.html#l00173">SGDMAOperations_t::Writing</a>, and <a class="el" href="lscdma_8h-source.html#l00135">DMAChannel_t::xferStatus</a>.    </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Wed Jul 16 12:05:24 2008 for Lattice PCIeDMA Device Driver  by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
