<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Lattice PCIeDMA Device Driver : ISR.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>ISR.c</h1><a href="_i_s_r_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 
00003 <span class="comment">/*========================================================================*/</span>
00004 <span class="comment">/*========================================================================*/</span>
00005 <span class="comment">/*========================================================================*/</span>
00006 <span class="comment">/*</span>
00007 <span class="comment"> *           INTERRUPT HANDLER AND TASKLET</span>
00008 <span class="comment"> */</span>
00009 <span class="comment">/*========================================================================*/</span>
00010 <span class="comment">/*========================================================================*/</span>
00011 <span class="comment">/*========================================================================*/</span>
00054 <span class="preprocessor">#include "<a class="code" href="lscdma_8h.html">lscdma.h</a>"</span>
00055 
00056 
00060 <span class="keywordtype">bool</span> <a class="code" href="lscdma_8h.html#a26">IsrDisableInterrupts</a>(<a class="code" href="struct_p_c_i_e___board.html">pcie_board_t</a> *pBrd)
00061 {
00062     ULONG intCtrl;
00063 
00064     intCtrl = <a class="code" href="lscdma_8h.html#a35">rdReg32</a>(pBrd, <a class="code" href="_devices_8h.html#a20">GPIO</a>(INTRCTL_CTRL));
00065     intCtrl = intCtrl &amp; ~INTRCTL_OUTPUT_EN;     <span class="comment">// turn off the interrupt output  </span>
00066     <a class="code" href="lscdma_8h.html#a38">wrReg32</a>(pBrd, <a class="code" href="_devices_8h.html#a20">GPIO</a>(INTRCTL_CTRL), intCtrl);
00067 
00068     pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o18">InterruptsEnabled</a> = <span class="keyword">false</span>;
00069     <span class="keywordflow">return</span>(<span class="keyword">true</span>);
00070 }
00071 
00072 
00077 <span class="keywordtype">bool</span> <a class="code" href="lscdma_8h.html#a25">IsrEnableInterrupts</a>(<a class="code" href="struct_p_c_i_e___board.html">pcie_board_t</a> *pBrd)
00078 {
00079     ULONG intCtrl;
00080     intCtrl = <a class="code" href="lscdma_8h.html#a35">rdReg32</a>(pBrd, <a class="code" href="_devices_8h.html#a20">GPIO</a>(INTRCTL_CTRL));
00081     intCtrl = intCtrl | INTRCTL_OUTPUT_EN;  <span class="comment">// turn on the interrupt output  </span>
00082     <a class="code" href="lscdma_8h.html#a38">wrReg32</a>(pBrd, <a class="code" href="_devices_8h.html#a20">GPIO</a>(INTRCTL_CTRL), intCtrl);
00083 
00084     pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o18">InterruptsEnabled</a> = <span class="keyword">true</span>;
00085     <span class="keywordflow">return</span>(<span class="keyword">true</span>);
00086 }
00087 
00088 
00095 irqreturn_t <a class="code" href="lscdma_8h.html#a27">lscdma_ISR</a>(<span class="keywordtype">int</span> irq, <span class="keywordtype">void</span> *dev_id, <span class="keyword">struct</span> pt_regs *regs)
00096 {
00097     ULONG intCtrl;
00098     ULONG led;
00099 
00100     <a class="code" href="struct_p_c_i_e___board.html">pcie_board_t</a> *pBrd = dev_id; 
00101     
00102     <span class="comment">// check if we interrupted</span>
00103     intCtrl = <a class="code" href="lscdma_8h.html#a35">rdReg32</a>(pBrd, <a class="code" href="_devices_8h.html#a20">GPIO</a>(INTRCTL_CTRL));
00104 
00105     <span class="keywordflow">if</span> ((intCtrl &amp; INTRCTL_OUT_ACTIVE) == 0)
00106         <span class="keywordflow">return</span>(IRQ_NONE);    <span class="comment">// not our interrupt</span>
00107 
00108 
00109     <span class="comment">// Disable the interrupt in the standard GPIO interrupt controller IP block.</span>
00110     <span class="comment">// This prevents an infinite loop.  The Deferred Tasklet needs to figure out which</span>
00111     <span class="comment">// specific IP device on the board/FPGA is generating the interrupt(s) and </span>
00112     <span class="comment">// service and clear all of them before re-enabling the main interrupt controller.</span>
00113 
00114     
00115     spin_lock(&amp;pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o7">hdwAccess</a>);   <span class="comment">// prevent SMP access to these registers</span>
00116     {
00117         <a class="code" href="lscdma_8h.html#a26">IsrDisableInterrupts</a>(pBrd);
00118 
00119         <span class="comment">// Increment the count of interrupts received</span>
00120         ++pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o17">InterruptCounter</a>;
00121 
00122         <span class="comment">// For testing - show ISR count on outer seg LEDs of 16 seg</span>
00123         led = <a class="code" href="lscdma_8h.html#a35">rdReg32</a>(pBrd, <a class="code" href="_devices_8h.html#a20">GPIO</a>(GPIO_LED16SEG));
00124         led = (led &amp; 0xffffff00) | (pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o17">InterruptCounter</a> &amp; 0xff);
00125         <a class="code" href="lscdma_8h.html#a38">wrReg32</a>(pBrd, <a class="code" href="_devices_8h.html#a20">GPIO</a>(GPIO_LED16SEG), led);
00126     }
00127     spin_unlock(&amp;pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o7">hdwAccess</a>);
00128 
00129     <span class="comment">// schedule the board's tasklet to run and do real interrupt processing</span>
00130     tasklet_schedule(&amp;(pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o19">isrTasklet</a>));
00131 
00132     <span class="keywordflow">return</span>(IRQ_HANDLED);  <span class="comment">// serviced the interrupt</span>
00133 }
00134 
00135 
00140 <span class="keywordtype">void</span> <a class="code" href="lscdma_8h.html#a28">lscdma_isr_tasklet</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> arg)
00141 {
00142     ULONG led;
00143     <a class="code" href="struct_p_c_i_e___board.html">pcie_board_t</a> *pBrd = (<a class="code" href="struct_p_c_i_e___board.html">pcie_board_t</a> *)arg;
00144     ULONG loopCnt = 1000;
00145     ULONG xferSize;
00146     uint32_t dmaStatus;
00147     uint32_t reg;
00148     uint32_t intrStatus, intrCtrl, intrEnable;
00149     uint32_t service;
00150     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> irqFlag;
00151 
00152     
00153     spin_lock_irqsave(&amp;pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o7">hdwAccess</a>, irqFlag);
00154     {
00155         <span class="comment">// For testing - show count on inner ring of 16segLEDs</span>
00156         led = <a class="code" href="lscdma_8h.html#a35">rdReg32</a>(pBrd, <a class="code" href="_devices_8h.html#a20">GPIO</a>(GPIO_LED16SEG));
00157         led = (led &amp; 0xffff00ff) | ((pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o17">InterruptCounter</a> &amp; 0xff)&lt;&lt;8);
00158         <a class="code" href="lscdma_8h.html#a38">wrReg32</a>(pBrd, <a class="code" href="_devices_8h.html#a20">GPIO</a>(GPIO_LED16SEG), led);
00159 
00160         <span class="comment">// These should all be read together so values are consistent</span>
00161         intrCtrl =  <a class="code" href="lscdma_8h.html#a35">rdReg32</a>(pBrd, <a class="code" href="_devices_8h.html#a20">GPIO</a>(INTRCTL_CTRL));
00162         intrStatus =  <a class="code" href="lscdma_8h.html#a35">rdReg32</a>(pBrd, <a class="code" href="_devices_8h.html#a20">GPIO</a>(INTRCTL_STATUS));
00163         intrEnable =  <a class="code" href="lscdma_8h.html#a35">rdReg32</a>(pBrd, <a class="code" href="_devices_8h.html#a20">GPIO</a>(INTRCTL_ENABLE));
00164     }
00165     spin_unlock_irqrestore(&amp;pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o7">hdwAccess</a>, irqFlag);
00166 
00167     <span class="keywordflow">if</span> (DrvrDebug)
00168         printk(<span class="stringliteral">"DPC_ISR: Cnt=%ld  CTRL=%x  STATUS=%x\n"</span>, pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o17">InterruptCounter</a>, intrCtrl, intrStatus);
00169 
00170     <span class="comment">// While there are active interrupts and we aren't stuck</span>
00171     <span class="comment">// keep servicing the hdw devices until all interrupts are cleared</span>
00172     <span class="keywordflow">while</span> (loopCnt &amp;&amp; (intrCtrl &amp; INTRCTL_OUT_ACTIVE))
00173     {
00174         --loopCnt;
00175 
00176         <span class="comment">// See who needs to be serviced (only if enabled)</span>
00177         service = intrStatus &amp; intrEnable;
00178 
00179         <span class="comment">// If the test mode is active and the Test bits are creating the interrupt,</span>
00180         <span class="comment">// turn them off, but leave enabled so software can fire them again</span>
00181         <span class="comment">// Used purely for testing hdw/ISR</span>
00182         <span class="keywordflow">if</span> (intrCtrl &amp; INTRCTL_TEST_MODE)
00183         {
00184             <span class="keywordflow">if</span> ((intrEnable &amp; INTRCTL_TEST1_EN) &amp;&amp; (intrCtrl &amp; INTRCTL_INTR_TEST1))
00185                 intrCtrl = intrCtrl &amp; ~INTRCTL_INTR_TEST1;  <span class="comment">// turn off test1 interrupt</span>
00186             <span class="keywordflow">if</span> ((intrEnable &amp; INTRCTL_TEST2_EN) &amp;&amp; (intrCtrl &amp; INTRCTL_INTR_TEST2))
00187                 intrCtrl = intrCtrl &amp; ~INTRCTL_INTR_TEST2;  <span class="comment">// turn off test2 interrupt</span>
00188 
00189             spin_lock_irqsave(&amp;pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o7">hdwAccess</a>, irqFlag);
00190             {
00191                 <a class="code" href="lscdma_8h.html#a38">wrReg32</a>(pBrd, <a class="code" href="_devices_8h.html#a20">GPIO</a>(INTRCTL_CTRL), intrCtrl);
00192             }
00193             spin_unlock_irqrestore(&amp;pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o7">hdwAccess</a>, irqFlag);
00194         }
00195         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (service &amp; INTRCTL_INTR_DOWN_COUNT_ZERO)
00196         {
00197             <span class="comment">// This is another test-case interrupt.</span>
00198             <span class="comment">// When the down counter hits 0 it creates an interrupt.  Service it here</span>
00199             <span class="comment">// by disabling the counter and releasing the task thats pending.</span>
00200             <span class="comment">// Check if the task has been canceled before doing any data transfers.</span>
00201 
00202             <span class="keywordflow">if</span> (DrvrDebug)
00203                 printk(<span class="stringliteral">"DownCount Interrupt\n"</span>);
00204 
00205             intrEnable =  intrEnable &amp; ~INTRCTL_DOWN_COUNT_EN;  <span class="comment">// turn off Down Counter interrupt</span>
00206             spin_lock_irqsave(&amp;pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o7">hdwAccess</a>, irqFlag);
00207             {
00208                 <a class="code" href="lscdma_8h.html#a38">wrReg32</a>(pBrd, <a class="code" href="_devices_8h.html#a20">GPIO</a>(INTRCTL_ENABLE), intrEnable);
00209 
00210                 <a class="code" href="lscdma_8h.html#a38">wrReg32</a>(pBrd, <a class="code" href="_devices_8h.html#a20">GPIO</a>(GPIO_CNTRCTRL), 0);  <span class="comment">// turn off the counter</span>
00211             }
00212             spin_unlock_irqrestore(&amp;pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o7">hdwAccess</a>, irqFlag);
00213 <span class="comment">//TODO</span>
00214             <span class="comment">// Release task blocked on an IOCTL call???</span>
00215             <span class="comment">// I don't even remember what the plan for this was - not implemented</span>
00216         }
00217         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (service &amp; INTRCTL_INTR_WR_CHAN)
00218         {
00219             <span class="keywordflow">if</span> (DrvrDebug)
00220                 printk(<span class="stringliteral">"SGDMA Write Chan Interrupt\n"</span>);
00221 
00222             <span class="keywordflow">if</span> (pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o7">Chan</a>[DMA_WR_CHAN].<a class="code" href="struct_d_m_a_channel__t.html#o2">cancelDMA</a>)
00223             {
00224                 <span class="comment">// abort all this cause read() has already cleaned up and marked the error</span>
00225                 pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o7">Chan</a>[0].<a class="code" href="struct_d_m_a_channel__t.html#o3">xferStatus</a> =  ERROR;
00226                 <span class="keywordflow">continue</span>;
00227             }
00228 
00229             <span class="comment">//----------------------------------------------------------------------------</span>
00230             <span class="comment">// This is the real processing of the SGDMA interrupts.</span>
00231             <span class="comment">// If a channel has interrupted that its done a transfer, then we need to</span>
00232             <span class="comment">// look and see if more data needs to be sent.  If so then setup a new SGlist</span>
00233             <span class="comment">// and reprogram the SGDMA channel and BD's with this data and then kick-off again.</span>
00234             <span class="comment">// If the entire transfer is complete then we need to unblock the user's task and</span>
00235             <span class="comment">// return status.</span>
00236             <span class="comment">// </span>
00237             <span class="comment">//----------------------------------------------------------------------------</span>
00238 
00239             <span class="comment">// Read the SGDMA and make sure that the xfer was OK and that no errors have occurred for</span>
00240             <span class="comment">// this Channel.  If so then abort the entire operation, even if not all the data has been</span>
00241             <span class="comment">// moved since corruption has now occurred</span>
00242             spin_lock_irqsave(&amp;pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o7">hdwAccess</a>, irqFlag);
00243             {
00244                 dmaStatus = <a class="code" href="lscdma_8h.html#a35">rdReg32</a>(pBrd, <a class="code" href="_devices_8h.html#a21">SGDMA</a>(CHAN_STAT(0)));
00245                 <a class="code" href="lscdma_8h.html#a38">wrReg32</a>(pBrd, <a class="code" href="_devices_8h.html#a21">SGDMA</a>(CHAN_STAT(0)), 0x010);  <span class="comment">// clear Xfer Complete</span>
00246 
00247                 <span class="comment">// Mask the interrupt bit in the GPIO Interrupt Controller</span>
00248                 <span class="comment">// It will get enable when the WRITE/READ initiates a new xfer</span>
00249                 reg = <a class="code" href="lscdma_8h.html#a35">rdReg32</a>(pBrd, <a class="code" href="_devices_8h.html#a20">GPIO</a>(INTRCTL_ENABLE));
00250                 <a class="code" href="lscdma_8h.html#a38">wrReg32</a>(pBrd,  <a class="code" href="_devices_8h.html#a20">GPIO</a>(INTRCTL_ENABLE),  (reg &amp; ~INTRCTL_INTR_WR_CHAN));
00251             }
00252             spin_unlock_irqrestore(&amp;pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o7">hdwAccess</a>, irqFlag);
00253 
00254             <span class="keywordflow">if</span> (!(dmaStatus &amp; CHAN_STATUS_ENABLED) || 
00255                 !(dmaStatus &amp; CHAN_STATUS_XFERCOMP) || 
00256                 (dmaStatus &amp; CHAN_STATUS_ERRORS))
00257             {
00258                 <span class="comment">// ERROR!!!!!</span>
00259                 printk(KERN_ERR <span class="stringliteral">"lscdma: SGDMA WR CHAN ERROR: %x\n"</span>, dmaStatus);
00260 
00261                 <span class="comment">// Abort the entire DMA transfer</span>
00262 
00263                 pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o7">Chan</a>[0].<a class="code" href="struct_d_m_a_channel__t.html#o3">xferStatus</a> =  ERROR;
00264 
00265             }
00266             <span class="keywordflow">else</span>
00267             {
00268                 <span class="comment">// Transfer completed OK</span>
00269                 pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o7">Chan</a>[0].<a class="code" href="struct_d_m_a_channel__t.html#o6">xferedSoFar</a> = pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o7">Chan</a>[0].<a class="code" href="struct_d_m_a_channel__t.html#o6">xferedSoFar</a> + 
00270                                     pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o7">Chan</a>[0].<a class="code" href="struct_d_m_a_channel__t.html#o7">thisXferSize</a>;
00271 
00272                 <span class="comment">// record time to do this part of the write transfer</span>
00273                 pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o7">Chan</a>[0].<a class="code" href="struct_d_m_a_channel__t.html#o4">elapsedTime</a> = pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o7">Chan</a>[0].<a class="code" href="struct_d_m_a_channel__t.html#o4">elapsedTime</a> + 
00274                                     <a class="code" href="lscdma_8h.html#a35">rdReg32</a>(pBrd, GPIO_WR_CNTR);
00275 
00276                 <span class="keywordflow">if</span> (pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o7">Chan</a>[0].<a class="code" href="struct_d_m_a_channel__t.html#o6">xferedSoFar</a> == pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o7">Chan</a>[0].<a class="code" href="struct_d_m_a_channel__t.html#o5">totalXferSize</a>)
00277                 {
00278                     <span class="keywordflow">if</span> (DrvrDebug)
00279                         printk(KERN_INFO <span class="stringliteral">"lscdma: WrChan: Done\n"</span>);
00280                     <span class="comment">// We're Done!!!!!</span>
00281                     pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o7">Chan</a>[0].<a class="code" href="struct_d_m_a_channel__t.html#o3">xferStatus</a> =  OK;
00282                 }
00283                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o7">Chan</a>[0].<a class="code" href="struct_d_m_a_channel__t.html#o6">xferedSoFar</a> &gt; pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o7">Chan</a>[0].<a class="code" href="struct_d_m_a_channel__t.html#o5">totalXferSize</a>)
00284                 {
00285                     printk(KERN_ERR <span class="stringliteral">"WrChan: ERROR! xfered too much!\n"</span>);
00286                     <span class="comment">// Abort the DMA transfer with an ERROR</span>
00287 
00288                     pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o7">Chan</a>[0].<a class="code" href="struct_d_m_a_channel__t.html#o3">xferStatus</a> =  ERROR;
00289                 }
00290                 <span class="keywordflow">else</span>
00291                 {
00292                     <span class="comment">// More to do</span>
00293                     xferSize = pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o7">Chan</a>[0].<a class="code" href="struct_d_m_a_channel__t.html#o5">totalXferSize</a> - pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o7">Chan</a>[0].<a class="code" href="struct_d_m_a_channel__t.html#o6">xferedSoFar</a>;
00294 
00295                     <span class="keywordflow">if</span> (DrvrDebug)
00296                         printk(KERN_INFO <span class="stringliteral">"WrChan: %ld more to do\n"</span>, xferSize);
00297 
00298 
00299 <span class="comment">//TODO</span>
00300                     <span class="comment">// !!!!!!!!!!!</span>
00301                     <span class="comment">// We don't handle this case right now</span>
00302                 }
00303             }
00304 
00305 
00306 
00307             <span class="comment">// if all done the transfer (all data moved, no more SG Lists to handle, etc.)</span>
00308             pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o7">Chan</a>[DMA_WR_CHAN].<a class="code" href="struct_d_m_a_channel__t.html#o1">doneDMA</a> = TRUE;
00309             wake_up_interruptible(&amp;(pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o8">ReadWaitQ</a>));  <span class="comment">// wake-up user waiting on read()</span>
00310 
00311         }
00312         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (service &amp; INTRCTL_INTR_RD_CHAN)
00313         {
00314 
00315             <span class="keywordflow">if</span> (DrvrDebug)
00316                 printk(<span class="stringliteral">"SGDMA Read Chan Interrupt\n"</span>);
00317 
00318             <span class="comment">//----------------------------------------------------------------------------</span>
00319             <span class="comment">// This is the real processing of the SGDMA interrupts.</span>
00320             <span class="comment">// If a Read channel has interrupted that its done a transfer, then we need to</span>
00321             <span class="comment">// look and see if more data needs to be reqd.  If so then setup a new SGlist</span>
00322             <span class="comment">// and reprogram the SGDMA channel and BD's with this data and then kick-off again.</span>
00323             <span class="comment">// If the entire transfer is complete then we need to unblock the user's task and</span>
00324             <span class="comment">// return status.</span>
00325             <span class="comment">// </span>
00326             <span class="comment">//----------------------------------------------------------------------------</span>
00327 
00328             <span class="keywordflow">if</span> (pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o7">Chan</a>[DMA_RD_CHAN].<a class="code" href="struct_d_m_a_channel__t.html#o2">cancelDMA</a>)
00329             {
00330                 <span class="comment">// abort all this cause read() has already cleaned up and marked the error</span>
00331                 pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o7">Chan</a>[1].<a class="code" href="struct_d_m_a_channel__t.html#o3">xferStatus</a> =  ERROR;
00332                 <span class="keywordflow">continue</span>;
00333             }
00334 
00335 
00336             <span class="comment">// Read the SGDMA and make sure that the xfer was OK and that no errors have occurred for</span>
00337             <span class="comment">// this Channel.  If so then abort the entire operation, even if not all the data has been</span>
00338             <span class="comment">// moved since corruption has now occurred</span>
00339             spin_lock_irqsave(&amp;pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o7">hdwAccess</a>, irqFlag);
00340             {
00341                 dmaStatus = <a class="code" href="lscdma_8h.html#a35">rdReg32</a>(pBrd, <a class="code" href="_devices_8h.html#a21">SGDMA</a>(CHAN_STAT(1)));
00342                 <a class="code" href="lscdma_8h.html#a38">wrReg32</a>(pBrd, <a class="code" href="_devices_8h.html#a21">SGDMA</a>(CHAN_STAT(1)), 0x010);  <span class="comment">// clear Xfer Complete</span>
00343 
00344                 <span class="comment">// Mask the interrupt bit in the GPIO Interrupt Controller</span>
00345                 <span class="comment">// It will get enable when the WRITE/READ initiates a new xfer</span>
00346                 reg = <a class="code" href="lscdma_8h.html#a35">rdReg32</a>(pBrd, <a class="code" href="_devices_8h.html#a20">GPIO</a>(INTRCTL_ENABLE));
00347                 <a class="code" href="lscdma_8h.html#a38">wrReg32</a>(pBrd,  <a class="code" href="_devices_8h.html#a20">GPIO</a>(INTRCTL_ENABLE),  (reg &amp; ~INTRCTL_INTR_RD_CHAN));
00348             }
00349             spin_unlock_irqrestore(&amp;pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o7">hdwAccess</a>, irqFlag);
00350 
00351             <span class="keywordflow">if</span> (!(dmaStatus &amp; CHAN_STATUS_ENABLED) || 
00352                 !(dmaStatus &amp; CHAN_STATUS_XFERCOMP) || 
00353                 (dmaStatus &amp; CHAN_STATUS_ERRORS))
00354             {
00355                 <span class="comment">// ERROR!!!!!</span>
00356                 printk(KERN_ERR <span class="stringliteral">"lscdma: SGDMA RD CHAN ERROR: %x\n"</span>, dmaStatus);
00357 
00358                 <span class="comment">// Abort the entire DMA transfer</span>
00359                 pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o7">Chan</a>[1].<a class="code" href="struct_d_m_a_channel__t.html#o3">xferStatus</a> =  ERROR;
00360 
00361             }
00362             <span class="keywordflow">else</span>
00363             {
00364                 <span class="comment">// Transfer completed OK</span>
00365                 pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o7">Chan</a>[1].<a class="code" href="struct_d_m_a_channel__t.html#o6">xferedSoFar</a> = pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o7">Chan</a>[1].<a class="code" href="struct_d_m_a_channel__t.html#o6">xferedSoFar</a> + 
00366                                     pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o7">Chan</a>[1].<a class="code" href="struct_d_m_a_channel__t.html#o7">thisXferSize</a>;
00367 
00368                 <span class="comment">// record time to do this part of the write transfer</span>
00369                 pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o7">Chan</a>[1].<a class="code" href="struct_d_m_a_channel__t.html#o4">elapsedTime</a> = pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o7">Chan</a>[1].<a class="code" href="struct_d_m_a_channel__t.html#o4">elapsedTime</a> + 
00370                                     <a class="code" href="lscdma_8h.html#a35">rdReg32</a>(pBrd, GPIO_RD_CNTR);
00371 
00372                 <span class="keywordflow">if</span> (pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o7">Chan</a>[1].<a class="code" href="struct_d_m_a_channel__t.html#o6">xferedSoFar</a> == pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o7">Chan</a>[1].<a class="code" href="struct_d_m_a_channel__t.html#o5">totalXferSize</a>)
00373                 {
00374                     <span class="keywordflow">if</span> (DrvrDebug)
00375                         printk(KERN_INFO <span class="stringliteral">"lscdma: RdChan: Done\n"</span>);
00376                     <span class="comment">// We're Done!!!!!</span>
00377                     pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o7">Chan</a>[1].<a class="code" href="struct_d_m_a_channel__t.html#o3">xferStatus</a> =  OK;
00378                 }
00379                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o7">Chan</a>[1].<a class="code" href="struct_d_m_a_channel__t.html#o6">xferedSoFar</a> &gt; pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o7">Chan</a>[1].<a class="code" href="struct_d_m_a_channel__t.html#o5">totalXferSize</a>)
00380                 {
00381                     printk(KERN_ERR <span class="stringliteral">"lscdma: RdChan: ERROR! xfered too much!\n"</span>);
00382                     <span class="comment">// Abort the DMA transfer with an ERROR</span>
00383                     pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o7">Chan</a>[1].<a class="code" href="struct_d_m_a_channel__t.html#o3">xferStatus</a> =  ERROR;
00384                 }
00385                 <span class="keywordflow">else</span>
00386                 {
00387                     <span class="comment">// More to do</span>
00388                     xferSize = pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o7">Chan</a>[1].<a class="code" href="struct_d_m_a_channel__t.html#o5">totalXferSize</a> - pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o7">Chan</a>[1].<a class="code" href="struct_d_m_a_channel__t.html#o6">xferedSoFar</a>;
00389 
00390                     <span class="keywordflow">if</span> (DrvrDebug)
00391                         printk(KERN_INFO <span class="stringliteral">"RdChan: %ld more to do\n"</span>, xferSize);
00392 
00393 
00394 <span class="comment">//TODO</span>
00395                     <span class="comment">// !!!!!!!!!!!</span>
00396                     <span class="comment">// We don't handle this case right now</span>
00397 
00398                 }
00399             }
00400 
00401 
00402 
00403             <span class="comment">// if all done the transfer (all data moved, no more SG Lists to handle, etc.)</span>
00404             pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o7">Chan</a>[DMA_RD_CHAN].<a class="code" href="struct_d_m_a_channel__t.html#o1">doneDMA</a> = TRUE;
00405             wake_up_interruptible(&amp;(pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o27">SGDMA</a>.<a class="code" href="struct_s_g_d_m_a_operations__t.html#o9">WriteWaitQ</a>));  <span class="comment">// wake up user waiting on write()</span>
00406 
00407         }
00408 
00409         spin_lock_irqsave(&amp;pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o7">hdwAccess</a>, irqFlag);
00410         {
00411             <span class="comment">// Re-read control &amp; status regs to see if Hdw still has active interrupts</span>
00412             intrCtrl =  <a class="code" href="lscdma_8h.html#a35">rdReg32</a>(pBrd, <a class="code" href="_devices_8h.html#a20">GPIO</a>(INTRCTL_CTRL));
00413             intrStatus =  <a class="code" href="lscdma_8h.html#a35">rdReg32</a>(pBrd, <a class="code" href="_devices_8h.html#a20">GPIO</a>(INTRCTL_STATUS));
00414             intrEnable =  <a class="code" href="lscdma_8h.html#a35">rdReg32</a>(pBrd, <a class="code" href="_devices_8h.html#a20">GPIO</a>(INTRCTL_ENABLE));
00415         }
00416         spin_unlock_irqrestore(&amp;pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o7">hdwAccess</a>, irqFlag);
00417     }
00418 
00419     <span class="comment">// Turn interrupt output back on (was shutoff in ISR) unless we're stuck</span>
00420     <span class="comment">// in interrupts,  then leave off and raise some flag that interrupts are stuck</span>
00421     <span class="keywordflow">if</span> (loopCnt)
00422     {
00423 <span class="comment">//TODO</span>
00424         <span class="comment">// Does this need to be run with some type of protection so ISR can't be invoked</span>
00425         <span class="comment">// immediately???</span>
00426         spin_lock_irqsave(&amp;pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o7">hdwAccess</a>, irqFlag);
00427         {
00428             <a class="code" href="lscdma_8h.html#a25">IsrEnableInterrupts</a>(pBrd);
00429         }
00430         spin_unlock_irqrestore(&amp;pBrd-&gt;<a class="code" href="struct_p_c_i_e___board.html#o7">hdwAccess</a>, irqFlag);
00431         
00432         <span class="comment">// A Hdw interrupt can fire now and invoke the ISR again</span>
00433     }
00434     <span class="keywordflow">else</span>
00435     {
00436         printk(KERN_WARNING <span class="stringliteral">"INTERRUPTS ARE STUCK ON!!!!  DISABLING HDW INTRS\n"</span>);
00437         <span class="comment">// leave interrupt controller output shut-off</span>
00438 
00439     }
00440 
00441 
00442 <span class="comment">//TODO</span>
00443     <span class="comment">// Do this if some user task is blocked waiting on the interrupt</span>
00444     <span class="comment">// wake_up_interruptible(&amp;lscdma_ISRQ);</span>
00445 
00446 }
00447 
00448 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Jul 16 12:05:24 2008 for Lattice PCIeDMA Device Driver  by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
