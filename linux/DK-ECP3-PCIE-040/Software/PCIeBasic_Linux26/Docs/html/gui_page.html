<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Lattice PCIe Basic Demo: PCIe Basic Demo GUI Description</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
Java JNI to C++ Interface. The <a class="el" href="_cpp___jni_8cpp.html">Cpp_Jni.cpp</a> file bridges the Java GUI to the C++ classes that implement the PCIe driver interface and device IP modules. The Java GUI simply provides a Graphical interface to the user. The Java GUI does not (can not) directly access the PCIe driver APIs. Java however can make calls to C functions if they are properly declared in the Java source as Java Native Interfaces (JNI) - interfaces to the native language of the Java platform, which is C/C++. To invoke the functions provided by the PCIeAPI library, the Java GUI elements invoke methods, such as runEBRTest(), which are tagged as JNI functions and cause the JVM to search for and invoke the C function found in a loaded DLL. The <a class="el" href="_cpp___jni_8cpp.html">Cpp_Jni.cpp</a> file is part of the DLL loaded when the Java GUI starts. Cpp_Jni provides the bridge between the Java JNI functions and the PCIeAPI library and driver interfaces. <p>
The following diagram depicts the flow of execution to invoke driver methods.<p>
<div class="fragment"><pre class="fragment">
   Java====&gt;JNI/JVM===&gt;DLL(this file)===&gt;APImethod()===&gt;driver
 </pre></div><p>
The file and functions are in C++ so they can access the standard PCIeAPI library methods and driver interface classes which are all in C++. These are the exact same classes and methods used by the Text Menu program. <p>
The Java GUI code resides in the directory <b>BasicGUI/DemoUI</b>. The main Java class is buried under the <b>src/com/.../DemoUI.java</b> path. It contains the JNI declarations of the functions that need to be implemented here. A sampling of these JNI declarations follows:<p>
<div class="fragment"><pre class="fragment">
    //==========================================================
    //   JNI Declarations
    //==========================================================
    private native String CPP_getVersionStr();
    private native String CPP_getDrvrResourceStr();
    private native String CPP_getPCIResourceStr();
    private native String CPP_runEBRTest();
    private native String CPP_readEBRMem(String cmd);
    private native String CPP_writeEBRMem(String cmd);
 </pre></div><p>
The header file that describes these JNI interface functions in terms of C/C++ is auto-generated using the <b>javah</b> utility run in the dist/ directory containing the jar file. See the Makefile in Cpp_DLL for details of invoking the <b>javah</b> utility See Java JNI tutorial for a description of how the function prototypes are generated and variables passed between Java and C/C++. <p>
After running the <b>javah</b> utility, a set of header files are generated. This source code includes the master file that defines the function signature for all the JNI functions declared in the Java source code. These functions are implemented here. They have mangled names, and do not match exactly the ones invoked in the Java source. See the comments of each function for its real name. <p>
This file, along with <b><a class="el" href="dllmain_8cpp.html">dllmain.cpp</a></b> are compiled into a DLL. The DLL can be loaded by the Java Virtual Machine (JVM) when it encounters the Java system call to load a library <b>System.loadLibrary("Cpp_Jni"); </b> Upon loading by the OS, the DllMain() function in <a class="el" href="dllmain_8cpp.html">dllmain.cpp</a> is invoked first. The function is invoked with a DLL_PROCESS_ATTACH code, which causes the <b><a class="el" href="_cpp___jni_8cpp.html#a7">createBasicDemo()</a></b> function to be called that constructs the driver interafce classes and all the device object classes. This is the exact same attach and construct sequence used in the Text Menu code. The instances of the classes are global variables so they can be accessed in each of the JNI method implementations. <p>
The code development flow: <ol>
<li>
Java Source: <ol>
<li>
declare JNI function signatures in Java GUI source </li>
<li>
make a system call to load the DLL containing the JNI implementations </li>
<li>
use the JNI functions like any other Java method </li>
</ol>
</li>
<li>
Create C++ function signatures of the JNI methods using Java's javah utility </li>
<li>
Implement these functions (this file) </li>
<li>
Compile and link into a DLL </li>
</ol>
<p>
The execution flow: <ol>
<li>
Java GUI is run like any Java class/program </li>
<li>
At the start of running, a system call is made to load the Cpp_Jni.dll </li>
<li>
JVM/OS loads the DLL </li>
<li>
The DllMain() entry is invoked and calls functions to create all the classes </li>
<li>
There-after Java GUI code calls JNI methods to control the hardware and thread execution flows into the functions implemented here </li>
<li>
When the Java GUI exits, the <a class="el" href="_cpp___jni_8cpp.html#a8">deleteBasicDemo()</a> function is invoked by the DLL and all objects are destroyed and the driver is closed. </li>
</ol>
<p>
Note: This is one possible method to perform the bridge between Java and C. A network server could have been used on the C side and Java could have sent/recvd commands via TCP on a socket. CORBA could also have been used. <hr size="1"><address style="align: right;"><small>Generated on Wed Jul 16 12:05:30 2008 for Lattice PCIe Basic Demo by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
