<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Lattice PCIe API Manual: SGDMA.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<div class="nav">
<a class="el" href="dir_000001.html">DevObjs</a></div>
<h1>SGDMA.cpp</h1><a href="_s_g_d_m_a_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment"> *  COPYRIGHT (c) 2008 by Lattice Semiconductor Corporation</span>
00003 <span class="comment"> *</span>
00004 <span class="comment"> * All rights reserved. All use of this software and documentation is</span>
00005 <span class="comment"> * subject to the License Agreement located in the file LICENSE.</span>
00006 <span class="comment"> */</span>
00007 
00010 <span class="preprocessor">#include &lt;cstdlib&gt;</span>
00011 <span class="preprocessor">#include &lt;iostream&gt;</span>
00012 <span class="preprocessor">#include &lt;string&gt;</span>
00013 <span class="preprocessor">#include &lt;sstream&gt;</span>
00014 <span class="preprocessor">#include &lt;iomanip&gt;</span>
00015 
00016 <span class="keyword">using</span> <span class="keyword">namespace </span>std;
00017 
00018 <span class="preprocessor">#include "<a class="code" href="_p_c_ie_a_p_i_8h.html">PCIeAPI.h</a>"</span>
00019 <span class="preprocessor">#include "<a class="code" href="_debug_print_8h.html">DebugPrint.h</a>"</span>
00020 <span class="preprocessor">#include "<a class="code" href="_s_g_d_m_a_8h.html">SGDMA.h</a>"</span>
00021 <span class="preprocessor">#include "<a class="code" href="_mem_format_8h.html">MemFormat.h</a>"</span>
00022 
00023 <span class="keyword">using</span> <span class="keyword">namespace </span>LatticeSemi_PCIe;
00024 
00025 
<a name="l00029"></a><a class="code" href="_s_g_d_m_a_8cpp.html#a0">00029</a> <span class="preprocessor">#define MAX_ADDRESS 0x1400</span>
00030 <span class="preprocessor"></span><span class="preprocessor">#define CHECK(x,y) if (x != y) {printf("Comparison Error Detected @ line: %d\n", __LINE__); return(false);}</span>
00031 <span class="preprocessor"></span>
<a name="l00044"></a><a class="code" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html#a0">00044</a> <a class="code" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html#a0">SGDMA::SGDMA</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *nameStr, 
00045        uint32_t baseAddr, 
00046        <a class="code" href="class_lattice_semi___p_c_ie_1_1_l_s_c_d_m_a___i_f.html">LSCDMA_IF</a> *pRA) : LatticeSemi_PCIe::<a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html">Device</a>(pRA, nameStr, baseAddr, MAX_ADDRESS)
00047 {
00048     uint32_t i;
00049 
00050     ENTER();
00051 
00052     <span class="comment">// Save the driver for later opening handles to channels</span>
00053     pDrvr = pRA;
00054 
00055 
00056     <span class="comment">// Verify the ID register and throw exception if not a SGDMA </span>
00057     <span class="keywordflow">if</span> ((this-&gt;<a class="code" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html#a6">getID</a>() &amp; 0xffff0000) != 0x12040000)
00058         <span class="keywordflow">throw</span>(<a class="code" href="class_lattice_semi___p_c_ie_1_1_p_c_ie___i_f___error.html">PCIe_IF_Error</a>(<span class="stringliteral">"SGDMA: Invalid Device ID!"</span>));
00059 
00060 
00061     <span class="comment">// Pass these in or read from Hardware?  Hardware should tell us.</span>
00062     this-&gt;<a class="code" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html#a7">getHdwParams</a>(numChannels, numBDs);
00063 
00064     <span class="comment">// Get the DMA common buffer size, address, etc. for Common Buffer transfer modes</span>
00065     pDrvr-&gt;<a class="code" href="class_lattice_semi___p_c_ie_1_1_l_s_c_d_m_a___i_f.html#a2">getDriverDMAInfo</a>(&amp;pDMAInfo);
00066     <span class="keywordflow">if</span> (pDMAInfo-&gt;<a class="code" href="struct_d_m_a_resource_info__t.html#o5">hasDmaBuf</a>)
00067     {
00068         gotCBDMA = <span class="keyword">true</span>;
00069         CBDMABufSize = pDMAInfo-&gt;<a class="code" href="struct_d_m_a_resource_info__t.html#o6">DmaBufSize</a>;
00070         physCBDMAAddr = pDMAInfo-&gt;<a class="code" href="struct_d_m_a_resource_info__t.html#o9">DmaPhyAddrLo</a>;   <span class="comment">// not supporting 64bit addr yet</span>
00071         ReadDmaBuf = (uint32_t *)malloc(CBDMABufSize);
00072         WriteDmaBuf = (uint32_t *)malloc(CBDMABufSize);
00073         <span class="keywordflow">if</span> (ReadDmaBuf == NULL)
00074             <span class="keywordflow">throw</span>(<a class="code" href="class_lattice_semi___p_c_ie_1_1_p_c_ie___i_f___error.html">PCIe_IF_Error</a>(<span class="stringliteral">"SGDMA: MALLOC ReadDmaBuf FAILED!"</span>));
00075         <span class="keywordflow">if</span> (WriteDmaBuf == NULL)
00076             <span class="keywordflow">throw</span>(<a class="code" href="class_lattice_semi___p_c_ie_1_1_p_c_ie___i_f___error.html">PCIe_IF_Error</a>(<span class="stringliteral">"SGDMA: MALLOC WriteDmaBuf FAILED!"</span>));
00077     }
00078     <span class="keywordflow">else</span>
00079     {
00080         gotCBDMA = <span class="keyword">false</span>;
00081         CBDMABufSize = 0;
00082         physCBDMAAddr = 0;
00083         ReadDmaBuf = NULL;
00084         WriteDmaBuf = NULL;
00085     }
00086 
00087     <span class="comment">// Clear the IP registers and disable everything</span>
00088     <span class="comment">//------------------------------------------------------------</span>
00089     <span class="comment">// Step 1: Reset all channels and disable DMA</span>
00090     <span class="comment">//------------------------------------------------------------</span>
00091 
00092     <a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a8">write32</a>(GCONTROL_REG, 0xffff0000);   <span class="comment">// disable and reset all channels and mask REQs</span>
00093     <a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a8">write32</a>(GSTATUS_REG, 0x00000000);    <span class="comment">// Disable SGDMA till ready</span>
00094     <a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a8">write32</a>(GEVENT_REG, 0xffff0000);     <span class="comment">// Disable event outputs</span>
00095     <a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a8">write32</a>(GERROR_REG, 0xffff0000);     <span class="comment">// mask error output</span>
00096 
00097     <span class="comment">//------------------------------------------------------------</span>
00098     <span class="comment">// Configure Arbiter</span>
00099     <span class="comment">//------------------------------------------------------------</span>
00100     <a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a8">write32</a>(GARBITER_REG, 0xffff148f);   <span class="comment">// Global Arbiter Control</span>
00101 
00102     <span class="comment">//*************************************************************</span>
00103     <span class="comment">// For debugging and development: clear all channel regsiters</span>
00104     <span class="comment">// and all BD's so we can see if anything gets written to the</span>
00105     <span class="comment">// wrong place or gets accessed</span>
00106     <span class="comment">//*************************************************************</span>
00107     <span class="keywordflow">for</span> (i = 0; i &lt; this-&gt;numChannels; i++)
00108     {
00109         <a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a8">write32</a>(CHAN_CTRL(i), 0);
00110         <a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a8">write32</a>(CHAN_STAT(i), 0);
00111         <a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a8">write32</a>(CHAN_PBOFF(i), 0);
00112     }
00113 
00114     <span class="comment">// Clear all BD's</span>
00115     <span class="keywordflow">for</span> (i = 0; i &lt; this-&gt;numBDs; i++)
00116     {
00117         <a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a8">write32</a>(BD_CFG0(i), 0);
00118         <a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a8">write32</a>(BD_CFG1(i), 0);
00119         <a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a8">write32</a>(BD_SRC(i), 0);
00120         <a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a8">write32</a>(BD_DST(i), 0);
00121     }
00122 
00123 
00124 
00125     LEAVE();
00126 }
00127 
00128 
<a name="l00134"></a><a class="code" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html#a1">00134</a> <a class="code" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html#a1">SGDMA::~SGDMA</a>()
00135 {
00136     ENTER();
00137 
00138 
00139     <span class="comment">// disable SGDMA functionality, especially interrupts</span>
00140     <a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a8">write32</a>(GCONTROL_REG, 0xffff0000);   <span class="comment">// disable and reset all channels and mask REQs</span>
00141     <a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a8">write32</a>(GSTATUS_REG, 0x00000000);    <span class="comment">// Disable SGDMA</span>
00142 
00143 
00144     <span class="comment">// Need to get the Common Buffer details</span>
00145     free(ReadDmaBuf);
00146     free(WriteDmaBuf);
00147 
00148 }
00149 
00150 
00151 
00152 
00153 
00154 
<a name="l00180"></a><a class="code" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html#a2">00180</a> <span class="keywordtype">bool</span> <a class="code" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html#a2">SGDMA::ReadFromCB</a>(uint8_t chan,
00181                    size_t len, 
00182                    uint32_t dstAddr, 
00183                    uint32_t dstMode, 
00184                    uint32_t dstSize, 
00185                    uint32_t nBDs, 
00186                    uint32_t bdStart)
00187 {
00188     uint32_t i, rd32_val, err;
00189 
00190     uint32_t xferSize, blockSize, burstSize;
00191     uint32_t bd;
00192     uint32_t srcAddr;
00193     uint32_t gctrl_save;
00194 
00195     ENTER();
00196 
00197     err = 0;
00198     xferSize = len;
00199 
00200     <span class="keywordflow">if</span> (chan &gt;= this-&gt;numChannels)
00201     {
00202         ERRORSTR(<span class="stringliteral">"Channel number invalid"</span>);
00203         <span class="keywordflow">return</span>(<span class="keyword">false</span>);   <span class="comment">// ERROR! Channel not valid</span>
00204     }
00205        
00206     <span class="keywordflow">if</span> (xferSize &gt; CBDMABufSize)
00207     {
00208         ERRORSTR(<span class="stringliteral">"DMA Len too large!"</span>);
00209         <span class="keywordflow">return</span>(<span class="keyword">false</span>);
00210     }
00211         
00212     <span class="keywordflow">if</span> (xferSize &lt; pDMAInfo-&gt;<a class="code" href="struct_d_m_a_resource_info__t.html#o11">MaxReadReqSize</a>)
00213         burstSize = xferSize;  <span class="comment">// need to be equal (or xfer can be bigger)</span>
00214     <span class="keywordflow">else</span>
00215         burstSize = pDMAInfo-&gt;<a class="code" href="struct_d_m_a_resource_info__t.html#o11">MaxReadReqSize</a>;  <span class="comment">// can't ask for more than this per TLP</span>
00216 
00217     <span class="keywordflow">if</span> (xferSize &lt; 8)
00218     {
00219         ERRORSTR(<span class="stringliteral">"DMA Len too small!"</span>);
00220         <span class="keywordflow">return</span>(<span class="keyword">false</span>);
00221     }
00222 
00223     <span class="keywordflow">if</span> (bdStart + nBDs &gt; this-&gt;numBDs)
00224     {
00225         ERRORSTR(<span class="stringliteral">"BD_start + nBDs out of range!"</span>);
00226         <span class="keywordflow">return</span>(<span class="keyword">false</span>);
00227     }
00228  
00229     <span class="comment">//------------------------------------------------------------</span>
00230     <span class="comment">// Step 1: Configure Buffer descriptors</span>
00231     <span class="comment">//------------------------------------------------------------</span>
00232     printf(<span class="stringliteral">"Setup %d buffer descriptors for read channel: %d\n"</span>, nBDs, chan);
00233     srcAddr = this-&gt;physCBDMAAddr;
00234 
00235     <span class="keywordflow">if</span> (nBDs &gt; 1)
00236         blockSize = xferSize / nBDs;
00237     <span class="keywordflow">else</span>
00238         blockSize = xferSize;
00239 
00240 
00241 <span class="comment">//TODO make sure that the last transfer handles sub-burst length size if there is something</span>
00242 <span class="comment">// left over that is less than burstSize i.e. sending 150 bytes = 128 + 22</span>
00243 <span class="comment">// This is actually a bit more complicated because the if the burstSize changes, it needs to </span>
00244 <span class="comment">// be in a new BD.</span>
00245 <span class="comment">// BD[0] = burst: 128, xfer: 128</span>
00246 <span class="comment">// BD[1] = burst: 22, xfer:22</span>
00247 <span class="comment">// 22 is not multiple of 64 bit, do I need to round up to 24?</span>
00248 
00249 
00250     <span class="comment">// xferSize = total amount to send (256, 1024, 32kB, etc.)</span>
00251     <span class="comment">// blockSize = per-buffer descriptor amount to send, if 4 BDs used then blockSize = xferSize / 4</span>
00252     <span class="comment">// burstSize = PCIe MaxPayload Size, can't send more than this per TLP</span>
00253     <span class="comment">// if sending 128 bytes in one BD, then xferSize = blockSize = burstSize</span>
00254     bd = bdStart;
00255     <span class="keywordflow">for</span> (i = 0; i &lt; nBDs; i++)
00256     {
00257         printf(<span class="stringliteral">"BD[%d]: src:%x -&gt; dst:%x  len:%d\n"</span>, bd, srcAddr, dstAddr, blockSize);
00258         <span class="keywordflow">if</span> (i == (nBDs - 1))
00259             <a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a8">write32</a>(BD_CFG0(bd), (DST_ADDR_MODE(dstMode) | DST_SIZE(dstSize)    | DST_BUS(BUS_A) |  \
00260                                                  SRC_MEM | SRC_SIZE(DATA_64BIT) | SRC_BUS(BUS_B) | EOL));
00261         <span class="keywordflow">else</span>
00262             <a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a8">write32</a>(BD_CFG0(bd), (DST_ADDR_MODE(dstMode) | DST_SIZE(dstSize)    | DST_BUS(BUS_A) |  \
00263                                                  SRC_MEM | SRC_SIZE(DATA_64BIT) | SRC_BUS(BUS_B)));
00264         <a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a8">write32</a>(BD_CFG1(bd), BURST_SIZE(burstSize) | XFER_SIZE(blockSize));
00265         <a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a8">write32</a>(BD_SRC(bd), srcAddr);        <span class="comment">//  source address = PC DMA buffer address</span>
00266         <a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a8">write32</a>(BD_DST(bd), WB(dstAddr));   <span class="comment">//  destination = wishbone slave device</span>
00267 
00268         srcAddr = srcAddr + blockSize;
00269         <span class="keywordflow">if</span> (dstMode != ADDR_MODE_FIFO)
00270             dstAddr = dstAddr + blockSize;
00271 
00272         ++bd;  <span class="comment">// load next buffer descriptor</span>
00273     }
00274 
00275     <span class="comment">//------------------------------------------------------------</span>
00276     <span class="comment">// Step 2: Configure Channels</span>
00277     <span class="comment">//------------------------------------------------------------</span>
00278     <a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a8">write32</a>(CHAN_CTRL(chan), (bdStart&lt;&lt;8));   <span class="comment">// set BD base, no err mask</span>
00279     <a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a8">write32</a>(CHAN_PBOFF(chan), 0x00000000);   <span class="comment">//  Pkt Buf offset = 0 (1st block)</span>
00280 
00281 
00282     <span class="comment">//------------------------------------------------------------</span>
00283     <span class="comment">// Step 3:  Enable Core and the Channel</span>
00284     <span class="comment">// arbiter not really used now, but could be in future so allow for it</span>
00285     <span class="comment">//------------------------------------------------------------</span>
00286     <a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a8">write32</a>(GSTATUS_REG, 0xe0000000);   <span class="comment">//  turn on the core and wishbone bus interfaces</span>
00287     rd32_val = <a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a7">read32</a>(GARBITER_REG);
00288     <a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a8">write32</a>(GARBITER_REG, rd32_val &amp; ~((1&lt;&lt;chan)&lt;&lt;16));   <span class="comment">// unmask this channel for arbiter service</span>
00289     rd32_val = <a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a7">read32</a>(GCONTROL_REG);
00290     gctrl_save = rd32_val;
00291     <a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a8">write32</a>(GCONTROL_REG, rd32_val | (1&lt;&lt;chan));   <span class="comment">// Global Control:  enable channel &amp; Req</span>
00292 
00293     <span class="comment">//------------------------------------------------------------</span>
00294     <span class="comment">// Step 4:  GO!!!!</span>
00295     <span class="comment">// Trigger transfer via software </span>
00296     <span class="comment">//------------------------------------------------------------</span>
00297     <a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a8">write32</a>(CHAN_STAT(chan), 0x00000002);   <span class="comment">// software trigger the transfer</span>
00298 
00299 
00300     i = 0;
00301     <span class="keywordflow">do</span>
00302     {
00303         Sleep(2);  <span class="comment">// let it run then check if XFERCOMP bit is set </span>
00304         ++i;  <span class="comment">// timeout</span>
00305     } <span class="keywordflow">while</span> (((<a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a7">read32</a>(CHAN_STAT(chan)) &amp; 0x00000004) == 0) &amp;&amp; (i &lt; 1000));
00306 
00307     <span class="keywordflow">if</span> (i &gt;= 1000)
00308     {
00309         ++err;
00310         ERRORSTR(<span class="stringliteral">"XFER_TIMEOUT! Never Completed!"</span>);
00311     }
00312 
00313     <span class="comment">// Check results</span>
00314     <span class="keywordflow">if</span> (<a class="code" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html#a9">checkChanStatus</a>(chan) == <span class="keyword">false</span>)
00315         ++err;
00316 
00317     <a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a8">write32</a>(CHAN_STAT(chan), 0x10); <span class="comment">// clear XFERCOMP so it can run again</span>
00318     <a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a8">write32</a>(GCONTROL_REG, gctrl_save);   <span class="comment">// restore Global Control state</span>
00319 
00320     <span class="keywordflow">if</span> (err)
00321         <span class="keywordflow">return</span>(<span class="keyword">false</span>);
00322     <span class="keywordflow">else</span>
00323         <span class="keywordflow">return</span>(<span class="keyword">true</span>);
00324 
00325 }
00326 
00327 
00328 
<a name="l00353"></a><a class="code" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html#a3">00353</a> <span class="keywordtype">bool</span> <a class="code" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html#a3">SGDMA::WriteToCB</a>(uint8_t chan,
00354                    size_t len, 
00355                    uint32_t srcAddr, 
00356                    uint32_t srcMode, 
00357                    uint32_t srcSize, 
00358                    uint32_t nBDs, 
00359                    uint32_t bdStart)
00360 {
00361     uint32_t i, rd32_val, err;
00362 
00363     uint32_t xferSize, blockSize, burstSize;
00364     uint32_t bd;
00365     uint32_t dstAddr;
00366     uint32_t gctrl_save;
00367 
00368     ENTER();
00369 
00370     err = 0;
00371     xferSize = len;
00372 
00373     <span class="keywordflow">if</span> (chan &gt;= this-&gt;numChannels)
00374     {
00375         ERRORSTR(<span class="stringliteral">"Channel number invalid"</span>);
00376         <span class="keywordflow">return</span>(<span class="keyword">false</span>);   <span class="comment">// ERROR! Channel not valid</span>
00377     }
00378        
00379     <span class="keywordflow">if</span> (xferSize &gt; CBDMABufSize)
00380     {
00381         ERRORSTR(<span class="stringliteral">"DMA Len too large!"</span>);
00382         <span class="keywordflow">return</span>(<span class="keyword">false</span>);
00383     }
00384         
00385     <span class="keywordflow">if</span> (xferSize &lt; pDMAInfo-&gt;<a class="code" href="struct_d_m_a_resource_info__t.html#o10">MaxPayloadSize</a>)
00386         burstSize = xferSize;  <span class="comment">// need to be equal (or xfer can be bigger)</span>
00387     <span class="keywordflow">else</span>
00388         burstSize = pDMAInfo-&gt;<a class="code" href="struct_d_m_a_resource_info__t.html#o10">MaxPayloadSize</a>;  <span class="comment">// can't write more than this per TLP</span>
00389 
00390     <span class="keywordflow">if</span> (xferSize &lt; 8)
00391     {
00392         ERRORSTR(<span class="stringliteral">"DMA Len too small!"</span>);
00393         <span class="keywordflow">return</span>(<span class="keyword">false</span>);
00394     }
00395 
00396     bdStart = 0;   <span class="comment">// if want to offset the starting BD, ie. use 128 BD's starting at 128 to 255</span>
00397     <span class="keywordflow">if</span> (bdStart + nBDs &gt; this-&gt;numBDs)
00398     {
00399         ERRORSTR(<span class="stringliteral">"BD_start + nBDs out of range!"</span>);
00400         <span class="keywordflow">return</span>(<span class="keyword">false</span>);
00401     }
00402  
00403     <span class="comment">//------------------------------------------------------------</span>
00404     <span class="comment">// Step 1: Configure Buffer descriptors</span>
00405     <span class="comment">//------------------------------------------------------------</span>
00406     printf(<span class="stringliteral">"Setup %d buffer descriptors for write channel: %d\n"</span>, nBDs, chan);
00407     dstAddr = this-&gt;physCBDMAAddr;
00408 
00409     <span class="keywordflow">if</span> (nBDs &gt; 1)
00410         blockSize = xferSize / nBDs;
00411     <span class="keywordflow">else</span>
00412         blockSize = xferSize;
00413 
00414 
00415 <span class="comment">//TODO make sure that the last transfer handles sub-burst length size if there is something</span>
00416 <span class="comment">// left over that is less than burstSize i.e. sending 150 bytes = 128 + 22</span>
00417 <span class="comment">// This is actually a bit more complicated because the if the burstSize changes, it needs to </span>
00418 <span class="comment">// be in a new BD.</span>
00419 <span class="comment">// BD[0] = burst: 128, xfer: 128</span>
00420 <span class="comment">// BD[1] = burst: 22, xfer:22</span>
00421 <span class="comment">// 22 is not multiple of 64 bit, do I need to round up to 24?</span>
00422 
00423 
00424     <span class="comment">// xferSize = total amount to send (256, 1024, 32kB, etc.)</span>
00425     <span class="comment">// blockSize = per-buffer descriptor amount to send, if 4 BDs used then blockSize = xferSize / 4</span>
00426     <span class="comment">// burstSize = PCIe MaxPayload Size, can't send more than this per TLP</span>
00427     <span class="comment">// if sending 128 bytes in one BD, then xferSize = blockSize = burstSize</span>
00428     bd = bdStart;
00429     <span class="keywordflow">for</span> (i = 0; i &lt; nBDs; i++)
00430     {
00431         printf(<span class="stringliteral">"BD[%d]: src:%x -&gt; dst:%x  len:%d\n"</span>, bd, srcAddr, dstAddr, blockSize);
00432         <span class="keywordflow">if</span> (i == (nBDs - 1))
00433             <a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a8">write32</a>(BD_CFG0(bd), (DST_MEM | DST_SIZE(DATA_64BIT) | DST_BUS(BUS_B) |  \
00434                           SRC_ADDR_MODE(srcMode) | SRC_SIZE(srcSize) | SRC_BUS(BUS_A) | EOL));
00435         <span class="keywordflow">else</span>
00436             <a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a8">write32</a>(BD_CFG0(bd), (DST_MEM | DST_SIZE(DATA_64BIT) | DST_BUS(BUS_B) |  \
00437                          SRC_ADDR_MODE(srcMode) | SRC_SIZE(srcSize) | SRC_BUS(BUS_A) ));
00438         <a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a8">write32</a>(BD_CFG1(bd), BURST_SIZE(burstSize) | XFER_SIZE(blockSize));
00439         <a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a8">write32</a>(BD_SRC(bd), WB(srcAddr));    <span class="comment">//  source address</span>
00440         <a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a8">write32</a>(BD_DST(bd), dstAddr);   <span class="comment">//  destination = PC DMA buffer address</span>
00441 
00442         <span class="keywordflow">if</span> (srcMode != ADDR_MODE_FIFO)
00443             srcAddr = srcAddr + blockSize;
00444         dstAddr = dstAddr + blockSize;
00445 
00446         ++bd;
00447     }
00448 
00449     <span class="comment">//------------------------------------------------------------</span>
00450     <span class="comment">// Step 2: Configure Channels</span>
00451     <span class="comment">//------------------------------------------------------------</span>
00452     <a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a8">write32</a>(CHAN_CTRL(chan), (bdStart&lt;&lt;8));   <span class="comment">// BD base 0, no err mask</span>
00453     <a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a8">write32</a>(CHAN_PBOFF(chan), 0x00000000);   <span class="comment">//  Pkt Buf offset = 0 (1st block)</span>
00454 
00455 
00456     <span class="comment">//------------------------------------------------------------</span>
00457     <span class="comment">// Step 3:  Enable Core and the Channel</span>
00458     <span class="comment">// arbiter not really used now, but could be in future so allow for it</span>
00459     <span class="comment">//------------------------------------------------------------</span>
00460     <a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a8">write32</a>(GSTATUS_REG, 0xe0000000);   <span class="comment">//  turn on the core and wishbone bus interfaces</span>
00461     rd32_val = <a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a7">read32</a>(GARBITER_REG);
00462     <a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a8">write32</a>(GARBITER_REG, rd32_val &amp; ~((1&lt;&lt;chan)&lt;&lt;16));   <span class="comment">// unmask this channel for arbiter service</span>
00463     rd32_val = <a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a7">read32</a>(GCONTROL_REG);
00464     gctrl_save = rd32_val;
00465     <a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a8">write32</a>(GCONTROL_REG, rd32_val | (1&lt;&lt;chan));   <span class="comment">// Global Control:  enable channel the channel</span>
00466     <span class="comment">// Note: the DMA_REQ is left masked because this is a hdw signal input.  Not needed for sw trigger.</span>
00467 
00468     <span class="comment">//------------------------------------------------------------</span>
00469     <span class="comment">// Step 4:  GO!!!!</span>
00470     <span class="comment">// Trigger transfer via software </span>
00471     <span class="comment">//------------------------------------------------------------</span>
00472     <a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a8">write32</a>(CHAN_STAT(chan), 0x00000002);   <span class="comment">// software trigger the transfer</span>
00473 
00474 
00475     i = 0;
00476     <span class="keywordflow">do</span>
00477     {
00478         Sleep(2);  <span class="comment">// let it run then check if XFERCOMP bit is set </span>
00479         ++i;  <span class="comment">// timeout</span>
00480     } <span class="keywordflow">while</span> (((<a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a7">read32</a>(CHAN_STAT(chan)) &amp; 0x00000004) == 0) &amp;&amp; (i &lt; 1000));
00481 
00482     <span class="keywordflow">if</span> (i &gt;= 1000)
00483     {
00484         ++err;
00485         ERRORSTR(<span class="stringliteral">"XFER_TIMEOUT! Never Completed!"</span>);
00486     }
00487 
00488     <span class="comment">// Check results</span>
00489     <span class="keywordflow">if</span> (<a class="code" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html#a9">checkChanStatus</a>(chan) == <span class="keyword">false</span>)
00490         ++err;
00491 
00492     <span class="comment">//-----------------------------------------------------</span>
00493     <span class="comment">//  Clean-up Channel, restore its original state</span>
00494     <span class="comment">//-----------------------------------------------------</span>
00495     <a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a8">write32</a>(CHAN_STAT(chan), 0x10); <span class="comment">// clear XFERCOMP so it can run again</span>
00496     <a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a8">write32</a>(GCONTROL_REG, gctrl_save);   <span class="comment">// restore Global Control state</span>
00497 
00498     <span class="keywordflow">if</span> (err)
00499         <span class="keywordflow">return</span>(<span class="keyword">false</span>);
00500     <span class="keywordflow">else</span>
00501         <span class="keywordflow">return</span>(<span class="keyword">true</span>);
00502 }
00503 
00504 
00505 
<a name="l00515"></a><a class="code" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html#a4">00515</a> <span class="keywordtype">void</span> <a class="code" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html#a4">SGDMA::enableCore</a>(uint16_t chanMask)
00516 {
00517     uint32_t mask, regVal;
00518     ENTER();
00519 
00520     mask = (~chanMask)&lt;&lt;16;
00521     regVal = <a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a7">read32</a>(GARBITER_REG);
00522     <a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a8">write32</a>(GARBITER_REG, regVal | mask);  <span class="comment">// turn on channels for arbiter scheduling</span>
00523 
00524     <a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a8">write32</a>(GSTATUS_REG, 0xe0000000);     <span class="comment">// turn on Core and Wishbone buses</span>
00525 
00526     regVal = <a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a7">read32</a>(GARBITER_REG);
00527     <a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a8">write32</a>(GCONTROL_REG, regVal | chanMask);  <span class="comment">// turn on channels (hdw req mask should be left set)</span>
00528 }
00529 
00530 
<a name="l00539"></a><a class="code" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html#a5">00539</a> <span class="keywordtype">void</span> <a class="code" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html#a5">SGDMA::disableCore</a>(<span class="keywordtype">void</span>)
00540 {
00541     ENTER();
00542     <a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a8">write32</a>(GCONTROL_REG, 0xffff0000);   <span class="comment">// disable and reset all channels and mask REQs</span>
00543     <a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a8">write32</a>(GSTATUS_REG, 0x00000000);    <span class="comment">// Disable SGDMA till ready</span>
00544     <a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a8">write32</a>(GEVENT_REG, 0xffff0000);     <span class="comment">// Disable event outputs</span>
00545     <a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a8">write32</a>(GERROR_REG, 0xffff0000);     <span class="comment">// mask error output</span>
00546 
00547 }
00548 
00549 
00550 
00551 
<a name="l00557"></a><a class="code" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html#a6">00557</a> uint32_t <a class="code" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html#a6">SGDMA::getID</a>(<span class="keywordtype">void</span>)
00558 {
00559     ENTER();
00560 
00561     <span class="keywordflow">return</span>(<a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a7">read32</a>(IPID_REG));
00562 }
00563 
00564 
<a name="l00573"></a><a class="code" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html#a7">00573</a> <span class="keywordtype">void</span> <a class="code" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html#a7">SGDMA::getHdwParams</a>(uint8_t &amp;numChan, uint32_t &amp;numBDs)
00574 {
00575     numChan = (uint8_t)((<a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a7">read32</a>(IPVER_REG))&gt;&gt;12) &amp; 0x1f;
00576     ++numChan;  <span class="comment">// what's in the hdw register is really the max chan#.  How many = +1</span>
00577     numBDs = 256;
00578 }
00579 
00580 
<a name="l00586"></a><a class="code" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html#a19">00586</a> <span class="keywordtype">void</span>    <a class="code" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html#a19">SGDMA::showGlobalRegs</a>(<span class="keywordtype">void</span>)
00587 {
00588     <span class="keywordtype">int</span> i;
00589 
00590     printf(<span class="stringliteral">"\n\n\n=====================================================\n"</span>);
00591     printf(<span class="stringliteral">"SGDMA: Global Register Contents\n"</span>);
00592     printf(<span class="stringliteral">"=====================================================\n"</span>);
00593     <span class="comment">// Read all the Global registers</span>
00594     <span class="keywordflow">for</span> (i = 0; i &lt; 0x20; i = i + 4)
00595     {
00596         printf(<span class="stringliteral">"SGDMA[%x] = %08x\n"</span>, i , <a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a7">read32</a>(i));
00597     }
00598 }
00599 
<a name="l00604"></a><a class="code" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html#a20">00604</a> <span class="keywordtype">void</span>    <a class="code" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html#a20">SGDMA::showChannelRegs</a>(<span class="keywordtype">void</span>)
00605 {
00606     <span class="keywordtype">int</span> i, j;
00607     <span class="keywordtype">int</span> ch;
00608 
00609     printf(<span class="stringliteral">"\n\n\n=====================================================\n"</span>);
00610     printf(<span class="stringliteral">"SGDMA: Channel Register Contents\n"</span>);
00611     printf(<span class="stringliteral">"=====================================================\n"</span>);
00612     ch = 0;
00613     <span class="keywordflow">for</span> (i = 0x200; i &lt; 0x200 + this-&gt;numChannels*0x20; i = i + 0x20)
00614     {
00615         printf(<span class="stringliteral">"Chan[%d]\n"</span>, ch);
00616         <span class="keywordflow">for</span> (j = 0; j &lt; 0x18; j = j + 4)
00617         {
00618             printf(<span class="stringliteral">"\tSGDMA[%x] = %08x\n"</span>, i+j , <a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a7">read32</a>(i+j));
00619         }
00620         ++ch;
00621     }
00622 }
00623 
00624  
<a name="l00629"></a><a class="code" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html#a21">00629</a> <span class="keywordtype">void</span>    <a class="code" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html#a21">SGDMA::showBufDescRegs</a>(<span class="keywordtype">void</span>)
00630 {
00631     uint32_t j, i;
00632     uint32_t bd;
00633 
00634     printf(<span class="stringliteral">"\n\n\n=====================================================\n"</span>);
00635     printf(<span class="stringliteral">"\n\nSGDMA: Buffer Desciptor Registers\n"</span>);
00636     printf(<span class="stringliteral">"=====================================================\n"</span>);
00637     bd = 0;
00638     <span class="keywordflow">for</span> (i = 0x400; i &lt; 0x400 + this-&gt;numBDs*0x10; i = i + 0x10)
00639     {
00640             printf(<span class="stringliteral">"BD[%d]:\n"</span>, bd);
00641             <span class="keywordflow">for</span> (j = 0; j &lt; 0x10; j = j + 4)
00642             {
00643                 printf(<span class="stringliteral">"\tSGDMA[%x] = %08x\n"</span>, i+j , <a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a7">read32</a>(i+j));
00644             }
00645 
00646         ++bd;
00647     }
00648 }
00649 
00650  
<a name="l00657"></a><a class="code" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html#a22">00657</a> <span class="keywordtype">bool</span>    <a class="code" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html#a22">SGDMA::verifyBufDescRegs</a>(<span class="keywordtype">void</span>)
00658 {
00659     uint32_t i;
00660     uint32_t bd;
00661 
00662     <span class="comment">// first load unique pattern into every registers of every buf desc.</span>
00663     bd = 0;
00664     <span class="keywordflow">for</span> (i = 0x400; i &lt; 0x400 + this-&gt;numBDs*0x10; i = i + 0x10)
00665     {
00666         <a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a8">write32</a>(i, bd);
00667         <a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a8">write32</a>((i + 4), (bd&lt;&lt;8) | bd);
00668         <a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a8">write32</a>((i + 8), (bd&lt;&lt;16) | (bd&lt;&lt;8) | bd);
00669         <a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a8">write32</a>((i + 12), (bd&lt;&lt;24) | (bd&lt;&lt;16) | (bd&lt;&lt;8) | bd);
00670         ++bd;
00671     }
00672 
00673     <span class="comment">// then verify that all registers have their programmed value</span>
00674     bd = 0;
00675     <span class="keywordflow">for</span> (i = 0x400; i &lt; 0x400 + this-&gt;numBDs*0x10; i = i + 0x10)
00676     {
00677 
00678         CHECK((ULONG)bd, <a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a7">read32</a>(i));
00679         CHECK((ULONG)((bd&lt;&lt;8) | bd), <a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a7">read32</a>(i + 4));
00680         CHECK((ULONG)((bd&lt;&lt;16) | (bd&lt;&lt;8) | bd), <a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a7">read32</a>(i + 8));
00681         CHECK((ULONG)((bd&lt;&lt;24) | (bd&lt;&lt;16) | (bd&lt;&lt;8) | bd), <a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a7">read32</a>(i + 12));
00682 
00683         ++bd;
00684     }
00685 
00686     <span class="keywordflow">return</span>(<span class="keyword">true</span>);
00687 
00688 }
00689 
<a name="l00695"></a><a class="code" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html#a8">00695</a> <span class="keywordtype">void</span> <a class="code" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html#a8">SGDMA::getChanStatusStr</a>(string &amp;outs, uint32_t chan)
00696 {
00697     uint32_t rd32_val;
00698     uint32_t chan_base;
00699 
00700     std::ostringstream oss;
00701     oss&lt;&lt;std::setbase(16);
00702 
00703     oss&lt;&lt;<span class="stringliteral">"CHAN["</span>&lt;&lt;chan&lt;&lt;<span class="stringliteral">"]:\n"</span>;
00704     chan_base = 0x200 + chan * 0x20;
00705     rd32_val = <a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a7">read32</a>(chan_base + 0x04);
00706     oss&lt;&lt;<span class="stringliteral">"   status: "</span>&lt;&lt;hex&lt;&lt;rd32_val&lt;&lt; <span class="stringliteral">"=&gt;["</span>;
00707     oss&lt;&lt;<span class="stringliteral">" BD="</span>&lt;&lt;dec&lt;&lt;(rd32_val&gt;&gt;24);
00708     <span class="keywordflow">if</span> (rd32_val &amp; 0x10000)
00709         cout&lt;&lt;<span class="stringliteral">" BusErr"</span>;
00710     <span class="keywordflow">if</span> (rd32_val &amp; 0x20000)
00711         cout&lt;&lt;<span class="stringliteral">" AddrErr"</span>;
00712     <span class="keywordflow">if</span> (rd32_val &amp; 0x40000)
00713         cout&lt;&lt;<span class="stringliteral">" TimeOut"</span>;
00714     <span class="keywordflow">if</span> (rd32_val &amp; 0x80000)
00715         cout&lt;&lt;<span class="stringliteral">" RtyErr"</span>;
00716     oss&lt;&lt;<span class="stringliteral">" STATE="</span>&lt;&lt;hex&lt;&lt;((rd32_val&gt;&gt;12) &amp; 0x0f);
00717     oss&lt;&lt;<span class="stringliteral">" RTY="</span>&lt;&lt;dec&lt;&lt;((rd32_val&gt;&gt;7) &amp; 0x1f);
00718     <span class="keywordflow">if</span> (rd32_val &amp; 0x00010)
00719         oss&lt;&lt;<span class="stringliteral">" ClrComp"</span>;
00720     <span class="keywordflow">if</span> (rd32_val &amp; 0x00008)
00721         oss&lt;&lt;<span class="stringliteral">" EOD"</span>;
00722     <span class="keywordflow">if</span> (rd32_val &amp; 0x00004)
00723         oss&lt;&lt;<span class="stringliteral">" XferComp"</span>;
00724     <span class="keywordflow">if</span> (rd32_val &amp; 0x00002)
00725         oss&lt;&lt;<span class="stringliteral">" Req"</span>;
00726     <span class="keywordflow">if</span> (rd32_val &amp; 0x00001)
00727         oss&lt;&lt;<span class="stringliteral">" En"</span>;
00728     oss&lt;&lt;<span class="stringliteral">"]"</span>&lt;&lt;endl;
00729 
00730     rd32_val = <a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a7">read32</a>(chan_base + 0x08);
00731     oss&lt;&lt;<span class="stringliteral">"   src_addr: "</span>&lt;&lt;hex&lt;&lt;rd32_val&lt;&lt;endl;
00732     rd32_val = <a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a7">read32</a>(chan_base + 0x0c);
00733     oss&lt;&lt;<span class="stringliteral">"   dst_addr: "</span>&lt;&lt;hex&lt;&lt;rd32_val&lt;&lt;endl;
00734     rd32_val = <a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a7">read32</a>(chan_base + 0x10);
00735     oss&lt;&lt;<span class="stringliteral">"   xfr_cnt: "</span>&lt;&lt;hex&lt;&lt;rd32_val&lt;&lt;endl;
00736 
00737 }
00738 
<a name="l00745"></a><a class="code" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html#a9">00745</a> <span class="keywordtype">bool</span> <a class="code" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html#a9">SGDMA::checkChanStatus</a>(uint32_t chan)
00746 {
00747     uint32_t rd32_val;
00748     uint32_t chan_base;
00749     <span class="keywordtype">int</span> errs = 0;
00750     string statusStr;
00751 
00752     <span class="comment">// First show the Channel's status registers</span>
00753     <a class="code" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html#a8">getChanStatusStr</a>(statusStr, chan);
00754     cout&lt;&lt;statusStr&lt;&lt;endl;
00755 
00756     chan_base = 0x200 + chan * 0x20;
00757     rd32_val = <a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a7">read32</a>(chan_base + 0x04);
00758     <span class="keywordflow">if</span> (rd32_val &amp; 0xf0000)
00759     {
00760         cout&lt;&lt;<span class="stringliteral">"\nDMA FAILED: Chan has errors!"</span>;  <span class="comment">// Errors set or not done yet!</span>
00761         ++errs;
00762     }
00763 
00764     <span class="keywordflow">if</span> (!(rd32_val &amp; 0x00004))
00765     {
00766         cout&lt;&lt;<span class="stringliteral">"\nDMA FAILED: Chan not done xfer."</span>;   <span class="comment">// Errors set or not done yet!</span>
00767         ++errs;
00768     }
00769 
00770     rd32_val = <a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a7">read32</a>(chan_base + 0x10);
00771     <span class="keywordflow">if</span> (rd32_val != 0)
00772     {
00773         cout&lt;&lt;<span class="stringliteral">"\nDMA FAILED: Chan xfer_cnt not 0."</span>;  <span class="comment">// not done yet!</span>
00774         ++errs;
00775     }
00776 
00777     <span class="keywordflow">if</span> (errs)
00778         <span class="keywordflow">return</span>(<span class="keyword">false</span>);
00779     <span class="keywordflow">else</span>
00780         <span class="keywordflow">return</span>(<span class="keyword">true</span>);
00781 }
00782 
00783  
00784 <span class="comment">/*===========================================================================*/</span>
00785 <span class="comment">/*===========================================================================*/</span>
00786 <span class="comment">/*===========================================================================*/</span>
00787 <span class="comment">//        SYSTEM DMA MEMORY TESTING FUNCTIONS (in kernel space)</span>
00788 <span class="comment">/*===========================================================================*/</span>
00789 <span class="comment">/*===========================================================================*/</span>
00790 <span class="comment">/*===========================================================================*/</span>
00791 
00792 
<a name="l00802"></a><a class="code" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html#a10">00802</a> size_t <a class="code" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html#a10">SGDMA::getDrvrCB</a>(uint32_t *buf, size_t len)
00803 {
00804     <span class="keywordflow">if</span> ((len == 0) || (len &gt; CBDMABufSize))
00805         len = CBDMABufSize;
00806 
00807     <span class="keywordflow">if</span> (pDrvr-&gt;<a class="code" href="class_lattice_semi___p_c_ie_1_1_l_s_c_d_m_a___i_f.html#a6">readSysDmaBuf</a>(buf, len))
00808         <span class="keywordflow">return</span>(len);
00809     <span class="keywordflow">else</span>
00810         <span class="keywordflow">return</span>(0);
00811 
00812 }
00813 
<a name="l00823"></a><a class="code" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html#a11">00823</a> size_t <a class="code" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html#a11">SGDMA::setDrvrCB</a>(uint32_t *buf, size_t len)
00824 {
00825     <span class="keywordflow">if</span> ((len == 0) || (len &gt; CBDMABufSize))
00826         len = CBDMABufSize;
00827 
00828     <span class="keywordflow">if</span> (pDrvr-&gt;<a class="code" href="class_lattice_semi___p_c_ie_1_1_l_s_c_d_m_a___i_f.html#a5">writeSysDmaBuf</a>(buf, len))
00829         <span class="keywordflow">return</span>(len);
00830     <span class="keywordflow">else</span>
00831         <span class="keywordflow">return</span>(0);
00832 
00833 
00834 }
00835 
00836 
<a name="l00842"></a><a class="code" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html#a12">00842</a> size_t <a class="code" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html#a12">SGDMA::getSizeDrvrCB</a>(<span class="keywordtype">void</span>)
00843 {
00844     <span class="keywordflow">return</span>(CBDMABufSize);
00845 }
00846 
00847 
00848 
<a name="l00858"></a><a class="code" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html#a13">00858</a> <span class="keywordtype">void</span> <a class="code" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html#a13">SGDMA::fillDrvrCB</a>(uint32_t val, size_t len)
00859 {
00860     size_t i;
00861 
00862     <span class="comment">// First fill the write buffer using the 32bit values</span>
00863     <span class="keywordflow">if</span> (len == 0)
00864         len = CBDMABufSize;
00865     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (len &gt; CBDMABufSize)
00866         len = CBDMABufSize;
00867 
00868     <span class="keywordflow">for</span> (i = 0; i &lt; len/4; i++)
00869     {
00870         WriteDmaBuf[i] =  val;
00871     }
00872 
00873     <span class="comment">// Then transfer WriteDmaBuf[] into the system common DMA buffer</span>
00874     pDrvr-&gt;<a class="code" href="class_lattice_semi___p_c_ie_1_1_l_s_c_d_m_a___i_f.html#a5">writeSysDmaBuf</a>(WriteDmaBuf, len);
00875 
00876 }
00877 
00878 
<a name="l00890"></a><a class="code" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html#a14">00890</a> <span class="keywordtype">void</span> <a class="code" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html#a14">SGDMA::fillPatternDrvrCB</a>(uint32_t pattern, size_t len)
00891 {
00892     size_t i;
00893 
00894     <span class="comment">// First fill the write buffer using the 32bit pattern values</span>
00895     <span class="keywordflow">if</span> (len == 0)
00896         len = CBDMABufSize;
00897     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (len &gt; CBDMABufSize)
00898         len = CBDMABufSize;
00899 
00900     <span class="keywordflow">for</span> (i = 0; i &lt; len/4; i++)
00901     {
00902         WriteDmaBuf[i] =  pattern | i;
00903     }
00904 
00905     <span class="comment">// Then transfer WriteDmaBuf[] into the system common DMA buffer</span>
00906     pDrvr-&gt;<a class="code" href="class_lattice_semi___p_c_ie_1_1_l_s_c_d_m_a___i_f.html#a5">writeSysDmaBuf</a>(WriteDmaBuf, len);
00907 
00908 }
00909 
00910 
<a name="l00914"></a><a class="code" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html#a15">00914</a> <span class="keywordtype">void</span> <a class="code" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html#a15">SGDMA::clearDrvrCB</a>(<span class="keywordtype">void</span>)
00915 {
00916     memset(WriteDmaBuf, 0x00, CBDMABufSize);
00917     pDrvr-&gt;<a class="code" href="class_lattice_semi___p_c_ie_1_1_l_s_c_d_m_a___i_f.html#a5">writeSysDmaBuf</a>(WriteDmaBuf, CBDMABufSize);
00918 }
00919 
00920 
<a name="l00929"></a><a class="code" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html#a16">00929</a> <span class="keywordtype">int</span> <a class="code" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html#a16">SGDMA::checkDrvrCB</a>(size_t len)
00930 {
00931     size_t i;
00932     <span class="keywordtype">int</span> errs;
00933 
00934     <span class="comment">// WrBuf must still contain same pattern used in call to fillEBR() or fillSysDmaBuf()</span>
00935 
00936     <span class="keywordflow">if</span> ((len == 0) || (len &gt; CBDMABufSize))
00937         len = CBDMABufSize;
00938 
00939     <span class="comment">// Compare WrBuf[] with the values read from the DMA buffer</span>
00940 
00941     pDrvr-&gt;<a class="code" href="class_lattice_semi___p_c_ie_1_1_l_s_c_d_m_a___i_f.html#a6">readSysDmaBuf</a>(ReadDmaBuf);
00942 
00943     errs = 0;
00944     <span class="keywordflow">for</span> (i = 0; i &lt; len/4; ++i)
00945     {
00946         <span class="keywordflow">if</span> (WriteDmaBuf[i] != ReadDmaBuf[i])
00947             ++errs;
00948     }
00949 
00950     <span class="keywordflow">if</span> (errs)
00951     {
00952         cout&lt;&lt;<span class="stringliteral">"\tcheckSysDmaBuf: Errors!!! ReadBuf != WriteBuf"</span>&lt;&lt;endl;
00953         <span class="comment">//throw(PCIe_IF_Error("CHECK_SysDmaBuf FAILED COMPARISON."));</span>
00954     }
00955     <span class="keywordflow">else</span>
00956     {
00957         cout&lt;&lt;<span class="stringliteral">"\tcheckSysDmaBuf==&gt;PASS"</span>&lt;&lt;endl;
00958     }
00959     <span class="keywordflow">return</span>(errs);
00960 }
00961 
00962 
00963 
<a name="l00968"></a><a class="code" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html#a17">00968</a> <span class="keywordtype">void</span> <a class="code" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html#a17">SGDMA::showDrvrCB</a>(size_t len)
00969 {
00970     string ostr;
00971 
00972 
00973     <span class="keywordflow">if</span> ((len == 0) || (len &gt; CBDMABufSize))
00974         len = CBDMABufSize;
00975 
00976 
00977     cout&lt;&lt;<span class="stringliteral">"\nSystem Common Buffer Contents Display"</span>;
00978 
00979     pDrvr-&gt;<a class="code" href="class_lattice_semi___p_c_ie_1_1_l_s_c_d_m_a___i_f.html#a6">readSysDmaBuf</a>(ReadDmaBuf);
00980     <a class="code" href="class_lattice_semi___p_c_ie_1_1_mem_format.html#e2">MemFormat::formatBlockOfWords</a>(ostr, 0, len, ReadDmaBuf);
00981     cout&lt;&lt;ostr&lt;&lt;endl;
00982 
00983 }
00984 
<a name="l00992"></a><a class="code" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html#a18">00992</a> <span class="keywordtype">bool</span> <a class="code" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html#a18">SGDMA::testDrvrCB</a>(<span class="keywordtype">void</span>)
00993 {
00994 
00995     <a class="code" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html#a14">fillPatternDrvrCB</a>(0x12340000);
00996 
00997     <span class="comment">// Compare WrBuf[] with the values read from the DMA buffer</span>
00998     <span class="keywordflow">if</span> (<a class="code" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html#a16">checkDrvrCB</a>() == 0)
00999         <span class="keywordflow">return</span>(<span class="keyword">true</span>);
01000     <span class="keywordflow">else</span>
01001         <span class="keywordflow">return</span>(<span class="keyword">false</span>);
01002 
01003 }
01004 
01005 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Jul 16 12:05:26 2008 for Lattice PCIe API Manual by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
