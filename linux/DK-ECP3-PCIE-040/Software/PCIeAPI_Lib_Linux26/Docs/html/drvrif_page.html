<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Lattice PCIe API Manual: Driver Interfaces</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h2>Introduction</h2>
<p>
Driver Interface classes provide access to the underlying driver via its IOCTL and MMAP calls. The Driver Interface does not assume any knowledge of IP devices in the demo hardware. It may have some knowledge of specific register locations, but for the most part it is meant to be isolated from the specific memory map layout and IP design. It knows about the functionality of the driver which is exposed to the User Space via the standard Linux file APIs (open, read, write, ioctrl, mmap, close). These APIs are wrapped by methods in the Driver Interface class that provides the proper constants, insulating the above user demo app from needing to know how to implement and call these OS APIs to perform operations. <p>
Driver Interfaces also hide some of the details with opening the driver handle initially. The kernel drivers are opened using the device node filename in the /dev directory. The class constructor handles assamembling the filename based on the predefined Lattice format and opening the file handle that represents the driver interface in the OS. The constructor also does the mmap'ing of the available BARs into the object's memory space.<p>
Again, Driver Interfaces make accessing the functionality of the driver easier. They do not attempt to implement device specific control. That is the job of the Device Objects (which work through the Driver Interface). <p>
The following Driver Interface Classes are present in the PCIeAPI Library.<p>
<h2>LSCPCIe2_IF</h2>
<p>
Access to the lscpcie2 driver used in the Basic demo and Thruput demo. <br>
 See class <a class="el" href="class_lattice_semi___p_c_ie_1_1_l_s_c_p_c_ie2___i_f.html">LatticeSemi_PCIe::LSCPCIe2_IF</a><p>
<h2>LSCDMA_IF</h2>
<p>
Access to the lscdma driver used in the PCIe SGDMA demo. <br>
 See class <a class="el" href="class_lattice_semi___p_c_ie_1_1_l_s_c_d_m_a___i_f.html">LatticeSemi_PCIe::LSCDMA_IF</a><p>
<h2>Driver Interface Base Class</h2>
<p>
All above driver interfaces inherit from this base class. If you want to create a new driver interface class, then base it on this class. <br>
 See <a class="el" href="class_lattice_semi___p_c_ie_1_1_p_c_ie___i_f.html">LatticeSemi_PCIe::PCIe_IF</a> <hr size="1"><address style="align: right;"><small>Generated on Wed Jul 16 12:05:27 2008 for Lattice PCIe API Manual by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
