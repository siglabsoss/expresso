<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Lattice PCIe API Manual: Hardware Access</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
</head>
<body>
    <H2>Introduction</H2>
    This page discusses how the Device Objects in the PCIe API Library actually
    access the phycial registers in the demo IP.  The discussion assumes the 
    reader is familiar with PCI BARs and the concept of different address spaces.
    This will give a better understanding of what is really going on under the
    hood.
    <p>

    <H2>Addressing Architecture</H2>
    The demo IP modules are Wishbone slave devices with specific base memory
    addresses on the Wishbone bus.  The Wishbone bus is an Open Standard parallel
    bus (Address[], Data[], Rd/Wr, Ctrl, Ack, etc.).  A specific address on the
    Wishbone bus creates a chip-select for the addressed slave to respond to that bus cycle.
    Refer to the diagram below.

<pre>
<code>

               GPIO            EBR
	     Slave_0         Slave_1
	        |                |
	================================  Internal Wishbone Bus
	               |
	          -----------
		  | PCIe IP |        Eval Board
	          | BAR0    |           Domain
	          -----------
                       |
	================================   PCI/PCIe Bus
                       |
	           ---------
		   | Mem   |        PC System Bus
	           |  Ctrl |            Domain
	           ---------
                       |
	================================   Physical Address (CPU Bus)
                       |
	          -----------
	 Kernel   | Driver  |
	 Space    | BAR Map |
	          -----------           CPU
                       |              Software 
	           ---------           Domain
	  User     | Demo  |
	 Space     |  App  |
	           ---------

</code>
</pre>
    <p>
    At the other end of the picture (pun intended), software can only use CPU
    addresses to differentiate which device it wants to access.  For PCI/PCIe devices,
    the system assigns an address block for each BAR the device (Eval Board) has
    enabled in its config space. These address blocks are windows in PC physical bus
    address space that then access the eval board.
    <p>
    Only the driver knows what addresses the system (BIOS or bus enumeration driver in
    the OS kernel) has assigned to each of the eval board's BARs.  The driver obtains this information
    from the kernel when it gets started.  The driver can then map these physical PCI bus addresses
    into software pointers it can use.  The BAR addresses can be changed at anytime by the
    kernel to ballance system resources.  Therefore, the driver needs to treat these BAR
    mappings as "variables" and not hard-coded values. The driver creates a look-up table
    that stores the currently assigned PCI bus address for each BAR (up to 6 entries total).
    <p>
    The demo software can not use these BAR addresses directly since User Space code
    can only access memory within its virtual process space (CPU space). The demo application calls
    the driver and asks it to map the physical BAR address into its virtual memory space.
    This is done with the standard mmap() system call.  The demo application knows what BARs are used
    in the demo hardware and what addresses the various slave IP modules are located at.
    The PCIeAPI Device Objects and Driver Interfaces agree to use an addressing convention
    that the driver also understands.
    The Device Object specifies which BAR number and what offset within that BAR to read/write.
    The driver uses the BAR number to look-up the base location of that BAR in its PCI bus
    memory space table.  It then adds the offset to it and performs the read/write
    operation using the mmap'ed memory range.
    <p>
    The bus address causes the memory controller to steer the access to the Eval Board.
    The Root Complex turns the operation into a PCIe MRd or MWr TLP.
    The end-point PCIe IP core receives and decodes the TLP and matches the address
    to a BAR.  The IP uses this information to subtract off the BAR base address to
    get just the offset.  The Wishbone bus does not use the physical bus BAR address
    because this can change at any time during run time (by the OS) and would make 
    designing IP address decode logic very difficult.  The resulting offset is then placed
    on the Wishbone bus and the slave device is selected.

    <p>
    The addresses of each IP module in the demo design are usually defined in
    a MemMap.h header file local to a demo.  The MemMap.h uses macros provided by PCIeAPI
    to define hardware addresses via BAR + offsets.  The BAR and base address of each device
    are passed to the Device Object in its constructor.  Thereafter any read/write
    operation will use this value for its base and add the register offset to
    it.  Here is an example:
    <p>

<pre>
<code>
    #define GPIOreg(i)     ((BAR0(0x0000)) + i)
    #define SGDMAreg(i)    ((BAR0(0x2000)) + i)
    #define IMG_FIFOreg(i) ((BAR0(0x4000)) + i)
    #define EBR_64reg(i)   ((BAR0(0x10000)) + i)
</pre>
</code>


    <h3>Terminology Recap</h3>
    <ul>
	<li>Slave Address - base address of an IP module (Wishbone bus space)
	<li>BAR - Base Address of a window into the PCIe Eval Board (PCI bus space)
	<li>Device Address -  {BAR#[31:28], Slave Address[27:0]} (PCIeAPI/driver software address convention)
    </ul>

    <h2>Read/Write Access</h2>
    Reading and writing are done using the read/write() methods found in the Device base class.
    A method for each data size transfered (byte, short, word) is provided.  This allows access
    to 8 bit wide slaves on true byte addresses.
    <ul>
	<li> read8/write8()
	<li> read16/write16()
	<li> read32/write32()
    </ul>
    Block transfers are also available in each data size.  Block transfers just use a loop
    write the buffer of data.  They do not actually create a TLP with a larger payload (see
    Write Combining).  Block transfer methods are just a programming convience.

    <h3>Via Device Classes</h3>
    Each Device class provides read/write methods that then call the Driver Interface to
    enlist the driver to perform the real data transfer.  The class internally adds the base address
    supplied when it was created, so the user only needs to specify the register offset within the
    IP device. 
    <br>
    <B>x = GPIO.read8(0x0a)</B> would read the DIP switch input register in the GPIO module.
    <p>
    The Device class read/write methods also provide range checking.  They throw an exception
    if the register address is beyond the address range of the device specified when created.
    This can catch addressing bugs that may otherwise go undetected for a while.

    <h3>Via Drive Interface</h3>
    The DriverInterface class provides the actual read/write methods that invoke the driver.
    The user can directly use these methods to access any BAR and any offset within the BAR.
    This obviously needs to be done with caution. 
    <br>
    <B>pDrvr->write32(0x10004000, 0x00)</B> will write 0x00 to offset 0x4000 in BAR1.

    <h3>Via the Driver Directly</h3>
    The driver can be used without the PCIeAPI library, but the read/write commands need to
    be converted to pointer accesses that point to the mmap'ed memory range.  The pointer
    is obtained by performing a mmap() system call.
    This is not the recommended method, but nothing would prevent one from using
    this direct method if the PCIeAPI library was too heavy.

</body>
</html>
 <hr size="1"><address style="align: right;"><small>Generated on Wed Jul 16 12:05:27 2008 for Lattice PCIe API Manual by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
