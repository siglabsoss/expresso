<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Lattice PCIe API Manual: LatticeSemi_PCIe::SGDMA Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>LatticeSemi_PCIe::SGDMA Class Reference</h1><code>#include &lt;<a class="el" href="_s_g_d_m_a_8h-source.html">SGDMA.h</a>&gt;</code>
<p>
<p>Inheritance diagram for LatticeSemi_PCIe::SGDMA:
<p><center><img src="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.png" usemap="#LatticeSemi_PCIe::SGDMA_map" border="0" alt=""></center>
<map name="LatticeSemi_PCIe::SGDMA_map">
<area href="class_lattice_semi___p_c_ie_1_1_device.html" alt="LatticeSemi_PCIe::Device" shape="rect" coords="0,0,162,24">
</map>
<a href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html#a0">SGDMA</a> (const char *nameStr, uint32_t addr, <a class="el" href="class_lattice_semi___p_c_ie_1_1_l_s_c_d_m_a___i_f.html">LatticeSemi_PCIe::LSCDMA_IF</a> *pRA)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html#a1">~SGDMA</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html#a2">ReadFromCB</a> (uint8_t chan, size_t len, uint32_t destAddr, uint32_t destMode, uint32_t destSize, uint32_t numBDs=1, uint32_t startBD=0)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html#a3">WriteToCB</a> (uint8_t chan, size_t len, uint32_t srcAddr, uint32_t srcMode, uint32_t srcSize, uint32_t numBDs=1, uint32_t startBD=0)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html#a4">enableCore</a> (uint16_t chanMask)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html#a5">disableCore</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html#a6">getID</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html#a7">getHdwParams</a> (uint8_t &amp;numChan, uint32_t &amp;numBDs)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html#a8">getChanStatusStr</a> (string &amp;outs, uint32_t chan)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html#a9">checkChanStatus</a> (uint32_t chan)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html#a10">getDrvrCB</a> (uint32_t *buf, size_t len=0)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html#a11">setDrvrCB</a> (uint32_t *buf, size_t len=0)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html#a12">getSizeDrvrCB</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html#a13">fillDrvrCB</a> (uint32_t val, size_t len=0)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html#a14">fillPatternDrvrCB</a> (uint32_t pattern, size_t len=0)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html#a15">clearDrvrCB</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html#a16">checkDrvrCB</a> (size_t len=0)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html#a17">showDrvrCB</a> (size_t len=0)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html#a18">testDrvrCB</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html#a19">showGlobalRegs</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html#a20">showChannelRegs</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html#a21">showBufDescRegs</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html#a22">verifyBufDescRegs</a> (void)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Specific definition of a Lattice Scatter Gather IP Core used in demos.<p>
This class provides test and debug access to the Lattice <a class="el" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html">SGDMA</a> IP Core for investigative purposes. This class does not provide a complete, optimized driver solution. For example, interrupts are not used (no convenient way to call-back into user space). The user is repsonsible for knowing and managing their channel usage. The methods do not know which channels are defined and which are read and which are write. The class methods provide a general-purpose software view of the <a class="el" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html">SGDMA</a> features and registers. They do not use implementation specific features such as interrupts, DMA_req lines, bus locking, packet buffer, etc. Triggering transfers is done via software writing to the REQUEST bit. Looking for completion is done by reading the XFERCOMP bit. Things that are considered implementation specific (and not handled here): <ul>
<li>
use of and mapping of interrupts </li>
<li>
hardware device requesting transfer via DMA req port </li>
<li>
non-standard PCIe/SGDMA configuration </li>
<li>
use of packet buffer and split transfers </li>
<li>
whether arbiter included in IP core </li>
</ul>
Be aware of the following: <ul>
<li>
Use only for testing <a class="el" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html">SGDMA</a> transfer scenarios and IP </li>
<li>
Do not use concurrent with driver initiated DMA transfers </li>
<li>
User must manage common buffer access - i.e. mutex </li>
<li>
best to only use in single threaded program - or else synchronize access </li>
<li>
no control of hardware or knowledge of implementation specifics </li>
</ul>
<p>
This class inherits from the generic <a class="el" href="class_lattice_semi___p_c_ie_1_1_device.html">Device</a> class to provide the actual read/write methods. The class needs a <a class="el" href="class_lattice_semi___p_c_ie_1_1_register_access.html">RegisterAccess</a> object (the Driver Interface) to pass to the <a class="el" href="class_lattice_semi___p_c_ie_1_1_device.html">Device</a> class for the hardware access. <p>
The <a class="el" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html">SGDMA</a> IP core is a standard product from Lattice Semiconductor. The IP provides Scatter Gather DMA transfers between Wishbone bus slave devices. The <a class="el" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html">SGDMA</a> core has 2 Wishbone Master interfacest that initiate the bus transactions. For PCIe applications, one Wishbone Master interface is connected to the PCIe IP core and the other to a general purpose Wishbone bus that has the data devices for DMAing. Please refer to the <a class="el" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html">SGDMA</a> Data sheet for specific operation details. See diagram below for compatible architecture. <p>
The <a class="el" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html">SGDMA</a> has configuration registers for provisioning and controlling the transfers. The registers are grouped as Global Configuration, Channel Configuration and Buffer Descriptors. <ul>
<li>
0x000 - Global Registers </li>
<li>
0x200 - Channel Registers </li>
<li>
0x400 - Buffer Descriptor Registers </li>
</ul>
<p>
This class expects the IP architecture to look like: <div class="fragment"><pre class="fragment">
 
          Memory Slave Devices
      |                 |        |
      |    Wishbone Bus |        |
   ======================================
              ^                     |
              |                     |
    ---------------------------     |
	|        WB_A             |     |
	|                         |     |
	|     SGDMA IP Core    Slv|&lt;-----
	|                         |
	|         WB_B            |
    ---------------------------
	            |
				V
       ---------------------
	   | PCIe Adapter Core |
       ---------------------
	            |
				V
         ----------------
	     | PCIe IP Core |
         ----------------
 
 
 
</pre></div><p>
All transfers setup by this class use the lscdma kernel-allocated Common Buffer for the soruce/destination of the DMA transfer on the PC side. The Common Buffer is used because it is a contiguous block of fixed memory given to the driver. Its physical address is easily obtained and used for the programming the <a class="el" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html">SGDMA</a> channel registers. The <a class="el" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html">SGDMA</a> core is not used in "scatter-gather" mode in the sense that it accesses physically distributed user-space virtual memory pages that make up the user buffer. Mapping virtual memory to a scatter-gather list requires many kernel API calls that would become cumbersome to translate and carry back and forth across this interface, plus would require re-creating these APIs as interfaces to the driver (IOCTL calls). Therefore, true scatter-gather is performed entirely in the driver on dedicated functional devices. This means that such a driver has IP architecture specific knowledge and is not appropriate for a general purpose <a class="el" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html">SGDMA</a> class. So, to be general purpose this class does what is known as Common Buffer transfers. Multiple BD's can still be linked to simulate a "scatter-gather" list, but true virtual memory mapping is not done here. 
<p>

<p>
Definition at line <a class="el" href="_s_g_d_m_a_8h-source.html#l00207">207</a> of file <a class="el" href="_s_g_d_m_a_8h-source.html">SGDMA.h</a>.<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="a0" doxytag="LatticeSemi_PCIe::SGDMA::SGDMA"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">SGDMA::SGDMA           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>nameStr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>uint32_t&nbsp;</td>
          <td class="mdname" nowrap> <em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="class_lattice_semi___p_c_ie_1_1_l_s_c_d_m_a___i_f.html">LatticeSemi_PCIe::LSCDMA_IF</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>pRA</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Construct access to a Lattice <a class="el" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html">SGDMA</a> IP module. Register access to the IP in the FPGA device is through the Driver Interface object instantiated at the start of the program.<p>
The base class <a class="el" href="class_lattice_semi___p_c_ie_1_1_device.html">Device</a> is initialized to the base address and register size.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nameStr</em>&nbsp;</td><td>the name of the FPGA device for unique naming </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>baseAddr</em>&nbsp;</td><td>the physical bus address the device registers start at </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pRA</em>&nbsp;</td><td>pointer to the interface object to the lscdma device driver. this clas requires access to the driver to open channels. It also uses the driver for the <a class="el" href="class_lattice_semi___p_c_ie_1_1_register_access.html">RegisterAccess</a> object for accessing the hardware registers. </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="_s_g_d_m_a_8cpp-source.html#l00044">44</a> of file <a class="el" href="_s_g_d_m_a_8cpp-source.html">SGDMA.cpp</a>.
<p>
References <a class="el" href="lscdma_2_ioctl_8h-source.html#l00044">DMAResourceInfo_t::DmaBufSize</a>, <a class="el" href="lscdma_2_ioctl_8h-source.html#l00047">DMAResourceInfo_t::DmaPhyAddrLo</a>, <a class="el" href="_l_s_c_d_m_a___i_f_8cpp-source.html#l00099">LatticeSemi_PCIe::LSCDMA_IF::getDriverDMAInfo()</a>, <a class="el" href="_s_g_d_m_a_8cpp-source.html#l00573">getHdwParams()</a>, <a class="el" href="_s_g_d_m_a_8cpp-source.html#l00557">getID()</a>, <a class="el" href="lscdma_2_ioctl_8h-source.html#l00043">DMAResourceInfo_t::hasDmaBuf</a>, and <a class="el" href="_device_8cpp-source.html#l00177">LatticeSemi_PCIe::Device::write32()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a1" doxytag="LatticeSemi_PCIe::SGDMA::~SGDMA"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">SGDMA::~<a class="el" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html">SGDMA</a>           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Destroy the <a class="el" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html">SGDMA</a> IP module. The device should no longer be accessed using any methods. All references to the device will now be invalid. 
<p>
Definition at line <a class="el" href="_s_g_d_m_a_8cpp-source.html#l00134">134</a> of file <a class="el" href="_s_g_d_m_a_8cpp-source.html">SGDMA.cpp</a>.
<p>
References <a class="el" href="_device_8cpp-source.html#l00177">LatticeSemi_PCIe::Device::write32()</a>.    </td>
  </tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="a9" doxytag="LatticeSemi_PCIe::SGDMA::checkChanStatus"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool SGDMA::checkChanStatus           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">uint32_t&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>chan</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Verify the Channels status registers don't show errors and are done the transfer. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>chan</em>&nbsp;</td><td>the channel number to check (0-15) </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>true if no errors, false if errors </dd></dl>

<p>
Definition at line <a class="el" href="_s_g_d_m_a_8cpp-source.html#l00745">745</a> of file <a class="el" href="_s_g_d_m_a_8cpp-source.html">SGDMA.cpp</a>.
<p>
References <a class="el" href="_s_g_d_m_a_8cpp-source.html#l00695">getChanStatusStr()</a>, and <a class="el" href="_device_8cpp-source.html#l00159">LatticeSemi_PCIe::Device::read32()</a>.
<p>
Referenced by <a class="el" href="_s_g_d_m_a_8cpp-source.html#l00180">ReadFromCB()</a>, and <a class="el" href="_s_g_d_m_a_8cpp-source.html#l00353">WriteToCB()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a16" doxytag="LatticeSemi_PCIe::SGDMA::checkDrvrCB"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int SGDMA::checkDrvrCB           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">size_t&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>len</em> = <code>0</code>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Checking the buffer compares what is in the WriteDmaBuf with what is read back into the ReadDmaBuf. The usage would be to load the WriteDmaBuf using a fillSysDmaBuf() call. Then transfer the DMA buf to the destination device, and read back with <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>in bytes, optional: if not given defaults to entire buf length </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="_s_g_d_m_a_8cpp-source.html#l00929">929</a> of file <a class="el" href="_s_g_d_m_a_8cpp-source.html">SGDMA.cpp</a>.
<p>
References <a class="el" href="_l_s_c_d_m_a___i_f_8cpp-source.html#l00160">LatticeSemi_PCIe::LSCDMA_IF::readSysDmaBuf()</a>.
<p>
Referenced by <a class="el" href="_s_g_d_m_a_8cpp-source.html#l00992">testDrvrCB()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a15" doxytag="LatticeSemi_PCIe::SGDMA::clearDrvrCB"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void SGDMA::clearDrvrCB           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Fill the system Common Buffer DMA buffer with all 0's. 
<p>
Definition at line <a class="el" href="_s_g_d_m_a_8cpp-source.html#l00914">914</a> of file <a class="el" href="_s_g_d_m_a_8cpp-source.html">SGDMA.cpp</a>.
<p>
References <a class="el" href="_l_s_c_d_m_a___i_f_8cpp-source.html#l00118">LatticeSemi_PCIe::LSCDMA_IF::writeSysDmaBuf()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a5" doxytag="LatticeSemi_PCIe::SGDMA::disableCore"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void SGDMA::disableCore           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Disable the IP core. Turn off all channels, turn off Bus masters, turn off core, mask everything. Core should not do anything anymore. Use to halt core for diagnostics to ensure its not running or could be triggered to run when peeking an dpoking registers. <dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>exception</em>&nbsp;</td><td>if register read or write fails </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="_s_g_d_m_a_8cpp-source.html#l00539">539</a> of file <a class="el" href="_s_g_d_m_a_8cpp-source.html">SGDMA.cpp</a>.
<p>
References <a class="el" href="_device_8cpp-source.html#l00177">LatticeSemi_PCIe::Device::write32()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a4" doxytag="LatticeSemi_PCIe::SGDMA::enableCore"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void SGDMA::enableCore           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">uint16_t&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>chanMask</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Enable the IP core and specified channels. Enabling enables the core and the Wishbone buses. It also enables channels, which will also enable the channel in the arbiter mask. Hardware request masks and event masks are left disabled. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>chanMask</em>&nbsp;</td><td>set bit position to a 1 to enable that channel.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>exception</em>&nbsp;</td><td>if register read or write fails </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="_s_g_d_m_a_8cpp-source.html#l00515">515</a> of file <a class="el" href="_s_g_d_m_a_8cpp-source.html">SGDMA.cpp</a>.
<p>
References <a class="el" href="_device_8cpp-source.html#l00159">LatticeSemi_PCIe::Device::read32()</a>, and <a class="el" href="_device_8cpp-source.html#l00177">LatticeSemi_PCIe::Device::write32()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a13" doxytag="LatticeSemi_PCIe::SGDMA::fillDrvrCB"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void SGDMA::fillDrvrCB           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">uint32_t&nbsp;</td>
          <td class="mdname" nowrap> <em>val</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>size_t&nbsp;</td>
          <td class="mdname" nowrap> <em>len</em> = <code>0</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Fill System DMA memory range with a specified value. The global WrBuf[] is first loaded with the value, then the contents of the WrBuf[] are transfered to the system buffer, using the driver ioctl call. WrBuf[] is then used as the comparison in checkEBR() or <a class="el" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html#a16">checkDrvrCB()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>32 bit value written into each 32bit location </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>in bytes, optional: if not given defaults to entire buf length </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="_s_g_d_m_a_8cpp-source.html#l00858">858</a> of file <a class="el" href="_s_g_d_m_a_8cpp-source.html">SGDMA.cpp</a>.
<p>
References <a class="el" href="_l_s_c_d_m_a___i_f_8cpp-source.html#l00118">LatticeSemi_PCIe::LSCDMA_IF::writeSysDmaBuf()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a14" doxytag="LatticeSemi_PCIe::SGDMA::fillPatternDrvrCB"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void SGDMA::fillPatternDrvrCB           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">uint32_t&nbsp;</td>
          <td class="mdname" nowrap> <em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>size_t&nbsp;</td>
          <td class="mdname" nowrap> <em>len</em> = <code>0</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Fill System DMA memory range with a specific pattern. The global WrBuf[] is first loaded with the pattern, then the contents of the WrBuf[] are transfered to the system buffer, using the driver ioctl call. WrBuf[] is then used as the comparison in checkEBR() or checkSysDmaBuf(). The pattern is the upper 16 bits of input param pattern OR'ed an incrementing value per word written. Example: aa550000 aa550001 aa550002 ...<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pattern</em>&nbsp;</td><td>upper 16 bits will be preserved and written into each 32bit location </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>in bytes, optional: if not given defaults to entire buf length </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="_s_g_d_m_a_8cpp-source.html#l00890">890</a> of file <a class="el" href="_s_g_d_m_a_8cpp-source.html">SGDMA.cpp</a>.
<p>
References <a class="el" href="_l_s_c_d_m_a___i_f_8cpp-source.html#l00118">LatticeSemi_PCIe::LSCDMA_IF::writeSysDmaBuf()</a>.
<p>
Referenced by <a class="el" href="_s_g_d_m_a_8cpp-source.html#l00992">testDrvrCB()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a8" doxytag="LatticeSemi_PCIe::SGDMA::getChanStatusStr"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void SGDMA::getChanStatusStr           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">string &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>outs</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>uint32_t&nbsp;</td>
          <td class="mdname" nowrap> <em>chan</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the Channel's status registers in a formatted string. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>outs</em>&nbsp;</td><td>the string to place the formatted values of the registers in </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>chan</em>&nbsp;</td><td>the <a class="el" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html">SGDMA</a> channel to operate on </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="_s_g_d_m_a_8cpp-source.html#l00695">695</a> of file <a class="el" href="_s_g_d_m_a_8cpp-source.html">SGDMA.cpp</a>.
<p>
References <a class="el" href="_device_8cpp-source.html#l00159">LatticeSemi_PCIe::Device::read32()</a>.
<p>
Referenced by <a class="el" href="_s_g_d_m_a_8cpp-source.html#l00745">checkChanStatus()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a10" doxytag="LatticeSemi_PCIe::SGDMA::getDrvrCB"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">size_t SGDMA::getDrvrCB           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">uint32_t *&nbsp;</td>
          <td class="mdname" nowrap> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>size_t&nbsp;</td>
          <td class="mdname" nowrap> <em>len</em> = <code>0</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the contents of the Driver's Common Buffer into the user supplied buffer. The DMA Common Buffer, starting at offset 0, is read for len bytes into buf. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>pointer to storage for bytes read from driver buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>number of bytes to read. Optional: if not given all read </td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>Use <a class="el" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html#a12">getSizeDrvrCB()</a> to ensure adequate storage has been allocated. <p>
len should be a multiple of 4. </dd></dl>
<dl compact><dt><b>Returns:</b></dt><dd>the number of bytes loaded into buf. </dd></dl>

<p>
Definition at line <a class="el" href="_s_g_d_m_a_8cpp-source.html#l00802">802</a> of file <a class="el" href="_s_g_d_m_a_8cpp-source.html">SGDMA.cpp</a>.
<p>
References <a class="el" href="_l_s_c_d_m_a___i_f_8cpp-source.html#l00160">LatticeSemi_PCIe::LSCDMA_IF::readSysDmaBuf()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a7" doxytag="LatticeSemi_PCIe::SGDMA::getHdwParams"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void SGDMA::getHdwParams           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">uint8_t &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>numChan</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>uint32_t &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>numBDs</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Read the 32bit <a class="el" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html">SGDMA</a> IP Version Register and parse out the current hardware build configuration. <dl compact><dt><b>Note:</b></dt><dd>The BDs are fixed at 256 until the <a class="el" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html">SGDMA</a> IP core has this info in it </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>numChan</em>&nbsp;</td><td>returns the number of channels the IP was built with </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>numBDs</em>&nbsp;</td><td>returns the number of BDs </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>exception</em>&nbsp;</td><td>if register read register fails </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="_s_g_d_m_a_8cpp-source.html#l00573">573</a> of file <a class="el" href="_s_g_d_m_a_8cpp-source.html">SGDMA.cpp</a>.
<p>
References <a class="el" href="_device_8cpp-source.html#l00159">LatticeSemi_PCIe::Device::read32()</a>.
<p>
Referenced by <a class="el" href="_s_g_d_m_a_8cpp-source.html#l00044">SGDMA()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a6" doxytag="LatticeSemi_PCIe::SGDMA::getID"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">uint32_t SGDMA::getID           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Read the 32bit <a class="el" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html">SGDMA</a> IP ID register. <dl compact><dt><b>Returns:</b></dt><dd>32bit <a class="el" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html">SGDMA</a> ID value </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>exception</em>&nbsp;</td><td>if register read fails </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="_s_g_d_m_a_8cpp-source.html#l00557">557</a> of file <a class="el" href="_s_g_d_m_a_8cpp-source.html">SGDMA.cpp</a>.
<p>
References <a class="el" href="_device_8cpp-source.html#l00159">LatticeSemi_PCIe::Device::read32()</a>.
<p>
Referenced by <a class="el" href="_s_g_d_m_a_8cpp-source.html#l00044">SGDMA()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a12" doxytag="LatticeSemi_PCIe::SGDMA::getSizeDrvrCB"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">size_t SGDMA::getSizeDrvrCB           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the size of the Driver's Common Buffer. Used so user code can allocate a buffer this size to use for get/setDrvrCB(). <dl compact><dt><b>Returns:</b></dt><dd>the size of the buffer in bytes. </dd></dl>

<p>
Definition at line <a class="el" href="_s_g_d_m_a_8cpp-source.html#l00842">842</a> of file <a class="el" href="_s_g_d_m_a_8cpp-source.html">SGDMA.cpp</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a2" doxytag="LatticeSemi_PCIe::SGDMA::ReadFromCB"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool SGDMA::ReadFromCB           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">uint8_t&nbsp;</td>
          <td class="mdname" nowrap> <em>chan</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>size_t&nbsp;</td>
          <td class="mdname" nowrap> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>uint32_t&nbsp;</td>
          <td class="mdname" nowrap> <em>dstAddr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>uint32_t&nbsp;</td>
          <td class="mdname" nowrap> <em>dstMode</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>uint32_t&nbsp;</td>
          <td class="mdname" nowrap> <em>dstSize</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>uint32_t&nbsp;</td>
          <td class="mdname" nowrap> <em>nBDs</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>uint32_t&nbsp;</td>
          <td class="mdname" nowrap> <em>bdStart</em> = <code>0</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Setup a channel to perform a Read operation and trigger it via software. The <a class="el" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html">SGDMA</a> core performs the read operation and then halts. A Read operation issues a series of MRd TLPs to the PC to read from the common buffer driver memory. The common buffer memory is used as the source of the transfer. Any location on the Wishbone can be specified as the destination. This method is primarily meant for testing DMA transfer operation and is not optimal. The user must first load the Common Buffer using one of the other methods. Max Read Request size is determined from the Link Capabilities. Total transfer size is limitted by the Common buffer size which is usually under 64kB. Number of BDs used can be programmed to demonstrate linking, but BDs can not specify under 8 bytes minimum or more than 64kB maximum for a transfer.<p>
<dl compact><dt><b>Note:</b></dt><dd>The channel must be linked to a Read adapter port to issue MRd and wait for CplD</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>chan</em>&nbsp;</td><td>the channel to perform the read operation on </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>the total number of bytes to transfer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>destAddr</em>&nbsp;</td><td>slave address on wishbone bus - destination of transfer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>destMode</em>&nbsp;</td><td>addressing mode; 0=FIFO, 1=linear, 2=loop </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>destSize</em>&nbsp;</td><td>data width; 0=8bit, 1=16bit, 2=32bit, 3=64bit </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>numBDs</em>&nbsp;</td><td>choose how many BDs to use, default=1. Errors if greater than hardware has. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>startBD</em>&nbsp;</td><td>choose where to start, default=0. Errors if greater than hardware has.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>The channel must be setup in hardware to perform a read (MRd TLPs). </dd></dl>

<p>
Definition at line <a class="el" href="_s_g_d_m_a_8cpp-source.html#l00180">180</a> of file <a class="el" href="_s_g_d_m_a_8cpp-source.html">SGDMA.cpp</a>.
<p>
References <a class="el" href="_s_g_d_m_a_8cpp-source.html#l00745">checkChanStatus()</a>, <a class="el" href="lscdma_2_ioctl_8h-source.html#l00051">DMAResourceInfo_t::MaxReadReqSize</a>, <a class="el" href="_device_8cpp-source.html#l00159">LatticeSemi_PCIe::Device::read32()</a>, and <a class="el" href="_device_8cpp-source.html#l00177">LatticeSemi_PCIe::Device::write32()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a11" doxytag="LatticeSemi_PCIe::SGDMA::setDrvrCB"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">size_t SGDMA::setDrvrCB           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">uint32_t *&nbsp;</td>
          <td class="mdname" nowrap> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>size_t&nbsp;</td>
          <td class="mdname" nowrap> <em>len</em> = <code>0</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Load the contents of the Driver's Common Buffer with the user supplied buffer. The DMA Common Buffer, starting at offset 0, is loaded with len bytes from buf. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>pointer to storage for bytes read from driver buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>number of bytes to written. Optional: if not given, load entire buffer </td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>Use <a class="el" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html#a12">getSizeDrvrCB()</a> to ensure adequate storage has been allocated. <p>
len should be a multiple of 4. </dd></dl>
<dl compact><dt><b>Returns:</b></dt><dd>the number of bytes written into the driver buffer. </dd></dl>

<p>
Definition at line <a class="el" href="_s_g_d_m_a_8cpp-source.html#l00823">823</a> of file <a class="el" href="_s_g_d_m_a_8cpp-source.html">SGDMA.cpp</a>.
<p>
References <a class="el" href="_l_s_c_d_m_a___i_f_8cpp-source.html#l00118">LatticeSemi_PCIe::LSCDMA_IF::writeSysDmaBuf()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a21" doxytag="LatticeSemi_PCIe::SGDMA::showBufDescRegs"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void SGDMA::showBufDescRegs           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Display all <a class="el" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html">SGDMA</a> Buffer Descriptor Registers. Use for debugging and testing to dump the <a class="el" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html">SGDMA</a> register values. 
<p>
Definition at line <a class="el" href="_s_g_d_m_a_8cpp-source.html#l00629">629</a> of file <a class="el" href="_s_g_d_m_a_8cpp-source.html">SGDMA.cpp</a>.
<p>
References <a class="el" href="_device_8cpp-source.html#l00159">LatticeSemi_PCIe::Device::read32()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a20" doxytag="LatticeSemi_PCIe::SGDMA::showChannelRegs"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void SGDMA::showChannelRegs           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Display all <a class="el" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html">SGDMA</a> Channel Config Registers. Use for debugging and testing to dump the <a class="el" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html">SGDMA</a> register values. 
<p>
Definition at line <a class="el" href="_s_g_d_m_a_8cpp-source.html#l00604">604</a> of file <a class="el" href="_s_g_d_m_a_8cpp-source.html">SGDMA.cpp</a>.
<p>
References <a class="el" href="_device_8cpp-source.html#l00159">LatticeSemi_PCIe::Device::read32()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a17" doxytag="LatticeSemi_PCIe::SGDMA::showDrvrCB"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void SGDMA::showDrvrCB           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">size_t&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>len</em> = <code>0</code>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Display the contents of the System DMA buffer. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>= number of bytes to show, Optional: if not given defaults to all </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="_s_g_d_m_a_8cpp-source.html#l00968">968</a> of file <a class="el" href="_s_g_d_m_a_8cpp-source.html">SGDMA.cpp</a>.
<p>
References <a class="el" href="_mem_format_8cpp-source.html#l00407">LatticeSemi_PCIe::MemFormat::formatBlockOfWords()</a>, and <a class="el" href="_l_s_c_d_m_a___i_f_8cpp-source.html#l00160">LatticeSemi_PCIe::LSCDMA_IF::readSysDmaBuf()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a19" doxytag="LatticeSemi_PCIe::SGDMA::showGlobalRegs"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void SGDMA::showGlobalRegs           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Display all <a class="el" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html">SGDMA</a> Global Registers. Use for debugging and testing to dump the <a class="el" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html">SGDMA</a> register values. 
<p>
Definition at line <a class="el" href="_s_g_d_m_a_8cpp-source.html#l00586">586</a> of file <a class="el" href="_s_g_d_m_a_8cpp-source.html">SGDMA.cpp</a>.
<p>
References <a class="el" href="_device_8cpp-source.html#l00159">LatticeSemi_PCIe::Device::read32()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a18" doxytag="LatticeSemi_PCIe::SGDMA::testDrvrCB"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool SGDMA::testDrvrCB           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Run test to verify that the Common Buffer memory in the driver can be accessed and can be written with values and read back with values and the contents match. The entire contents are checked. <dl compact><dt><b>Returns:</b></dt><dd>true if all test operations succeed. </dd></dl>

<p>
Definition at line <a class="el" href="_s_g_d_m_a_8cpp-source.html#l00992">992</a> of file <a class="el" href="_s_g_d_m_a_8cpp-source.html">SGDMA.cpp</a>.
<p>
References <a class="el" href="_s_g_d_m_a_8cpp-source.html#l00929">checkDrvrCB()</a>, and <a class="el" href="_s_g_d_m_a_8cpp-source.html#l00890">fillPatternDrvrCB()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a22" doxytag="LatticeSemi_PCIe::SGDMA::verifyBufDescRegs"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool SGDMA::verifyBufDescRegs           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Verify access to all <a class="el" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html">SGDMA</a> Buffer Descriptor Registers. Use for debugging and testing to validate that all registers can be written and read and have the correct values. <dl compact><dt><b>Warning:</b></dt><dd>Do not execute while DMA transfers are in progress! </dd></dl>

<p>
Definition at line <a class="el" href="_s_g_d_m_a_8cpp-source.html#l00657">657</a> of file <a class="el" href="_s_g_d_m_a_8cpp-source.html">SGDMA.cpp</a>.
<p>
References <a class="el" href="_device_8cpp-source.html#l00159">LatticeSemi_PCIe::Device::read32()</a>, and <a class="el" href="_device_8cpp-source.html#l00177">LatticeSemi_PCIe::Device::write32()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a3" doxytag="LatticeSemi_PCIe::SGDMA::WriteToCB"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool SGDMA::WriteToCB           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">uint8_t&nbsp;</td>
          <td class="mdname" nowrap> <em>chan</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>size_t&nbsp;</td>
          <td class="mdname" nowrap> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>uint32_t&nbsp;</td>
          <td class="mdname" nowrap> <em>srcAddr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>uint32_t&nbsp;</td>
          <td class="mdname" nowrap> <em>srcMode</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>uint32_t&nbsp;</td>
          <td class="mdname" nowrap> <em>srcSize</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>uint32_t&nbsp;</td>
          <td class="mdname" nowrap> <em>nBDs</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>uint32_t&nbsp;</td>
          <td class="mdname" nowrap> <em>bdStart</em> = <code>0</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Setup a channel to perform a Write operation and trigger it via software. The <a class="el" href="class_lattice_semi___p_c_ie_1_1_s_g_d_m_a.html">SGDMA</a> core performs the write operation and then halts. A Write operation issues a series of MWr TLPs to the PC to write into the common buffer driver memory. The common buffer memory is used as the destination of the transfer. Any location on the Wishbone can be specified as the source. This method is primarily meant for testing DMA transfer operation and is not optimal. The user must read the Common Buffer contents using one of the other methods. Max TLP size is determined from the Link Capabilities. Total transfer size is limitted by the Common buffer size which is usually under 64kB. Number of BDs used can be programmed to demonstrate linking, but BDs can not specify under 8 bytes minimum or more than 64kB maximum for a transfer.<p>
<dl compact><dt><b>Note:</b></dt><dd>The channel must be linked to a Write adapter port to issue MWr TLPs.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>chan</em>&nbsp;</td><td>the channel to perform the write operation; 0-15 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>the total number of bytes to transfer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>srcAddr</em>&nbsp;</td><td>slave address on wishbone bus - source of transfer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>srcMode</em>&nbsp;</td><td>addressing mode; 0=FIFO, 1=Linear, 2=Loop </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>srcSize</em>&nbsp;</td><td>data width; 0=8bit, 1=16bit, 2=32bit, 3=64bit </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>numBDs</em>&nbsp;</td><td>choose how many BDs to use, default=1. Errors if greater than hardware has. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>startBD</em>&nbsp;</td><td>choose where to start, default=0. Errors if greater than hardware has. </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="_s_g_d_m_a_8cpp-source.html#l00353">353</a> of file <a class="el" href="_s_g_d_m_a_8cpp-source.html">SGDMA.cpp</a>.
<p>
References <a class="el" href="_s_g_d_m_a_8cpp-source.html#l00745">checkChanStatus()</a>, <a class="el" href="lscdma_2_ioctl_8h-source.html#l00050">DMAResourceInfo_t::MaxPayloadSize</a>, <a class="el" href="_device_8cpp-source.html#l00159">LatticeSemi_PCIe::Device::read32()</a>, and <a class="el" href="_device_8cpp-source.html#l00177">LatticeSemi_PCIe::Device::write32()</a>.    </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Wed Jul 16 12:05:27 2008 for Lattice PCIe API Manual by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
