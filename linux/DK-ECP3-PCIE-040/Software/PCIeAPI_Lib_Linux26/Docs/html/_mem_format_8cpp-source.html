<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Lattice PCIe API Manual: MemFormat.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<div class="nav">
<a class="el" href="dir_000000.html">Utils</a></div>
<h1>MemFormat.cpp</h1><a href="_mem_format_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment"> *  COPYRIGHT (c) 2008 by Lattice Semiconductor Corporation</span>
00003 <span class="comment"> *</span>
00004 <span class="comment"> * All rights reserved. All use of this software and documentation is</span>
00005 <span class="comment"> * subject to the License Agreement located in the file LICENSE.</span>
00006 <span class="comment"> */</span>
00007 
00010 <span class="keyword">using</span> <span class="keyword">namespace </span>std;
00011 
00012 <span class="preprocessor">#include &lt;iostream&gt;</span>
00013 <span class="preprocessor">#include &lt;string&gt;</span>
00014 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00015 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00016 <span class="preprocessor">#include &lt;string.h&gt;</span>
00017 
00018 
00019 
00020 <span class="preprocessor">#include "<a class="code" href="_mem_format_8h.html">MemFormat.h</a>"</span>
00021 
00022 <span class="keyword">using</span> <span class="keyword">namespace </span>LatticeSemi_PCIe;
00023 
00024 
<a name="l00031"></a><a class="code" href="class_lattice_semi___p_c_ie_1_1_mem_format.html#a0">00031</a> <a class="code" href="class_lattice_semi___p_c_ie_1_1_mem_format.html#a0">MemFormat::MemFormat</a>(<a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html">Device</a> *pDev, size_t maxBuf)
00032 {
00033 
00034     rd_size = 1;
00035     rd_addr = 0;
00036     rd_count = 1;
00037 
00038     wr_size = 1;
00039     wr_addr = 0;
00040     wr_count = 1;
00041     
00042     pMem = pDev;
00043 
00044     MaxBlockSize = maxBuf;  <span class="comment">// Allocate this much buffer space</span>
00045               
00046     buf8 = <span class="keyword">new</span> uint8_t[MaxBlockSize];
00047     buf16 = <span class="keyword">new</span> uint16_t[MaxBlockSize / 2];
00048     buf32 = <span class="keyword">new</span> uint32_t[MaxBlockSize / 4];
00049 }
00050 
00051 
<a name="l00055"></a><a class="code" href="class_lattice_semi___p_c_ie_1_1_mem_format.html#a1">00055</a> <a class="code" href="class_lattice_semi___p_c_ie_1_1_mem_format.html#a1">MemFormat::~MemFormat</a>()
00056 {
00057      <span class="keyword">delete</span> buf8;         
00058      <span class="keyword">delete</span> buf16;         
00059      <span class="keyword">delete</span> buf32;         
00060 }
00061 
00062 
<a name="l00079"></a><a class="code" href="class_lattice_semi___p_c_ie_1_1_mem_format.html#a2">00079</a> <span class="keywordtype">bool</span> <a class="code" href="class_lattice_semi___p_c_ie_1_1_mem_format.html#a2">MemFormat::doCmd</a>(<span class="keywordtype">char</span> *cmdStr, string &amp;results)
00080 {
00081      <span class="keywordtype">char</span> cmd[80];
00082      <span class="keywordtype">int</span> i, n, nVals;
00083      uint32_t addr, count;
00084      uint8_t val8;
00085      uint16_t val16;
00086      uint32_t val32;
00087      
00088      <span class="comment">// Remove any white space at beginning</span>
00089      cmdStr = strip(cmdStr);
00090      
00091     <span class="keywordflow">try</span>
00092     {
00093 
00094          <span class="comment">// parse command</span>
00095          <span class="keywordflow">switch</span> (cmdStr[0])
00096          {
00097                 <span class="keywordflow">case</span> <span class="charliteral">'r'</span>:   <span class="comment">// read:  r [addr [count]]</span>
00098                 <span class="keywordflow">case</span> <span class="charliteral">'R'</span>:
00099                     n = sscanf(cmdStr, <span class="stringliteral">"%s %x %d"</span>, cmd, &amp;addr, &amp;count);
00100 
00101                     <span class="keywordflow">if</span> (cmd[0] != <span class="charliteral">'r'</span>)
00102                        <span class="keywordflow">return</span>(<span class="keyword">false</span>);
00103             <span class="keywordflow">if</span> (cmd[1] == <span class="charliteral">'b'</span>)
00104                rd_size = 1;
00105             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cmd[1] == <span class="charliteral">'s'</span>)
00106                rd_size = 2;
00107             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cmd[1] == <span class="charliteral">'l'</span>)
00108                rd_size = 4;
00109                
00110                     <span class="keywordflow">if</span> (count * rd_size &gt; MaxBlockSize)
00111                        count = MaxBlockSize/ rd_size;
00112 
00113 
00114                     <span class="keywordflow">if</span> (n == 1)
00115                     {
00116                         rd_addr = rd_addr + rd_count;
00117                     }
00118                     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (n == 2)
00119                     {
00120                         rd_addr = addr;
00121                     }
00122                     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (n == 3)
00123                     {
00124                         rd_addr = addr;
00125                         rd_count = count;
00126                     }
00127                     <span class="comment">// perform operation based on size</span>
00128                     <span class="keywordflow">switch</span> (rd_size)
00129                     {
00130                    <span class="keywordflow">case</span> 1:
00131                     <span class="keywordflow">if</span> (rd_count == 1)
00132                     buf8[0] = pMem-&gt;<a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a3">read8</a>(rd_addr);
00133                     <span class="keywordflow">else</span>
00134                     pMem-&gt;<a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a3">read8</a>(rd_addr, buf8, rd_count);
00135                     <a class="code" href="class_lattice_semi___p_c_ie_1_1_mem_format.html#e0">formatBlockOfBytes</a>(results, rd_addr, rd_count, buf8);
00136                     <span class="keywordflow">break</span>;
00137 
00138                    <span class="keywordflow">case</span> 2:
00139                     <span class="keywordflow">if</span> (rd_count == 1)
00140                     buf16[0] = pMem-&gt;<a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a5">read16</a>(rd_addr);
00141                     <span class="keywordflow">else</span>
00142                     pMem-&gt;<a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a5">read16</a>(rd_addr, buf16, rd_count);
00143                     <a class="code" href="class_lattice_semi___p_c_ie_1_1_mem_format.html#e1">formatBlockOfShorts</a>(results, rd_addr, rd_count, buf16);
00144                     <span class="keywordflow">break</span>;
00145                     
00146                    <span class="keywordflow">case</span> 4:
00147                     <span class="keywordflow">if</span> (rd_count == 1)
00148                     buf32[0] = pMem-&gt;<a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a7">read32</a>(rd_addr);
00149                     <span class="keywordflow">else</span>
00150                     pMem-&gt;<a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a7">read32</a>(rd_addr, buf32, rd_count);
00151                     <a class="code" href="class_lattice_semi___p_c_ie_1_1_mem_format.html#e2">formatBlockOfWords</a>(results, rd_addr, rd_count, buf32);
00152                     <span class="keywordflow">break</span>;
00153             }
00154                     <span class="keywordflow">break</span>;
00155 
00156                 <span class="keywordflow">case</span> <span class="charliteral">'w'</span>:  <span class="comment">// write:  w &lt;address&gt; [data_1]...[data_n]</span>
00157                 <span class="keywordflow">case</span> <span class="charliteral">'W'</span>:
00158                     n = sscanf(cmdStr, <span class="stringliteral">"%s %x %x"</span>, cmd, &amp;addr, &amp;val32);
00159                     <span class="keywordflow">if</span> (n == 2)
00160                        <span class="keywordflow">return</span>(<span class="keyword">false</span>);   <span class="comment">// nothing to do</span>
00161                     <span class="keywordflow">if</span> (cmd[0] != <span class="charliteral">'w'</span>)
00162                        <span class="keywordflow">return</span>(<span class="keyword">false</span>);
00163             <span class="keywordflow">if</span> (cmd[1] == <span class="charliteral">'b'</span>)
00164                wr_size = 1;
00165             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cmd[1] == <span class="charliteral">'s'</span>)
00166                wr_size = 2;
00167             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cmd[1] == <span class="charliteral">'l'</span>)
00168                wr_size = 4;
00169                     <span class="keywordflow">if</span> (n == 1)
00170                        <span class="keywordflow">return</span>(<span class="keyword">true</span>);   <span class="comment">// changed write mode, but nothing to write</span>
00171 
00172             <span class="comment">// Parse the list of hex values</span>
00173             nVals = parseHexList(cmdStr, 2, buf32);
00174             <span class="keywordflow">if</span> (nVals == 0)
00175                <span class="keywordflow">return</span>(<span class="keyword">false</span>);  <span class="comment">// Something went wrong, nothing to write</span>
00176             wr_addr = addr;
00177                
00178                     <span class="comment">// perform operation based on size</span>
00179                     <span class="keywordflow">switch</span> (wr_size)
00180                     {
00181                    <span class="keywordflow">case</span> 1:
00182                     results = <span class="stringliteral">"wr8"</span>;
00183                     <span class="keywordflow">if</span> (nVals == 1)
00184                     {
00185                           val8 = (uint8_t)buf32[0];
00186                           pMem-&gt;<a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a4">write8</a>(wr_addr, val8);
00187                     }
00188                     <span class="keywordflow">else</span>
00189                     {
00190                     <span class="keywordflow">for</span> (i = 0; i &lt; nVals; i++)
00191                         buf8[i] = (uint8_t)buf32[i];         
00192                     pMem-&gt;<a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a4">write8</a>(wr_addr, buf8, nVals);
00193                     }    
00194                     <span class="keywordflow">break</span>;
00195 
00196                    <span class="keywordflow">case</span> 2:
00197                     results = <span class="stringliteral">"wr16"</span>;
00198                     <span class="keywordflow">if</span> (nVals == 1)
00199                     {
00200                           val16 = (uint16_t)buf32[0];
00201                           pMem-&gt;<a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a6">write16</a>(wr_addr, val16);
00202                     }
00203                     <span class="keywordflow">else</span>
00204                     {
00205                     <span class="keywordflow">for</span> (i = 0; i &lt; nVals; i++)
00206                         buf16[i] = (uint16_t)buf32[i];         
00207                     pMem-&gt;<a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a6">write16</a>(wr_addr, buf16, nVals);
00208                     }    
00209                     <span class="keywordflow">break</span>;
00210                     
00211                    <span class="keywordflow">case</span> 4:
00212                     results = <span class="stringliteral">"wr32"</span>;
00213                     <span class="keywordflow">if</span> (nVals == 1)
00214                     {
00215                      pMem-&gt;<a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a8">write32</a>(wr_addr, buf32[0]);
00216                     }
00217                     <span class="keywordflow">else</span>
00218                     {
00219                     pMem-&gt;<a class="code" href="class_lattice_semi___p_c_ie_1_1_device.html#a8">write32</a>(wr_addr, buf32, nVals);
00220                     }    
00221                     <span class="keywordflow">break</span>;
00222             }
00223                 
00224                     <span class="keywordflow">break</span>;
00225         
00226            <span class="keywordflow">default</span>:
00227                <span class="keywordflow">return</span>(<span class="keyword">false</span>);
00228         }
00229     }
00230     <span class="keywordflow">catch</span> (std::exception &amp;e)
00231     {
00232         cout&lt;&lt;<span class="stringliteral">"\nMemFormat or Access Error: "</span>&lt;&lt;e.what()&lt;&lt;endl;
00233         <span class="keywordflow">return</span>(<span class="keyword">false</span>);
00234     }
00235     
00236     <span class="keywordflow">return</span>(<span class="keyword">true</span>);
00237 }
00238 
00239 
00240 
00241 
<a name="l00254"></a><a class="code" href="class_lattice_semi___p_c_ie_1_1_mem_format.html#e0">00254</a> <span class="keywordtype">bool</span> <a class="code" href="class_lattice_semi___p_c_ie_1_1_mem_format.html#e0">MemFormat::formatBlockOfBytes</a>(string &amp;ostr, uint32_t startAddr, uint32_t len, uint8_t *data)
00255 {
00256     uint32_t i, j;
00257     uint32_t addr;
00258     <span class="keywordtype">char</span> *blank;
00259     <span class="keywordtype">char</span> buf[256];
00260 
00261     <span class="keywordflow">if</span> (len == 1)
00262     {
00263         sprintf(buf, <span class="stringliteral">"%08x: %02x\n"</span>, startAddr, *data);
00264         ostr.append(buf);
00265         <span class="keywordflow">return</span>(<span class="keyword">true</span>);
00266     }
00267 
00268     <span class="keywordflow">if</span> (len &gt; 8)
00269     {
00270         ostr.append(<span class="stringliteral">"\n"</span>);  <span class="comment">/* can't fit all on one line so start its own block */</span>
00271         blank = <span class="stringliteral">"    "</span>;
00272     }
00273     <span class="keywordflow">else</span>
00274     {
00275         blank = <span class="stringliteral">""</span>;
00276 
00277     }
00278 
00279     addr = (startAddr &amp; 0xfffffff0);
00280     len = len + (startAddr - addr);
00281 
00282     j = 0;
00283 
00284 
00285     <span class="keywordflow">for</span> (i = 0; i &lt; len; i++)
00286     {
00287         <span class="keywordflow">if</span> ((i % 16) == 0)
00288         {
00289             <span class="keywordflow">if</span> (i &gt; 0)
00290                 sprintf(buf, <span class="stringliteral">"\n%08x:"</span>, addr);
00291             <span class="keywordflow">else</span>
00292                 sprintf(buf, <span class="stringliteral">"%08x:"</span>, startAddr);
00293             ostr.append(buf);
00294         }
00295         <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((i % 8) == 0)
00296         {
00297             ostr.append(<span class="stringliteral">"  "</span>);  <span class="comment">// put a little space between 8 cols and 8 cols</span>
00298         }
00299 
00300         <span class="keywordflow">if</span> (addr &lt; startAddr)
00301             ostr.append(blank);
00302         <span class="keywordflow">else</span>
00303         {
00304             sprintf(buf, <span class="stringliteral">"  %02x"</span>, data[j]);
00305             ostr.append(buf);
00306             ++j;
00307         }
00308 
00309         ++addr;
00310     }
00311 
00312     ostr.append(<span class="stringliteral">"\n"</span>);
00313 
00314     <span class="keywordflow">return</span>(<span class="keyword">true</span>);
00315 }
00316 
00317 
00318 
<a name="l00331"></a><a class="code" href="class_lattice_semi___p_c_ie_1_1_mem_format.html#e1">00331</a> <span class="keywordtype">bool</span> <a class="code" href="class_lattice_semi___p_c_ie_1_1_mem_format.html#e1">MemFormat::formatBlockOfShorts</a>(string &amp;ostr, uint32_t startAddr, uint32_t len, uint16_t *data)
00332 {
00333     uint32_t i, j;
00334     uint32_t addr;
00335     <span class="keywordtype">char</span> *blank;
00336     <span class="keywordtype">char</span> buf[256];
00337 
00338     <span class="keywordflow">if</span> (len == 1)
00339     {
00340         sprintf(buf, <span class="stringliteral">"%08x: %04x\n"</span>, startAddr, *data);
00341         ostr.append(buf);
00342         <span class="keywordflow">return</span>(<span class="keyword">true</span>);
00343     }
00344 
00345 
00346     <span class="keywordflow">if</span> (len &gt; 4)
00347     {
00348         ostr.append(<span class="stringliteral">"\n"</span>);  <span class="comment">/* can't fit all on one line so start its own block */</span>
00349         blank = <span class="stringliteral">"      "</span>;
00350     }
00351     <span class="keywordflow">else</span>
00352     {
00353         blank = <span class="stringliteral">""</span>;
00354     }
00355 
00356     addr = (startAddr &amp; 0xfffffff0);
00357     len = len + (startAddr - addr) / 2;
00358 
00359     j = 0;
00360 
00361     <span class="keywordflow">for</span> (i = 0; i &lt; len; i++)
00362     {
00363         <span class="keywordflow">if</span> ((i % 8) == 0)
00364         {
00365             <span class="keywordflow">if</span> (i &gt; 0)
00366                 sprintf(buf, <span class="stringliteral">"\n%08x:"</span>, addr);
00367             <span class="keywordflow">else</span>
00368                 sprintf(buf, <span class="stringliteral">"%08x:"</span>, startAddr);
00369             ostr.append(buf);
00370         }
00371         <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((i % 4) == 0)
00372         {
00373             ostr.append(<span class="stringliteral">"  "</span>);  <span class="comment">// divide output into 2 cols</span>
00374         }
00375 
00376 
00377         <span class="keywordflow">if</span> (addr &lt; startAddr)
00378             ostr.append(blank);
00379         <span class="keywordflow">else</span>
00380         {
00381             sprintf(buf, <span class="stringliteral">"  %04x"</span>, data[j]);
00382             ostr.append(buf);
00383             ++j;
00384         }
00385 
00386         addr = addr + 2;
00387     }
00388 
00389     ostr.append(<span class="stringliteral">"\n"</span>);
00390 
00391     <span class="keywordflow">return</span>(<span class="keyword">true</span>);
00392 }
00393 
00394 
<a name="l00407"></a><a class="code" href="class_lattice_semi___p_c_ie_1_1_mem_format.html#e2">00407</a> <span class="keywordtype">bool</span> <a class="code" href="class_lattice_semi___p_c_ie_1_1_mem_format.html#e2">MemFormat::formatBlockOfWords</a>(string &amp;ostr, uint32_t startAddr, uint32_t len, uint32_t *data)
00408 {
00409     uint32_t i, j;
00410     uint32_t addr;
00411     <span class="keywordtype">char</span> *blank;
00412     <span class="keywordtype">char</span> buf[256];
00413 
00414     <span class="keywordflow">if</span> (len == 1)
00415     {
00416         sprintf(buf, <span class="stringliteral">"%08x: %08x\n"</span>, startAddr, *data);
00417         ostr.append(buf);
00418         <span class="keywordflow">return</span>(<span class="keyword">true</span>);
00419     }
00420 
00421     <span class="keywordflow">if</span> (len &gt; 2)
00422     {
00423         ostr.append(<span class="stringliteral">"\n"</span>);  <span class="comment">/* can't fit all on one line so start its own block */</span>
00424         blank = <span class="stringliteral">"          "</span>;
00425     }
00426     <span class="keywordflow">else</span>
00427     {
00428         blank = <span class="stringliteral">""</span>;
00429     }
00430 
00431     addr = (startAddr &amp; 0xfffffff0);
00432     len = len + (startAddr - addr) / 4;
00433 
00434     j = 0;
00435     <span class="keywordflow">for</span> (i = 0; i &lt; len; i++)
00436     {
00437         <span class="keywordflow">if</span> ((i % 4) == 0)
00438         {
00439             <span class="keywordflow">if</span> (i &gt; 0)
00440                 sprintf(buf, <span class="stringliteral">"\n%08x:"</span>, addr);
00441             <span class="keywordflow">else</span>
00442                 sprintf(buf, <span class="stringliteral">"%08x:"</span>, startAddr);
00443             ostr.append(buf);
00444         }
00445         <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((i % 2) == 0)
00446         {
00447             ostr.append(<span class="stringliteral">"  "</span>);  <span class="comment">// divide output into 2 cols</span>
00448         }
00449 
00450         <span class="keywordflow">if</span> (addr &lt; startAddr)
00451         {
00452             ostr.append(blank);
00453         }
00454         <span class="keywordflow">else</span>
00455         {
00456             sprintf(buf, <span class="stringliteral">"  %08x"</span>, data[j]);
00457             ostr.append(buf);
00458             ++j;
00459         }
00460 
00461         addr = addr + 4;
00462     }
00463 
00464     ostr.append(<span class="stringliteral">"\n"</span>);
00465 
00466     <span class="keywordflow">return</span>(<span class="keyword">true</span>);
00467 }
00468 
00469 
00470 <span class="comment">/*===================================================================================*/</span>
00471 <span class="comment">/*===================================================================================*/</span>
00472 <span class="comment">/*===================================================================================*/</span>
00473 <span class="comment">//                            PRIVATE METHODS</span>
00474 <span class="comment">/*===================================================================================*/</span>
00475 <span class="comment">/*===================================================================================*/</span>
00476 <span class="comment">/*===================================================================================*/</span>
00477 
00482 <span class="keywordtype">char</span>* MemFormat::strip(<span class="keywordtype">char</span> *s)
00483 {
00484     <span class="keywordflow">while</span> (((*s &lt;= 0x21) || ((unsigned char)*s &gt; 0x7f)) &amp;&amp; (*s != <span class="charliteral">'\0'</span>))
00485         ++s;
00486     <span class="keywordflow">return</span>(s);
00487 }
00488 
00489 
00493 <span class="keywordtype">char</span> * MemFormat::skipWhiteSpace(<span class="keywordtype">char</span> *s)
00494 {
00495     <span class="keywordflow">while</span>(*s &lt;= 0x20)
00496     {
00497         <span class="keywordflow">if</span> (*s == <span class="charliteral">'\0'</span>)
00498             <span class="keywordflow">return</span>(NULL);
00499         <span class="keywordflow">else</span>
00500             ++s;  <span class="comment">// next char</span>
00501     }
00502 
00503     <span class="keywordflow">return</span>(s);
00504 }
00505 
00506 
00510 <span class="keywordtype">char</span> * MemFormat::skipWord(<span class="keywordtype">char</span> *s)
00511 {
00512     <span class="keywordflow">while</span>(*s &gt; 0x20)
00513     {
00514         <span class="keywordflow">if</span> (*s == <span class="charliteral">'\0'</span>)
00515             <span class="keywordflow">return</span>(NULL);
00516         <span class="keywordflow">else</span>
00517             ++s;  <span class="comment">// next char</span>
00518     }
00519 
00520     <span class="keywordflow">return</span>(s);
00521 }
00522 
00523 
00532 <span class="keywordtype">int</span> MemFormat::parseHexList(<span class="keywordtype">char</span> *str, <span class="keywordtype">int</span> skip, uint32_t *buf)
00533 {
00534     <span class="keywordtype">char</span> *s;
00535     size_t cnt;
00536 
00537     s = str;
00538 
00539    <span class="keywordflow">while</span> (skip)
00540    {
00541         s = skipWhiteSpace(s);
00542         <span class="keywordflow">if</span> (s == NULL)
00543             <span class="keywordflow">return</span>(-1);
00544         s = skipWord(s);
00545         <span class="keywordflow">if</span> (s == NULL)
00546             <span class="keywordflow">return</span>(-1);
00547         --skip;
00548    }
00549 
00550     s = skipWhiteSpace(s);
00551 
00552     cnt = 0;
00553     <span class="keywordflow">while</span> (s != NULL)
00554     {
00555         <span class="keywordflow">if</span> (sscanf(s, <span class="stringliteral">"%x"</span>, &amp;buf[cnt]) == 1)
00556             ++cnt;
00557         s = skipWord(s);
00558         <span class="keywordflow">if</span> (s == NULL)
00559             <span class="keywordflow">break</span>;
00560         s = skipWhiteSpace(s);
00561         
00562         <span class="keywordflow">if</span> (cnt == MaxBlockSize)
00563            <span class="keywordflow">break</span>;   <span class="comment">// Reached maximum storage space, ignore rest</span>
00564     }
00565 
00566     <span class="keywordflow">return</span>(cnt);
00567 }
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Jul 16 12:05:26 2008 for Lattice PCIe API Manual by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
