// ===========================================================================
// Verilog module generated by IPexpress
// Filename: test_mem_ctrl.v
// Copyright 2010 (c) Lattice Semiconductor Corporation. All rights reserved.
// ===========================================================================

`timescale 1 ps / 1 ps
`include "ddr3_sdram_mem_params.v"
`include "tb_config_params.v"
module  test_mem_ctrl;

/////////////////////////// Command True Table ////////////////////////////////
//_____________________________________________________________________________
//             |  cmd[3:0] |  CKE  |  CS#  |  RAS# |  CAS# |  WE#  |
//READ         |  0001 (1 )|   1   |   0   |   1   |   0   |   1   |
//WRITE        |  0010 (2 )|   1   |   0   |   1   |   0   |   0   |
//READA        |  0011 (3 )|   1   |   0   |   1   |   0   |   1   |    A10 = 1
//WRITEA       |  0100 (4 )|   1   |   0   |   1   |   0   |   0   |    A10 = 1
//PDOWN_ENT    |  0101 (5 )|   0   |   0   |   1   |   1   |   1   |
//             |           |   0   |   1   |   X   |   X   |   X   |
//LOAD_MR      |  0110 (6 )|   1   |   0   |   0   |   0   |   0   |
//REF          |  0111 (7 )|   1   |   0   |   0   |   0   |   1   |
//SEL_REF_ENT  |  1000 (8 )|   0   |   0   |   0   |   0   |   1   |
//SEL_REF_EXIT |  1001 (9 )|   1   |   0   |   1   |   1   |   1   |
//             |           |   1   |   1   |   0(X)|   1(X)|   0(X)|
//NOP          |  1010 (10)|   1   |   0   |   1   |   1   |   1   |
//PDOWN_EXIT   |  1011 (11)|   1   |   0   |   1   |   1   |   1   |
//             |           |   1   |   1   |   1(X)|   0(X)|   1(X)|
//ZQ_LNG       |  1100 (12)|   1   |   0   |   1   |   1   |   0   |    A10 = 1
//ZQ_SHRT      |  1101 (13)|   1   |   0   |   1   |   1   |   0   |    A10 = 0
//_____________________________________________________________________________
/////////////////////////// Command True Table ////////////////////////////////

`define READ         4'b0001
`define WRITE        4'b0010
`define READA        4'b0011
`define WRITEA       4'b0100
`define PDOWN_ENT    4'b0101
`define LMR          4'b0110
`define SEL_REF_ENT  4'b1000
`define SEL_REF_EXIT 4'b1001
`define PDOWN_EXIT   4'b1011
`define ZQ_LNG       4'b1100
`define ZQ_SHRT      4'b1101

parameter LOW = 1'b0;
parameter HIGH = 1'b1;

// ====================================================================
// Internal signals
// ====================================================================
wire   [`DATA_WIDTH-1:0]            ddr_dq;
wire   [`DQS_WIDTH-1:0]             ddr_dqs;
wire   [`DQS_WIDTH-1:0]             inv_ddr_dqs;
wire   [`DQS_WIDTH-1:0]             ddr_dqm;
wire   [`DQS_WIDTH-1:0]             ddr_dqm_temp;
wire   [`DQS_WIDTH-1:0]             ddr_dqs_d;

// ====================================================================
// Registers used by the tasks to drive the input signals of the
// FPGA bridge
// ====================================================================

reg                                 rst_n;
reg    [3:0]                        cmd;
reg                                 cmd_valid;
reg                                 init_start;
reg                                 mem_rst_n;
reg                                 ofly_burst_len;
reg    [4:0]                        ff_burst_count;
reg    [`USER_DM -1:0]              dmsel;
reg    [`ADDR_WIDTH-1:0]            addr;

`ifdef EXT_AUTO_REF
wire                                ext_auto_ref;
`endif
reg    [2:0]                        ar_burst_cnt;
reg    [2:0]                        ar_burst_en;
reg    [3:0]                        db_size;
reg    [15:0]                       trefi;

reg    [`DSIZE-1:0]                 write_data;
reg    [(`DSIZE/8)-1:0]             data_mask;
wire   [`DSIZE-1:0]                 read_data;

// ====================================================================
// Output signals from the controller
// ====================================================================


wire                                cmd_rdy;
wire                                init_done;

wire   [`CKE_WIDTH-1:0]             ddr_cke;
wire                                ddr_ras_n;
wire                                ddr_cas_n;
wire                                ddr_we_n;
wire                                ddr_resetn;
wire   [`CS_WIDTH_BB-1:0]           ddr_cs_n;
wire   [`CS_WIDTH-1 :0]             ddr_odt;
wire   [`ROW_WIDTH-1:0]             ddr_ad;
wire   [`BANK_WIDTH-1:0]            ddr_ba;
wire                                data_rdy;

// ====================================================================
// Clock generation logic and Parameters
// ====================================================================

reg                                 clk_in;     // memory controller clock
wire                                sys_clk;    // memory controller clock
reg                                 mem_clk;    // memory controller clock
wire                                clk;
wire   [`CLKO_WIDTH-1:0]            ddr_clk;    // clock connected to the memory
wire   [`CLKO_WIDTH-1:0]            ddr_clk_n;  // clock connected to the memory
wire                                ddr_clk_d;

GSR GSR_INST (.GSR(rst_n));
PUR PUR_INST (.PUR(1'b1));

//Simulation Clock Cycle in PS
parameter c = 5000;

initial begin
    clk_in         = 0;
    mem_clk        = 0;
    init_start     = 0;
    mem_rst_n      = 1'b1;
    addr           = 0;
    ff_burst_count = 1;
    cmd            = 0;
    dmsel          = 'b0;
    cmd_valid      = 0;
    write_data     = 0;     //  64'h0123456789ABCDEF
    data_mask      = 0;
    ofly_burst_len = 0;
    ar_burst_cnt   = 4;
    ar_burst_en    = `AR_BURST_EN;
    trefi          = `TREFI;
end

always #(c)   clk_in   = ~clk_in;
always #(c/2) mem_clk  = ~mem_clk;

//assign clk = clk_in;
// ====================================================================
// This will provide display of the current settings, good for debugging
// ====================================================================

initial begin
   $display ("// ==================================================");
   $display ("INFO: Current Data Bus Width is %0d bits", `DATA_WIDTH);
   $display ("INFO: Current Addr Bus Width is %0d bits", `ADDR_WIDTH);
   $display ("INFO: Current User Data Bus Width is %0d bits", `DSIZE);
   $display ("INFO: Current User Data Mask Bus Width is %0d bits", `USER_DM);
   $display ("INFO: Current Frequency is %0d MHz", (1000000/c));
   $display ("INFO: Current Clock Period is %2f ns", c/1000.0);
 `ifdef GATE_SIM
   $display ("INFO: Doing Gate Level Simulation");
 `endif
 `ifdef DUMMY_LOGIC
   $display ("INFO: Dummy Logic is used.");
 `endif
   $display ("// ==================================================");
end

reg   dm_toggle;       // 0: data mask=0
                       // 1: random pattern on data mask

initial begin
      dm_toggle = 0;
end

always @(dm_toggle) begin
   if (dm_toggle == 0)
      $display ("INFO: Data Mask is Disabled.\n");
   else if (dm_toggle == 1)
      $display ("INFO: Data Mask is Enabled.\n");
end

assign ddr_dqm     = ddr_dqm_temp;
assign inv_ddr_dqs = ~ddr_dqs;
// ====================================================================
// Instantiate the memory controller module
// ====================================================================

ddr3_sdram_mem_top U1_ddr_sdram_mem_top (
// Local User Interface
    .clk_in           (clk_in),
    .rst_n            (rst_n),
//`ifdef ENB_MEM_RST
    .mem_rst_n       (mem_rst_n),
//`endif 
    .init_start       (init_start),
    .cmd              (cmd),
    .addr             (addr),
    .cmd_burst_cnt    (ff_burst_count),
    .cmd_valid        (cmd_valid),
    .ofly_burst_len   (ofly_burst_len),
    .write_data       (write_data),
    .datain_rdy       (data_rdy),
    .data_mask        (dmsel),
    .read_pulse_tap  (`READ_PULSE_TAP), 

`ifdef EXT_AUTO_REF
    .ext_auto_ref     (ext_auto_ref),
    .ext_auto_ref_ack (ext_auto_ref_ack),
`endif
`ifdef WL_DYNDLY
    .wl_dyndly        (),
`endif
`ifdef DFI_CKE
    .dfi_cke          (),
`endif
    .cmd_rdy          (cmd_rdy),
    .init_done        (init_done),
    .wl_err           (),
    .read_data        (read_data),
    .read_data_valid  (read_data_valid),
    .sclk_out         (clk),
    .clocking_good    (clocking_good),

`ifdef CLK_SWAP
    .em_ddr_clk       (ddr_clk_n),
`else
    .em_ddr_clk       (ddr_clk),
`endif
    .em_ddr_cke       (ddr_cke),
    .em_ddr_addr      (ddr_ad),
    .em_ddr_ba        (ddr_ba),
    .em_ddr_data      (ddr_dq),
    .em_ddr_dm        (ddr_dqm_temp),
    .em_ddr_dqs       (ddr_dqs),
`ifdef ENB_MEM_RST
    .em_ddr_reset_n   (ddr_resetn),
`endif
    .em_ddr_cs_n      (ddr_cs_n),
    .em_ddr_cas_n     (ddr_cas_n),
    .em_ddr_ras_n     (ddr_ras_n),
    .em_ddr_we_n      (ddr_we_n),
    .em_ddr_odt       (ddr_odt)
);

`ifdef ENB_MEM_RST
`else

`define USR_RST_CLK_CNT  8'd20   // 20 x 5ns = 100 ns
reg                   clocking_good_r;
reg                   mem_rst_n_r;
reg    [7:0]          rst_cnt;

always @(negedge rst_n or posedge clk) begin
   if (!rst_n)
      mem_rst_n_r <= 1'b0;
   else
      mem_rst_n_r <= mem_rst_n;
end

always @(negedge rst_n or posedge clk) begin
   if (!rst_n)
      rst_cnt <= 8'h0;
   else if (rst_cnt == `USR_RST_CLK_CNT - 1)
      rst_cnt <= 8'h0;
   else if ((!mem_rst_n && mem_rst_n_r) || |(rst_cnt) )
      rst_cnt <= rst_cnt + 1;
   else
      rst_cnt <= rst_cnt;
end

always @(negedge rst_n or posedge clk) begin
   if (!rst_n)
      clocking_good_r <= 1'b0;
   else if (clocking_good)
      clocking_good_r <= 1'b1;
end

assign ddr_resetn = rst_n & mem_rst_n & ~|(rst_cnt) & clocking_good_r;

`endif

`ifdef CS_WIDTH_4
   `define DUAL_RANK
   `define DIMM2
   `define DIMM_CS_WIDTH 2
`endif

`ifdef CS_WIDTH_2
  `ifdef DUAL_RANK
    `define DIMM_CS_WIDTH 2
  `else
    `define DIMM2
    `define DIMM_CS_WIDTH 1
  `endif
`endif

`ifdef CS_WIDTH_1
  `define DIMM_CS_WIDTH 1
`endif


//--------------- DIMM 0 --------------------------------------

`ifdef RDIMM
   `ifdef DATA_SIZE_72
      ddr3_rdimm_72
   `endif
   `ifdef DATA_SIZE_64
      ddr3_rdimm_64
   `endif
   `ifdef DATA_SIZE_56
      ddr3_rdimm_56
   `endif
   `ifdef DATA_SIZE_48
      ddr3_rdimm_48
   `endif
   `ifdef DATA_SIZE_40
      ddr3_rdimm_40
   `endif
   `ifdef DATA_SIZE_32
      ddr3_rdimm_32
   `endif
   `ifdef DATA_SIZE_24
      ddr3_rdimm_24
   `endif
   `ifdef DATA_SIZE_16
      ddr3_rdimm_16
   `endif
   `ifdef DATA_SIZE_8
      ddr3_rdimm_8
   `endif

`else

`ifdef DATA_SIZE_72
   ddr3_dimm_72
`endif
`ifdef DATA_SIZE_64
   ddr3_dimm_64
`endif
`ifdef DATA_SIZE_56
   ddr3_dimm_56
`endif
`ifdef DATA_SIZE_48
   ddr3_dimm_48
`endif
`ifdef DATA_SIZE_40
   ddr3_dimm_40
`endif
`ifdef DATA_SIZE_32
   ddr3_dimm_32
`endif
`ifdef DATA_SIZE_24
   ddr3_dimm_24
`endif
`ifdef DATA_SIZE_16
   ddr3_dimm_16
`endif
`ifdef DATA_SIZE_8
   ddr3_dimm_8
`endif

`endif

    U0_ddr3_dimm (
        .rst_n              (ddr_resetn),
        .ddr_dq             (ddr_dq),
        .ddr_dqs            (ddr_dqs),
        .ddr_dqs_n          (inv_ddr_dqs),
        .ddr_dm_tdqs        (ddr_dqm),
        .ddr_ad             (ddr_ad),
        .ddr_ba             (ddr_ba),
        .ddr_ras_n          (ddr_ras_n),
        .ddr_cas_n          (ddr_cas_n),
        .ddr_we_n           (ddr_we_n),
        .ddr_cs_n           (ddr_cs_n[`DIMM_CS_WIDTH-1:0]),
        .ddr_clk            (ddr_clk[`DIMM_CS_WIDTH-1:0]),
        .ddr_clk_n          (~ddr_clk[`DIMM_CS_WIDTH-1:0]),
        .ddr_cke            (ddr_cke[`DIMM_CS_WIDTH-1:0]),
        .ddr_odt            (ddr_odt[`DIMM_CS_WIDTH-1:0])
    );

//--------------- DIMM 1 --------------------------------------
`ifdef DIMM2

`ifdef RDIMM
   `ifdef DATA_SIZE_72
      ddr3_rdimm_72
   `endif
   `ifdef DATA_SIZE_64
      ddr3_rdimm_64
   `endif
   `ifdef DATA_SIZE_56
      ddr3_rdimm_56
   `endif
   `ifdef DATA_SIZE_48
      ddr3_rdimm_48
   `endif
   `ifdef DATA_SIZE_40
      ddr3_rdimm_40
   `endif
   `ifdef DATA_SIZE_32
      ddr3_rdimm_32
   `endif
   `ifdef DATA_SIZE_24
      ddr3_rdimm_24
   `endif
   `ifdef DATA_SIZE_16
      ddr3_rdimm_16
   `endif
   `ifdef DATA_SIZE_8
      ddr3_rdimm_8
   `endif

`else

   `ifdef DATA_SIZE_72
      ddr3_dimm_72
   `endif
   `ifdef DATA_SIZE_64
      ddr3_dimm_64
   `endif
   `ifdef DATA_SIZE_56
      ddr3_dimm_56
   `endif
   `ifdef DATA_SIZE_48
      ddr3_dimm_48
   `endif
   `ifdef DATA_SIZE_40
      ddr3_dimm_40
   `endif
   `ifdef DATA_SIZE_32
      ddr3_dimm_32
   `endif
   `ifdef DATA_SIZE_24
      ddr3_dimm_24
   `endif
   `ifdef DATA_SIZE_16
      ddr3_dimm_16
   `endif
   `ifdef DATA_SIZE_8
      ddr3_dimm_8
   `endif

`endif //RDIMM

    U1_ddr3_dimm (
        .rst_n              (ddr_resetn),
        .ddr_dq             (ddr_dq),
        .ddr_dqs            (ddr_dqs),
        .ddr_dqs_n          (inv_ddr_dqs),
        .ddr_dm_tdqs        (ddr_dqm),
        .ddr_ad             (ddr_ad),
        .ddr_ba             (ddr_ba),
        .ddr_ras_n          (ddr_ras_n),
        .ddr_cas_n          (ddr_cas_n),
        .ddr_we_n           (ddr_we_n),
        .ddr_cs_n           (ddr_cs_n[`DIMM_CS_WIDTH*2-1:`DIMM_CS_WIDTH]),
        .ddr_clk            (ddr_clk[`DIMM_CS_WIDTH*2-1:`DIMM_CS_WIDTH]),
        .ddr_clk_n          (~ddr_clk[`DIMM_CS_WIDTH*2-1:`DIMM_CS_WIDTH]),
        .ddr_cke            (ddr_cke[`DIMM_CS_WIDTH*2-1:`DIMM_CS_WIDTH]),
        .ddr_odt            (ddr_odt[`DIMM_CS_WIDTH*2-1:`DIMM_CS_WIDTH])
    );
`endif


// ====================================================================
// This file has all the tasks used in the tests to generate stimulus on
// the FPGA interface for the DDR memory controller
// ====================================================================

// ====================================================================
// Instantiate the protocol monitor
// ====================================================================
reg endoftest;

initial begin
    endoftest  = 0;
end

wire [1:0]  burst_len;
wire [31:0] mem_write_cnt;
wire [31:0] mem_read_cnt;
wire [3:0]  cas_latency;
wire [3:0]  cas_write_latency;

monitor U1_monitor (
    .clk                       (clk),
    .mem_clk                   (ddr_clk[0]),
    .rst_n                     (rst_n),
    .endoftest                 (endoftest),
    .cmd                       (cmd),
    .cmd_valid                 (cmd_valid),
    .dmsel                     (dmsel),
    .addr                      (addr),
    .datain                    (write_data),
    .burst_cnt                 (ff_burst_count),
    .init_start                (init_start),
    .init_done                 (init_done),
    .ar_burst_en               (`AR_BURST_EN),
    .db_size                   (db_size),

    .ddr_cke                   (ddr_cke[0]),
    .ddr_we_n                  (ddr_we_n),
    .ddr_cs_n                  (ddr_cs_n[`CS_WIDTH-1:0]),
    .ddr_ad                    (ddr_ad),
    .ddr_ba                    (ddr_ba),
    .ddr_dqm                   (ddr_dqm),
    .ddr_dq                    (ddr_dq),
    .ddr_ras_n                 (ddr_ras_n),
    .ddr_cas_n                 (ddr_cas_n),
    .ddr_dqs                   (ddr_dqs),
    .user_clk                  (clk),
    .dataout                   (read_data),
    .cmd_rdy                   (cmd_rdy),
    .dataout_valid             (read_data_valid),
    .datain_valid              (data_rdy),
    .mem_write_cnt             (mem_write_cnt),
    .mem_read_cnt              (mem_read_cnt),
    .burst_len                 (burst_len),
    .cas_latency_true          (cas_latency),
    .cas_write_latency_true    (cas_write_latency),
    .self_ref_done             (self_ref_done)
);

odt_watchdog U1_odt_watchdog (
    .mem_clk                   (ddr_clk[0]),
    .rst_n                     (rst_n),
    .ddr_cke                   (ddr_cke[0]),
    .ddr_cs_n                  (ddr_cs_n[`CS_WIDTH-1:0]),
    .ddr_ras_n                 (ddr_ras_n),
    .ddr_cas_n                 (ddr_cas_n),
    .ddr_we_n                  (ddr_we_n),
    .ddr_ad                    (ddr_ad),
    .ddr_ba                    (ddr_ba),
    .ddr_dqm                   (ddr_dqm),
    .ddr_dq                    (ddr_dq),
    .ddr_dqs                   (ddr_dqs),
    .ddr_odt                   (ddr_odt),
    .burst_len                 (burst_len),
    .cas_latency               (cas_latency),
    .cas_write_latency         (cas_write_latency),
    .self_ref_done             (self_ref_done)
);

`ifdef EXT_AUTO_REF
auto_ref_gen U1_auto_ref_gen (
    .clk                       (clk),
    .init_done                 (init_done),
    .ext_auto_ref_ack          (ext_auto_ref_ack),
    .ext_auto_ref_req          (ext_auto_ref)
);
`endif

// ====================================================================
// Initialize the static parameters
// ====================================================================

initial begin
   repeat (500000) @(posedge clk);
   $display ("============Testbench INFO: SIMULATION TIMEOUT=============");
   $stop;
end

initial begin
`ifdef DATA_SIZE_72
   db_size  = 4'b1000;
`endif

`ifdef DATA_SIZE_64
   db_size  = 4'b0111;
`endif

`ifdef DATA_SIZE_56
   db_size  = 4'b0110;
`endif

`ifdef DATA_SIZE_48
   db_size  = 4'b0101;
`endif

`ifdef DATA_SIZE_40
   db_size  = 4'b0100;
`endif

`ifdef DATA_SIZE_32
   db_size  = 4'b0011;
`endif

`ifdef DATA_SIZE_24
   db_size  = 4'b0010;
`endif

`ifdef DATA_SIZE_16
   db_size  = 4'b0001;
`endif

`ifdef DATA_SIZE_8
   db_size  = 4'b0000;
`endif
end

// set an flag to check if the monitor checking has passed.
reg error_flg;
reg odt_error_flg;

initial begin
    error_flg = 0;
    odt_error_flg = 0;
end
`include "cmd_gen.v"
`include "testcase.v"

endmodule
