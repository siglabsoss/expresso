// ===========================================================================
// Verilog module generated by IPexpress
// Filename: testcase.v  
// Copyright 2008 (c) Lattice Semiconductor Corporation. All rights reserved.
// ===========================================================================

// load_mr       (cmd_valid_lat, bl, bt, cl, wr)
// write         (cmd_valid_lat, burst_count, row_addr, bank_addr, col_addr, bl_mem, ofly_burst_len)
// read          (cmd_valid_lat, burst_count, row_addr, bank_addr, col_addr, bl_mem, ofly_burst_len)

parameter MAX_CMD_CNT = 8;
reg       otf_bit;

`ifdef BRST_CNT_EN
   parameter BURST_CNT = 15;          // Current setting of burst count
`else
   parameter BURST_CNT = 1;          // Current setting of burst count
`endif

reg [31:0]             wr_cmd_cnt;
reg [31:0]             rd_cmd_cnt;
reg [31:0]             wr_addr;
reg [31:0]             rd_addr;
reg [`BSIZE -1 :0]     ba_addr;
reg [`ROW_WIDTH-1:0]   row_addr;
reg [`COL_WIDTH-1:0]   col_addr;

initial begin
    reset;
    #(20*c);
// initial the memory, the default burst length is 4
    init;
    #(`DELAY*c);
// self refresh
    self_ref     (0);
    #(`DELAY*c);
    self_ref_ext (0);
    #(`DELAY*c);
// power down
    pdown        (0);
    #(`DELAY*c);
    pdown_ext    (0);
    #(`DELAY*c);



// ====================================================================================
//  burst chop 4 operation
// ====================================================================================
    load_mr0     (0, 4, 0, 5, 6);

    #(250*c);
    write       (0, 1, 0, 0, 0, 0);
    #(`DELAY*c);
// burst count 1
    write       (0, 1, 3, 2, 8, 0);
    write       (0, 1, 4, 2, 0, 0);
    write       (0, 1, 5, 2, 0, 0);
    write       (0, 1, 6, 2, 0, 0);
    #(`DELAY*c);
    read        (0, 1, 3, 2, 8, 0);
    #(`DELAY*c);
    write       (0, 1, 3, 2, 0, 0);
    #(`DELAY*c);

// burst count N
    write       (0, 15, 1, 0, 0, 0);
    #(`DELAY*c);
    write       (0, 8, 2, 2, 8, 0);
    #(`DELAY*c);
    read        (0, 12, 1, 0, 0, 0);
    #(`DELAY*c);
    read        (0, 8, 2, 2, 8, 0);
    #(`DELAY*c);

// ====================================================================================
// change burst length to 8
// ====================================================================================

  load_mr0     (0, 8, 0, 5, 6);
    #(`DELAY*c);
// burst count 1
    write       (0, 1, 3, 0, 0, 0);
    #(`DELAY*c);
    read        (0, 1, 3, 0, 0, 0);
   #(`DELAY*c);
    write       (0, 2, 3, 0, 0, 0);
   #(`DELAY*c); 
    read        (0, 2, 3, 0, 0, 0);
    #(`DELAY*c);
    writea      (0, 1, 3, 2, 12, 0);
    #(`DELAY*c);
    read        (0, 1, 3, 2, 12, 0);
    #(`DELAY*c);

// burst count N
    write       (0, 31, 15, 0, 0, 0);
    #(`DELAY*c);
    write       (0, 3, 2, 0, 8, 0);
    #(`DELAY*c);
    read        (0, 31, 15, 0, 0, 0);
    #(`DELAY*c);
    read        (0, 3, 2, 0, 8, 0);
   #(`DELAY*c);

// ====================================================================================
// change BL to OTF, BL is controlled by the ofly_burst_len.
// ====================================================================================

  load_mr0     (0, 0, 0, 5, 6);

  #(250*c);
  
  otf_bit = 1'b0;
  for (wr_cmd_cnt = 0; wr_cmd_cnt < MAX_CMD_CNT; wr_cmd_cnt = wr_cmd_cnt + 1) begin
     wr_addr = wr_cmd_cnt*8;

       col_addr = wr_addr[`COL_WIDTH -1 :0];       
       ba_addr  = wr_addr[`COL_WIDTH + `BSIZE -1 :`COL_WIDTH];       
       row_addr = wr_addr[`COL_WIDTH + `BSIZE -1 + `ROW_WIDTH :`COL_WIDTH + `BSIZE];

     `ifdef DEBUG
         $display ("%t INFO : wr_cmd_cnt is %0d", $time, wr_cmd_cnt); 
     `endif
     write       (0, 1, row_addr, ba_addr, col_addr, otf_bit);
     otf_bit = otf_bit + 1;
     #(`DELAY*c);
  end


  otf_bit = 1'b0;
  for (rd_cmd_cnt = 0; rd_cmd_cnt < MAX_CMD_CNT; rd_cmd_cnt = rd_cmd_cnt + 1) begin
       rd_addr = rd_cmd_cnt*8;

       col_addr = rd_addr[`COL_WIDTH -1 :0];       
       ba_addr  = rd_addr[`COL_WIDTH + `BSIZE -1 :`COL_WIDTH];       
       row_addr = rd_addr[`COL_WIDTH + `BSIZE -1 + `ROW_WIDTH :`COL_WIDTH + `BSIZE];

     `ifdef DEBUG
         $display ("%t INFO : rd_cmd_cnt is %0d", $time, rd_cmd_cnt); 
     `endif
     read       (0, 1, row_addr, ba_addr, col_addr, otf_bit);
     otf_bit = otf_bit + 1;
     #(`DELAY*c);
  end

// ====================================================================================
// OTF with burst cnt N
// ====================================================================================

    #(250*c);
  
  otf_bit = 1'b0;
  for (wr_cmd_cnt = 0; wr_cmd_cnt < MAX_CMD_CNT; wr_cmd_cnt = wr_cmd_cnt + 1) begin
     wr_addr = wr_cmd_cnt*8*BURST_CNT;

       col_addr = wr_addr[`COL_WIDTH -1 :0];       
       ba_addr  = wr_addr[`COL_WIDTH + `BSIZE -1 :`COL_WIDTH];
       row_addr = wr_addr[`COL_WIDTH + `BSIZE -1 + `ROW_WIDTH :`COL_WIDTH + `BSIZE];

     `ifdef DEBUG
         $display ("%t INFO : wr_cmd_cnt is %0d", $time, wr_cmd_cnt); 
     `endif
     write       (0, BURST_CNT, row_addr, ba_addr, col_addr, otf_bit);
     otf_bit = otf_bit + 1;
     #(`DELAY*c);
  end


  otf_bit = 1'b0;
  for (rd_cmd_cnt = 0; rd_cmd_cnt < MAX_CMD_CNT; rd_cmd_cnt = rd_cmd_cnt + 1) begin
       rd_addr = rd_cmd_cnt*8*BURST_CNT;

       col_addr = rd_addr[`COL_WIDTH -1 :0];       
       ba_addr  = rd_addr[`COL_WIDTH + `BSIZE -1 :`COL_WIDTH];       
       row_addr = rd_addr[`COL_WIDTH + `BSIZE -1 + `ROW_WIDTH :`COL_WIDTH + `BSIZE];

     `ifdef DEBUG
         $display ("%t INFO : rd_cmd_cnt is %0d", $time, rd_cmd_cnt); 
     `endif
     read       (0, BURST_CNT, row_addr, ba_addr, col_addr, otf_bit);
     otf_bit = otf_bit + 1;
     #(`DELAY*c);
  end

// ====================================================================================
// end of test
// ====================================================================================
    #(500*c);
    endoftest = 1;
    #c;
    endoftest = 0;



$stop;

end
