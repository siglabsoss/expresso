--=============================================================================
-- VHDL module generated by IPExpress    01/20/2010    14:16:54          
-- Filename: sgdmac_top.vhd 
-- Copyright(c) 2008 Lattice Semiconductor Corporation. All rights reserved.   
--=============================================================================

-- =============================================================================
--                           COPYRIGHT NOTICE
-- Copyright 2007 (c) Lattice Semiconductor Corporation
-- ALL RIGHTS RESERVED
-- This confidential and proprietary software may be used only as authorised
-- by a licensing agreement from Lattice Semiconductor Corporation.
-- The entire notice above must be reproduced on all authorized copies and
-- copies may only be made to the extent permitted by a licensing agreement
-- from Lattice Semiconductor Corporation.
--
-- Lattice Semiconductor Corporation    TEL : 1-800-Lattice (USA and Canada)
-- 5555 NE Moore Court                        408-826-6000 (other locations)
-- Hillsboro, OR 97124                  web  : http://www.latticesemi.com/
-- U.S.A                                email: techsupport@latticesemi.com
-- =============================================================================
--                         FILE DETAILS
-- Project          : Scatter-Gather DMA Controller
-- File             : sgdmac_core.vhd
-- Title            :
-- Dependencies     :
-- Description      : SGDMAC core top level
-- =============================================================================
--
--  REVISION HISTORY
--
-- Revision 0.0  2007/03/15 dap
-- Initial version
--
-- =============================================================================

-- bogus wishbone port terminator
library IEEE; 
use IEEE.std_logic_1164.all;
use IEEE.std_logic_unsigned.all;
entity wbterm is generic(
       DWIDTH : integer := 32;
       AWIDTH : integer := 32);
     port (
       clk  : in  std_logic;
       rstn : in  std_logic;
       cyc  : in  std_logic;
       stb  : in  std_logic;
       we   : in  std_logic;
       sel  : in  std_logic_vector(DWIDTH/8-1 downto 0);
       addr : in  std_logic_vector(AWIDTH  -1 downto 0);
       wdat : in  std_logic_vector(DWIDTH  -1 downto 0);
       rdat : out std_logic_vector(DWIDTH  -1 downto 0);  
       lock : in  std_logic; 
       cti  : in  std_logic_vector(2 downto 0);         
       ack  : out std_logic;
       err  : out std_logic;
       retry: out std_logic;
       eod  : out std_logic);
end entity wbterm;

architecture behavior of wbterm is

signal mem     : std_logic_vector(DWIDTH  -1 downto 0);
signal addr_r  : std_logic_vector(AWIDTH  -1 downto 0);
begin  
	
 process(clk, rstn) begin
    if( rstn = '0') then
       mem    <= (others => '0');
       ack    <= '0';
       err    <= '0';
       retry  <= '0';
       eod    <= '0';
       rdat   <= (others => '0');
       addr_r <= (others => '0');
    elsif (clk'event and clk = '1') then
       ack    <= lock;
       err    <= cti(2);
       retry  <= cti(1);
       eod    <= cti(0);
       addr_r <= addr;
       if ( addr_r = 0 ) then
          rdat <= mem;
       end if;
       if( (cyc and stb and we) = '1' ) then
          mem <= wdat;
       end if;
    end if;
  end process;

end behavior;

library IEEE; 
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
entity sgdmac_top is port(
    clk  : in std_logic;
    rstn : in std_logic;
    rst_core : in std_logic;
    
    -- Slave Interface
    sgs_addr : in  std_logic_vector(32-1 downto 0);
    sgs_wdat : in  std_logic_vector(31 downto 0);
    sgs_rdat : out std_logic_vector(31 downto 0);
    sgs_cyc  : in  std_logic;
    sgs_stb  : in  std_logic;
    sgs_sel  : in  std_logic_vector(3 downto 0);
    sgs_we   : in  std_logic;
    sgs_ack  : out std_logic;
    sgs_err  : out std_logic;
    
    -- Interrupt and Control
    dma_req        : in  std_logic_vector(2-1 downto 0);
    dma_ack        : out std_logic_vector(2-1 downto 0);
    eventx         : out std_logic_vector(2-1 downto 0);
    errorx         : out std_logic_vector(2-1 downto 0);
    actchan        : out std_logic_vector(1-1 downto 0);
    subchan        : out std_logic_vector(1-1 downto 0);
    a_active       : out std_logic;
    b_active       : out std_logic;
    p_active       : out std_logic;
    max_burst_size : out std_logic_vector(15 downto 0);
    auxctrl        : out std_logic_vector(15 downto 0);
    auxstat        : in  std_logic_vector(15 downto 0));
end sgdmac_top;

architecture behavior of sgdmac_top is
component sgdma port (
        clk     : in  std_logic;
        rstn    : in  std_logic;
        rst_core    : in  std_logic;
        a_cyc   : out std_logic;
        a_stb   : out std_logic;
        a_lock  : out std_logic;
        a_we    : out std_logic;
        a_cti   : out std_logic_vector(2 downto 0);
        a_sel   : out std_logic_vector(8-1 downto 0);
        a_addr  : out std_logic_vector(32-1 downto 0);
        a_wdat  : out std_logic_vector(64-1 downto 0);
        a_rdat  : in  std_logic_vector(64-1 downto 0);
        a_ack   : in  std_logic;
        a_err   : in  std_logic;
        a_retry : in  std_logic;
        a_eod   : in  std_logic;
        b_cyc   : out std_logic;
        b_stb   : out std_logic;
        b_lock  : out std_logic;
        b_we    : out std_logic;
        b_cti   : out std_logic_vector(2 downto 0);
        b_sel   : out std_logic_vector(8-1 downto 0);
        b_addr  : out std_logic_vector(32-1 downto 0);
        b_wdat  : out std_logic_vector(64-1 downto 0);
        b_rdat  : in  std_logic_vector(64-1 downto 0);
        b_ack   : in  std_logic;
        b_err   : in  std_logic;
        b_retry : in  std_logic;
        b_eod   : in  std_logic;
        b_active: out std_logic;
        saddr   : in  std_logic_vector(32-1 downto 0);
        swdat   : in  std_logic_vector(31 downto 0);
        srdat   : out std_logic_vector(31 downto 0);
        scyc    : in  std_logic;
        sstb    : in  std_logic;
        ssel    : in  std_logic_vector(3 downto 0);
        swe     : in  std_logic;
        sack    : out std_logic;
        serr    : out std_logic;
        dma_req : in  std_logic_vector(2-1 downto 0);
        dma_ack : out std_logic_vector(2-1 downto 0);
        eventx  : out std_logic_vector(2-1 downto 0);
        errorx  : out std_logic_vector(2-1 downto 0);
        actchan : out std_logic_vector(1-1 downto 0);
        subchan : out std_logic_vector(1-1 downto 0);
        a_active: out std_logic;
        max_burst_size: out std_logic_vector(15 downto 0);
        bd_waddr: out std_logic_vector (10-1 downto 0);
        bd_raddr: out std_logic_vector (10-1 downto 0);
        bd_wdat : out std_logic_vector (31 downto 0) ;
        bd_rdat :  in std_logic_vector (31 downto 0) ;
        bd_we   : out  std_logic;
        bd_re   : out  std_logic;
        bd_rval : in   std_logic);
end component sgdma;

component pmi_ram_dp
   generic (
     pmi_wr_addr_depth : integer := 512; 
     pmi_wr_addr_width : integer := 9; 
     pmi_wr_data_width : integer := 18; 
     pmi_rd_addr_depth : integer := 512; 
     pmi_rd_addr_width : integer := 9; 
     pmi_rd_data_width : integer := 18; 
     pmi_regmode : string := "reg"; 
     pmi_gsr : string := "disable"; 
     pmi_resetmode : string := "sync"; 
     pmi_init_file : string := "none"; 
     pmi_init_file_format : string := "binary"; 
     pmi_family : string := "EC"; 
     module_type : string := "pmi_ram_dp" 
  );
  port (
   Data : in std_logic_vector((pmi_wr_data_width-1) downto 0);
   WrAddress : in std_logic_vector((pmi_wr_addr_width-1) downto 0);
   RdAddress : in std_logic_vector((pmi_rd_addr_width-1) downto 0);
   WrClock: in std_logic;
   RdClock: in std_logic;
   WrClockEn: in std_logic;
   RdClockEn: in std_logic;
   WE: in std_logic;
   Reset: in std_logic;
   Q : out std_logic_vector((pmi_rd_data_width-1) downto 0)
 );
end component pmi_ram_dp;

component wbterm generic(
       DWIDTH : integer := 32;
       AWIDTH : integer := 32);
     port (
       clk  : in  std_logic;
       rstn : in  std_logic;
       cyc  : in  std_logic;
       stb  : in  std_logic;
       we   : in  std_logic;
       sel  : in  std_logic_vector(DWIDTH/8-1 downto 0);
       addr : in  std_logic_vector(AWIDTH  -1 downto 0);
       wdat : in  std_logic_vector(DWIDTH  -1 downto 0);
       rdat : out std_logic_vector(DWIDTH  -1 downto 0);  
       lock : in  std_logic; 
       cti  : in  std_logic_vector(2 downto 0);         
       ack  : out std_logic;
       err  : out std_logic;
       retry: out std_logic;
       eod  : out std_logic);
end component wbterm;      

   -- Master Interface, Bus A
signal  sga_addr  : std_logic_vector(32-1    downto 0);
signal  sga_wdat  : std_logic_vector(64-1   downto 0);
signal  sga_rdat  : std_logic_vector(64-1   downto 0);
signal  sga_sel   : std_logic_vector(8-1 downto 0);
signal  sga_we    : std_logic;
signal  sga_cyc   : std_logic;
signal  sga_stb   : std_logic;
signal  sga_lock  : std_logic;
signal  sga_cti   : std_logic_vector(2 downto 0);
signal  sga_ack   : std_logic;
signal  sga_err   : std_logic;
signal  sga_retry : std_logic;
signal  sga_eod   : std_logic;
   
   -- Master Interface, Bus B
signal  sgb_addr  : std_logic_vector(32-1    downto 0);
signal  sgb_wdat  : std_logic_vector(64-1   downto 0);
signal  sgb_rdat  : std_logic_vector(64-1   downto 0);
signal  sgb_sel   : std_logic_vector(8-1 downto 0);
signal  sgb_we    : std_logic;
signal  sgb_cyc   : std_logic;
signal  sgb_stb   : std_logic;
signal  sgb_lock  : std_logic;
signal  sgb_cti   : std_logic_vector(2 downto 0);
signal  sgb_ack   : std_logic;
signal  sgb_err   : std_logic;
signal  sgb_retry : std_logic;
signal  sgb_eod   : std_logic;
   
   -- buffer descriptor RAM interface
signal bd_waddr   : std_logic_vector(10-1 downto 0); 
signal bd_raddr   : std_logic_vector(10-1 downto 0);           
signal bd_wdat    : std_logic_vector(31 downto 0);           	       
signal bd_rdat    : std_logic_vector(31 downto 0);           	       
signal bd_we      : std_logic;               
signal bd_re      : std_logic;               
signal bd_rval    : std_logic;               
   
   -- packet buffer RAM interface
signal pb_waddr   : std_logic_vector(1-1 downto 0);  
signal pb_raddr   : std_logic_vector(1-1 downto 0);     
signal pb_wdat    : std_logic_vector(64-1 downto 0);  
signal pb_rdat    : std_logic_vector(64-1 downto 0); 
signal pb_write   : std_logic;               
signal pb_read    : std_logic;               
signal pb_rval    : std_logic;               

signal bd_access : std_logic;         
signal pb_access : std_logic;         
signal rst       : std_logic;
begin  
	
rst <= not rstn;
	 
    -- instantiate core
dut: sgdma
    port map (
        clk            => clk,
        rstn           => rstn,
        rst_core       => rst_core,
        a_cyc          => sga_cyc,
        a_stb          => sga_stb,
        a_lock         => sga_lock,
        a_we           => sga_we,
        a_cti          => sga_cti,
        a_sel          => sga_sel,
        a_addr         => sga_addr,
        a_wdat         => sga_wdat,
        a_rdat         => sga_rdat,
        a_ack          => sga_ack,
        a_err          => sga_err,
        a_retry        => sga_retry,
        a_eod          => sga_eod,
        b_cyc          => sgb_cyc,
        b_stb          => sgb_stb,
        b_lock         => sgb_lock,
        b_we           => sgb_we,
        b_cti          => sgb_cti,
        b_sel          => sgb_sel,
        b_addr         => sgb_addr,
        b_wdat         => sgb_wdat,
        b_rdat         => sgb_rdat,
        b_ack          => sgb_ack,
        b_err          => sgb_err,
        b_retry        => sgb_retry,
        b_eod          => sgb_eod,
        b_active       => b_active,
        saddr          => sgs_addr,
        swdat          => sgs_wdat,
        srdat          => sgs_rdat,
        scyc           => sgs_cyc,
        sstb           => sgs_stb,
        ssel           => sgs_sel,
        swe            => sgs_we,
        sack           => sgs_ack,
        serr           => sgs_err,
        dma_req        => dma_req,
        dma_ack        => dma_ack,
        eventx         => eventx,
        errorx         => errorx,
        actchan        => actchan,
        subchan        => subchan,
        a_active       => a_active,
        max_burst_size => max_burst_size,
        bd_waddr       => bd_waddr,
        bd_raddr       => bd_raddr,
        bd_wdat        => bd_wdat,
        bd_rdat        => bd_rdat,
        bd_we          => bd_we,
        bd_re          => bd_re,
        bd_rval        => bd_rval
);
    
    -- buffer descriptor RAM
bdram : pmi_ram_dp generic map(
    	pmi_wr_addr_depth    => 256*4,
    	pmi_wr_addr_width    => 10,
    	pmi_wr_data_width    => 32,
    	pmi_rd_addr_depth    => 256*4,
    	pmi_rd_addr_width    => 10,
    	pmi_rd_data_width    => 32,
    	pmi_regmode          => "reg",
    	pmi_gsr              => "disable",
    	pmi_resetmode        => "sync",
    	pmi_init_file        => "none",
    	pmi_init_file_format => "binary",
    	pmi_family           => "ECP2",
    	module_type          => "pmi_ram_dp")
     port map (
    	Data       => bd_wdat,
    	WrAddress  => bd_waddr,
    	RdAddress  => bd_raddr,
    	WrClock    => clk,
    	RdClock    => clk,
    	WrClockEn  => '1',
    	RdClockEn  => '1',
    	WE         => bd_we,
    	Reset      => rst,
    	Q          => bd_rdat);
    
    -- bd_rval generation
    process(clk, rst ) begin
       if( rst = '1') then
          bd_access <= '0';
          bd_rval   <= '0';
       elsif (clk'event and clk = '1') then
          bd_access <= bd_we or bd_re;
          bd_rval   <= bd_access;
       end if;
    end process;

    -- packet buffer RAM
    pbram : pmi_ram_dp generic map(
        pmi_wr_addr_depth   => 0,
        pmi_wr_addr_width   => 1,
        pmi_wr_data_width   => 64,
        pmi_rd_addr_depth   => 0,
        pmi_rd_addr_width   => 1,
        pmi_rd_data_width   => 64,
        pmi_regmode         => "reg",
        pmi_gsr             => "disable",
        pmi_resetmode       => "sync",
        pmi_init_file       => "none",
        pmi_init_file_format=> "binary",
        pmi_family          => "ECP2",
        module_type         => "pmi_ram_dp")
     port map (
        Data       => pb_wdat,
        WrAddress  => pb_waddr,
        RdAddress  => pb_raddr,
        WrClock    => clk,
        RdClock    => clk,
        WrClockEn  => '1',
        RdClockEn  => '1',
        WE         => pb_write,
        Reset      => rst,
        Q          => pb_rdat);
    
    -- packet buffer logic
    process(clk, rst ) begin
       if( rst = '1') then
          pb_access <= '0';
          pb_rval   <= '0';
       elsif (clk'event and clk = '1') then
          pb_access <= pb_write or pb_read;
          pb_rval   <= pb_access;
       end if;
    end process;

	-- bogus wishbone port terminators
     wbterma : wbterm generic map( 
          DWIDTH => 64, 
          AWIDTH => 32)
       port map( 
          clk   => clk, 
          rstn  => rstn,
          cyc   => sga_cyc, 
          stb   => sga_stb, 
          we    => sga_we,
          sel   => sga_sel, 
          addr  => sga_addr, 
          wdat  => sga_wdat,
          rdat  => sga_rdat,
          lock  => sga_lock, 
          cti   => sga_cti,
          ack   => sga_ack, 
          err   => sga_err, 
          retry => sga_retry, 
          eod   => sga_eod);

    wbtermb : wbterm generic map( 
          DWIDTH => 64, 
          AWIDTH => 32 )
     port map(
          clk  => clk, 
          rstn => rstn,
          cyc  => sgb_cyc, 
          stb  => sgb_stb, 
          we   => sgb_we,
          sel  => sgb_sel, 
          addr => sgb_addr, 
          wdat => sgb_wdat,
          rdat => sgb_rdat, 
          lock => sgb_lock, 
          cti  => sgb_cti,
          ack  => sgb_ack, 
          err  => sgb_err, 
          retry=> sgb_retry, 
          eod  => sgb_eod);

end behavior;

